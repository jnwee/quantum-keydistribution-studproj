{"version":3,"file":"5352.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/widgets/dist/index.es6.js"],"sourcesContent":["import { ArrayExt, StringExt, empty, find, max } from '@lumino/algorithm';\nimport { UUID, JSONExt, MimeData } from '@lumino/coreutils';\nimport { ElementExt, Selector, Platform } from '@lumino/domutils';\nimport { Message, ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { Drag } from '@lumino/dragdrop';\nimport { CommandRegistry } from '@lumino/commands';\nimport { VirtualDOM, h } from '@lumino/virtualdom';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A sizer object for use with the box engine layout functions.\n *\n * #### Notes\n * A box sizer holds the geometry information for an object along an\n * arbitrary layout orientation.\n *\n * For best performance, this class should be treated as a raw data\n * struct. It should not typically be subclassed.\n */\nclass BoxSizer {\n    constructor() {\n        /**\n         * The preferred size for the sizer.\n         *\n         * #### Notes\n         * The sizer will be given this initial size subject to its size\n         * bounds. The sizer will not deviate from this size unless such\n         * deviation is required to fit into the available layout space.\n         *\n         * There is no limit to this value, but it will be clamped to the\n         * bounds defined by {@link minSize} and {@link maxSize}.\n         *\n         * The default value is `0`.\n         */\n        this.sizeHint = 0;\n        /**\n         * The minimum size of the sizer.\n         *\n         * #### Notes\n         * The sizer will never be sized less than this value, even if\n         * it means the sizer will overflow the available layout space.\n         *\n         * It is assumed that this value lies in the range `[0, Infinity)`\n         * and that it is `<=` to {@link maxSize}. Failure to adhere to this\n         * constraint will yield undefined results.\n         *\n         * The default value is `0`.\n         */\n        this.minSize = 0;\n        /**\n         * The maximum size of the sizer.\n         *\n         * #### Notes\n         * The sizer will never be sized greater than this value, even if\n         * it means the sizer will underflow the available layout space.\n         *\n         * It is assumed that this value lies in the range `[0, Infinity]`\n         * and that it is `>=` to {@link minSize}. Failure to adhere to this\n         * constraint will yield undefined results.\n         *\n         * The default value is `Infinity`.\n         */\n        this.maxSize = Infinity;\n        /**\n         * The stretch factor for the sizer.\n         *\n         * #### Notes\n         * This controls how much the sizer stretches relative to its sibling\n         * sizers when layout space is distributed. A stretch factor of zero\n         * is special and will cause the sizer to only be resized after all\n         * other sizers with a stretch factor greater than zero have been\n         * resized to their limits.\n         *\n         * It is assumed that this value is an integer that lies in the range\n         * `[0, Infinity)`. Failure to adhere to this constraint will yield\n         * undefined results.\n         *\n         * The default value is `1`.\n         */\n        this.stretch = 1;\n        /**\n         * The computed size of the sizer.\n         *\n         * #### Notes\n         * This value is the output of a call to {@link BoxEngine.calc}. It represents\n         * the computed size for the object along the layout orientation,\n         * and will always lie in the range `[minSize, maxSize]`.\n         *\n         * This value is output only.\n         *\n         * Changing this value will have no effect.\n         */\n        this.size = 0;\n        /**\n         * An internal storage property for the layout algorithm.\n         *\n         * #### Notes\n         * This value is used as temporary storage by the layout algorithm.\n         *\n         * Changing this value will have no effect.\n         */\n        this.done = false;\n    }\n}\n/**\n * The namespace for the box engine layout functions.\n */\nvar BoxEngine;\n(function (BoxEngine) {\n    /**\n     * Calculate the optimal layout sizes for a sequence of box sizers.\n     *\n     * This distributes the available layout space among the box sizers\n     * according to the following algorithm:\n     *\n     * 1. Initialize the sizers's size to its size hint and compute the\n     *    sums for each of size hint, min size, and max size.\n     *\n     * 2. If the total size hint equals the available space, return.\n     *\n     * 3. If the available space is less than the total min size, set all\n     *    sizers to their min size and return.\n     *\n     * 4. If the available space is greater than the total max size, set\n     *    all sizers to their max size and return.\n     *\n     * 5. If the layout space is less than the total size hint, distribute\n     *    the negative delta as follows:\n     *\n     *    a. Shrink each sizer with a stretch factor greater than zero by\n     *       an amount proportional to the negative space and the sum of\n     *       stretch factors. If the sizer reaches its min size, remove\n     *       it and its stretch factor from the computation.\n     *\n     *    b. If after adjusting all stretch sizers there remains negative\n     *       space, distribute the space equally among the sizers with a\n     *       stretch factor of zero. If a sizer reaches its min size,\n     *       remove it from the computation.\n     *\n     * 6. If the layout space is greater than the total size hint,\n     *    distribute the positive delta as follows:\n     *\n     *    a. Expand each sizer with a stretch factor greater than zero by\n     *       an amount proportional to the postive space and the sum of\n     *       stretch factors. If the sizer reaches its max size, remove\n     *       it and its stretch factor from the computation.\n     *\n     *    b. If after adjusting all stretch sizers there remains positive\n     *       space, distribute the space equally among the sizers with a\n     *       stretch factor of zero. If a sizer reaches its max size,\n     *       remove it from the computation.\n     *\n     * 7. return\n     *\n     * @param sizers - The sizers for a particular layout line.\n     *\n     * @param space - The available layout space for the sizers.\n     *\n     * @returns The delta between the provided available space and the\n     *   actual consumed space. This value will be zero if the sizers\n     *   can be adjusted to fit, negative if the available space is too\n     *   small, and positive if the available space is too large.\n     *\n     * #### Notes\n     * The {@link BoxSizer.size} of each sizer is updated with the computed size.\n     *\n     * This function can be called at any time to recompute the layout for\n     * an existing sequence of sizers. The previously computed results will\n     * have no effect on the new output. It is therefore not necessary to\n     * create new sizer objects on each resize event.\n     */\n    function calc(sizers, space) {\n        // Bail early if there is nothing to do.\n        let count = sizers.length;\n        if (count === 0) {\n            return space;\n        }\n        // Setup the size and stretch counters.\n        let totalMin = 0;\n        let totalMax = 0;\n        let totalSize = 0;\n        let totalStretch = 0;\n        let stretchCount = 0;\n        // Setup the sizers and compute the totals.\n        for (let i = 0; i < count; ++i) {\n            let sizer = sizers[i];\n            let min = sizer.minSize;\n            let max = sizer.maxSize;\n            let hint = sizer.sizeHint;\n            sizer.done = false;\n            sizer.size = Math.max(min, Math.min(hint, max));\n            totalSize += sizer.size;\n            totalMin += min;\n            totalMax += max;\n            if (sizer.stretch > 0) {\n                totalStretch += sizer.stretch;\n                stretchCount++;\n            }\n        }\n        // If the space is equal to the total size, return early.\n        if (space === totalSize) {\n            return 0;\n        }\n        // If the space is less than the total min, minimize each sizer.\n        if (space <= totalMin) {\n            for (let i = 0; i < count; ++i) {\n                let sizer = sizers[i];\n                sizer.size = sizer.minSize;\n            }\n            return space - totalMin;\n        }\n        // If the space is greater than the total max, maximize each sizer.\n        if (space >= totalMax) {\n            for (let i = 0; i < count; ++i) {\n                let sizer = sizers[i];\n                sizer.size = sizer.maxSize;\n            }\n            return space - totalMax;\n        }\n        // The loops below perform sub-pixel precision sizing. A near zero\n        // value is used for compares instead of zero to ensure that the\n        // loop terminates when the subdivided space is reasonably small.\n        let nearZero = 0.01;\n        // A counter which is decremented each time a sizer is resized to\n        // its limit. This ensures the loops terminate even if there is\n        // space remaining to distribute.\n        let notDoneCount = count;\n        // Distribute negative delta space.\n        if (space < totalSize) {\n            // Shrink each stretchable sizer by an amount proportional to its\n            // stretch factor. If a sizer reaches its min size it's marked as\n            // done. The loop progresses in phases where each sizer is given\n            // a chance to consume its fair share for the pass, regardless of\n            // whether a sizer before it reached its limit. This continues\n            // until the stretchable sizers or the free space is exhausted.\n            let freeSpace = totalSize - space;\n            while (stretchCount > 0 && freeSpace > nearZero) {\n                let distSpace = freeSpace;\n                let distStretch = totalStretch;\n                for (let i = 0; i < count; ++i) {\n                    let sizer = sizers[i];\n                    if (sizer.done || sizer.stretch === 0) {\n                        continue;\n                    }\n                    let amt = (sizer.stretch * distSpace) / distStretch;\n                    if (sizer.size - amt <= sizer.minSize) {\n                        freeSpace -= sizer.size - sizer.minSize;\n                        totalStretch -= sizer.stretch;\n                        sizer.size = sizer.minSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                        stretchCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size -= amt;\n                    }\n                }\n            }\n            // Distribute any remaining space evenly among the non-stretchable\n            // sizers. This progresses in phases in the same manner as above.\n            while (notDoneCount > 0 && freeSpace > nearZero) {\n                let amt = freeSpace / notDoneCount;\n                for (let i = 0; i < count; ++i) {\n                    let sizer = sizers[i];\n                    if (sizer.done) {\n                        continue;\n                    }\n                    if (sizer.size - amt <= sizer.minSize) {\n                        freeSpace -= sizer.size - sizer.minSize;\n                        sizer.size = sizer.minSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size -= amt;\n                    }\n                }\n            }\n        }\n        // Distribute positive delta space.\n        else {\n            // Expand each stretchable sizer by an amount proportional to its\n            // stretch factor. If a sizer reaches its max size it's marked as\n            // done. The loop progresses in phases where each sizer is given\n            // a chance to consume its fair share for the pass, regardless of\n            // whether a sizer before it reached its limit. This continues\n            // until the stretchable sizers or the free space is exhausted.\n            let freeSpace = space - totalSize;\n            while (stretchCount > 0 && freeSpace > nearZero) {\n                let distSpace = freeSpace;\n                let distStretch = totalStretch;\n                for (let i = 0; i < count; ++i) {\n                    let sizer = sizers[i];\n                    if (sizer.done || sizer.stretch === 0) {\n                        continue;\n                    }\n                    let amt = (sizer.stretch * distSpace) / distStretch;\n                    if (sizer.size + amt >= sizer.maxSize) {\n                        freeSpace -= sizer.maxSize - sizer.size;\n                        totalStretch -= sizer.stretch;\n                        sizer.size = sizer.maxSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                        stretchCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size += amt;\n                    }\n                }\n            }\n            // Distribute any remaining space evenly among the non-stretchable\n            // sizers. This progresses in phases in the same manner as above.\n            while (notDoneCount > 0 && freeSpace > nearZero) {\n                let amt = freeSpace / notDoneCount;\n                for (let i = 0; i < count; ++i) {\n                    let sizer = sizers[i];\n                    if (sizer.done) {\n                        continue;\n                    }\n                    if (sizer.size + amt >= sizer.maxSize) {\n                        freeSpace -= sizer.maxSize - sizer.size;\n                        sizer.size = sizer.maxSize;\n                        sizer.done = true;\n                        notDoneCount--;\n                    }\n                    else {\n                        freeSpace -= amt;\n                        sizer.size += amt;\n                    }\n                }\n            }\n        }\n        // Indicate that the consumed space equals the available space.\n        return 0;\n    }\n    BoxEngine.calc = calc;\n    /**\n     * Adjust a sizer by a delta and update its neighbors accordingly.\n     *\n     * @param sizers - The sizers which should be adjusted.\n     *\n     * @param index - The index of the sizer to grow.\n     *\n     * @param delta - The amount to adjust the sizer, positive or negative.\n     *\n     * #### Notes\n     * This will adjust the indicated sizer by the specified amount, along\n     * with the sizes of the appropriate neighbors, subject to the limits\n     * specified by each of the sizers.\n     *\n     * This is useful when implementing box layouts where the boundaries\n     * between the sizers are interactively adjustable by the user.\n     */\n    function adjust(sizers, index, delta) {\n        // Bail early when there is nothing to do.\n        if (sizers.length === 0 || delta === 0) {\n            return;\n        }\n        // Dispatch to the proper implementation.\n        if (delta > 0) {\n            growSizer(sizers, index, delta);\n        }\n        else {\n            shrinkSizer(sizers, index, -delta);\n        }\n    }\n    BoxEngine.adjust = adjust;\n    /**\n     * Grow a sizer by a positive delta and adjust neighbors.\n     */\n    function growSizer(sizers, index, delta) {\n        // Compute how much the items to the left can expand.\n        let growLimit = 0;\n        for (let i = 0; i <= index; ++i) {\n            let sizer = sizers[i];\n            growLimit += sizer.maxSize - sizer.size;\n        }\n        // Compute how much the items to the right can shrink.\n        let shrinkLimit = 0;\n        for (let i = index + 1, n = sizers.length; i < n; ++i) {\n            let sizer = sizers[i];\n            shrinkLimit += sizer.size - sizer.minSize;\n        }\n        // Clamp the delta adjustment to the limits.\n        delta = Math.min(delta, growLimit, shrinkLimit);\n        // Grow the sizers to the left by the delta.\n        let grow = delta;\n        for (let i = index; i >= 0 && grow > 0; --i) {\n            let sizer = sizers[i];\n            let limit = sizer.maxSize - sizer.size;\n            if (limit >= grow) {\n                sizer.sizeHint = sizer.size + grow;\n                grow = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size + limit;\n                grow -= limit;\n            }\n        }\n        // Shrink the sizers to the right by the delta.\n        let shrink = delta;\n        for (let i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {\n            let sizer = sizers[i];\n            let limit = sizer.size - sizer.minSize;\n            if (limit >= shrink) {\n                sizer.sizeHint = sizer.size - shrink;\n                shrink = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size - limit;\n                shrink -= limit;\n            }\n        }\n    }\n    /**\n     * Shrink a sizer by a positive delta and adjust neighbors.\n     */\n    function shrinkSizer(sizers, index, delta) {\n        // Compute how much the items to the right can expand.\n        let growLimit = 0;\n        for (let i = index + 1, n = sizers.length; i < n; ++i) {\n            let sizer = sizers[i];\n            growLimit += sizer.maxSize - sizer.size;\n        }\n        // Compute how much the items to the left can shrink.\n        let shrinkLimit = 0;\n        for (let i = 0; i <= index; ++i) {\n            let sizer = sizers[i];\n            shrinkLimit += sizer.size - sizer.minSize;\n        }\n        // Clamp the delta adjustment to the limits.\n        delta = Math.min(delta, growLimit, shrinkLimit);\n        // Grow the sizers to the right by the delta.\n        let grow = delta;\n        for (let i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {\n            let sizer = sizers[i];\n            let limit = sizer.maxSize - sizer.size;\n            if (limit >= grow) {\n                sizer.sizeHint = sizer.size + grow;\n                grow = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size + limit;\n                grow -= limit;\n            }\n        }\n        // Shrink the sizers to the left by the delta.\n        let shrink = delta;\n        for (let i = index; i >= 0 && shrink > 0; --i) {\n            let sizer = sizers[i];\n            let limit = sizer.size - sizer.minSize;\n            if (limit >= shrink) {\n                sizer.sizeHint = sizer.size - shrink;\n                shrink = 0;\n            }\n            else {\n                sizer.sizeHint = sizer.size - limit;\n                shrink -= limit;\n            }\n        }\n    }\n})(BoxEngine || (BoxEngine = {}));\n\n/**\n * An object which holds data related to an object's title.\n *\n * #### Notes\n * A title object is intended to hold the data necessary to display a\n * header for a particular object. A common example is the `TabPanel`,\n * which uses the widget title to populate the tab for a child widget.\n *\n * It is the responsibility of the owner to call the title disposal.\n */\nclass Title {\n    /**\n     * Construct a new title.\n     *\n     * @param options - The options for initializing the title.\n     */\n    constructor(options) {\n        this._label = '';\n        this._caption = '';\n        this._mnemonic = -1;\n        this._icon = undefined;\n        this._iconClass = '';\n        this._iconLabel = '';\n        this._className = '';\n        this._closable = false;\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this.owner = options.owner;\n        if (options.label !== undefined) {\n            this._label = options.label;\n        }\n        if (options.mnemonic !== undefined) {\n            this._mnemonic = options.mnemonic;\n        }\n        if (options.icon !== undefined) {\n            this._icon = options.icon;\n        }\n        if (options.iconClass !== undefined) {\n            this._iconClass = options.iconClass;\n        }\n        if (options.iconLabel !== undefined) {\n            this._iconLabel = options.iconLabel;\n        }\n        if (options.caption !== undefined) {\n            this._caption = options.caption;\n        }\n        if (options.className !== undefined) {\n            this._className = options.className;\n        }\n        if (options.closable !== undefined) {\n            this._closable = options.closable;\n        }\n        this._dataset = options.dataset || {};\n    }\n    /**\n     * A signal emitted when the state of the title changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Get the label for the title.\n     *\n     * #### Notes\n     * The default value is an empty string.\n     */\n    get label() {\n        return this._label;\n    }\n    /**\n     * Set the label for the title.\n     */\n    set label(value) {\n        if (this._label === value) {\n            return;\n        }\n        this._label = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the mnemonic index for the title.\n     *\n     * #### Notes\n     * The default value is `-1`.\n     */\n    get mnemonic() {\n        return this._mnemonic;\n    }\n    /**\n     * Set the mnemonic index for the title.\n     */\n    set mnemonic(value) {\n        if (this._mnemonic === value) {\n            return;\n        }\n        this._mnemonic = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the icon renderer for the title.\n     *\n     * #### Notes\n     * The default value is undefined.\n     */\n    get icon() {\n        return this._icon;\n    }\n    /**\n     * Set the icon renderer for the title.\n     *\n     * #### Notes\n     * A renderer is an object that supplies a render and unrender function.\n     */\n    set icon(value) {\n        if (this._icon === value) {\n            return;\n        }\n        this._icon = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the icon class name for the title.\n     *\n     * #### Notes\n     * The default value is an empty string.\n     */\n    get iconClass() {\n        return this._iconClass;\n    }\n    /**\n     * Set the icon class name for the title.\n     *\n     * #### Notes\n     * Multiple class names can be separated with whitespace.\n     */\n    set iconClass(value) {\n        if (this._iconClass === value) {\n            return;\n        }\n        this._iconClass = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the icon label for the title.\n     *\n     * #### Notes\n     * The default value is an empty string.\n     */\n    get iconLabel() {\n        return this._iconLabel;\n    }\n    /**\n     * Set the icon label for the title.\n     *\n     * #### Notes\n     * Multiple class names can be separated with whitespace.\n     */\n    set iconLabel(value) {\n        if (this._iconLabel === value) {\n            return;\n        }\n        this._iconLabel = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the caption for the title.\n     *\n     * #### Notes\n     * The default value is an empty string.\n     */\n    get caption() {\n        return this._caption;\n    }\n    /**\n     * Set the caption for the title.\n     */\n    set caption(value) {\n        if (this._caption === value) {\n            return;\n        }\n        this._caption = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the extra class name for the title.\n     *\n     * #### Notes\n     * The default value is an empty string.\n     */\n    get className() {\n        return this._className;\n    }\n    /**\n     * Set the extra class name for the title.\n     *\n     * #### Notes\n     * Multiple class names can be separated with whitespace.\n     */\n    set className(value) {\n        if (this._className === value) {\n            return;\n        }\n        this._className = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the closable state for the title.\n     *\n     * #### Notes\n     * The default value is `false`.\n     */\n    get closable() {\n        return this._closable;\n    }\n    /**\n     * Set the closable state for the title.\n     *\n     * #### Notes\n     * This controls the presence of a close icon when applicable.\n     */\n    set closable(value) {\n        if (this._closable === value) {\n            return;\n        }\n        this._closable = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Get the dataset for the title.\n     *\n     * #### Notes\n     * The default value is an empty dataset.\n     */\n    get dataset() {\n        return this._dataset;\n    }\n    /**\n     * Set the dataset for the title.\n     *\n     * #### Notes\n     * This controls the data attributes when applicable.\n     */\n    set dataset(value) {\n        if (this._dataset === value) {\n            return;\n        }\n        this._dataset = value;\n        this._changed.emit(undefined);\n    }\n    /**\n     * Test whether the title has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the title.\n     *\n     * #### Notes\n     * It is the responsibility of the owner to call the title disposal.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n}\n\n/**\n * The base class of the lumino widget hierarchy.\n *\n * #### Notes\n * This class will typically be subclassed in order to create a useful\n * widget. However, it can be used directly to host externally created\n * content.\n */\nclass Widget {\n    /**\n     * Construct a new widget.\n     *\n     * @param options - The options for initializing the widget.\n     */\n    constructor(options = {}) {\n        this._flags = 0;\n        this._layout = null;\n        this._parent = null;\n        this._disposed = new Signal(this);\n        this._hiddenMode = Widget.HiddenMode.Display;\n        this.node = Private$j.createNode(options);\n        this.addClass('lm-Widget');\n    }\n    /**\n     * Dispose of the widget and its descendant widgets.\n     *\n     * #### Notes\n     * It is unsafe to use the widget after it has been disposed.\n     *\n     * All calls made to this method after the first are a no-op.\n     */\n    dispose() {\n        // Do nothing if the widget is already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        // Set the disposed flag and emit the disposed signal.\n        this.setFlag(Widget.Flag.IsDisposed);\n        this._disposed.emit(undefined);\n        // Remove or detach the widget if necessary.\n        if (this.parent) {\n            this.parent = null;\n        }\n        else if (this.isAttached) {\n            Widget.detach(this);\n        }\n        // Dispose of the widget layout.\n        if (this._layout) {\n            this._layout.dispose();\n            this._layout = null;\n        }\n        // Dispose the title\n        this.title.dispose();\n        // Clear the extra data associated with the widget.\n        Signal.clearData(this);\n        MessageLoop.clearData(this);\n        AttachedProperty.clearData(this);\n    }\n    /**\n     * A signal emitted when the widget is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Test whether the widget has been disposed.\n     */\n    get isDisposed() {\n        return this.testFlag(Widget.Flag.IsDisposed);\n    }\n    /**\n     * Test whether the widget's node is attached to the DOM.\n     */\n    get isAttached() {\n        return this.testFlag(Widget.Flag.IsAttached);\n    }\n    /**\n     * Test whether the widget is explicitly hidden.\n     */\n    get isHidden() {\n        return this.testFlag(Widget.Flag.IsHidden);\n    }\n    /**\n     * Test whether the widget is visible.\n     *\n     * #### Notes\n     * A widget is visible when it is attached to the DOM, is not\n     * explicitly hidden, and has no explicitly hidden ancestors.\n     */\n    get isVisible() {\n        return this.testFlag(Widget.Flag.IsVisible);\n    }\n    /**\n     * The title object for the widget.\n     *\n     * #### Notes\n     * The title object is used by some container widgets when displaying\n     * the widget alongside some title, such as a tab panel or side bar.\n     *\n     * Since not all widgets will use the title, it is created on demand.\n     *\n     * The `owner` property of the title is set to this widget.\n     */\n    get title() {\n        return Private$j.titleProperty.get(this);\n    }\n    /**\n     * Get the id of the widget's DOM node.\n     */\n    get id() {\n        return this.node.id;\n    }\n    /**\n     * Set the id of the widget's DOM node.\n     */\n    set id(value) {\n        this.node.id = value;\n    }\n    /**\n     * The dataset for the widget's DOM node.\n     */\n    get dataset() {\n        return this.node.dataset;\n    }\n    /**\n     * Get the method for hiding the widget.\n     */\n    get hiddenMode() {\n        return this._hiddenMode;\n    }\n    /**\n     * Set the method for hiding the widget.\n     */\n    set hiddenMode(value) {\n        if (this._hiddenMode === value) {\n            return;\n        }\n        if (this.isHidden) {\n            // Reset styles set by previous mode.\n            this._toggleHidden(false);\n        }\n        if (value == Widget.HiddenMode.Scale) {\n            this.node.style.willChange = 'transform';\n        }\n        else {\n            this.node.style.willChange = 'auto';\n        }\n        this._hiddenMode = value;\n        if (this.isHidden) {\n            // Set styles for new mode.\n            this._toggleHidden(true);\n        }\n    }\n    /**\n     * Get the parent of the widget.\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Set the parent of the widget.\n     *\n     * #### Notes\n     * Children are typically added to a widget by using a layout, which\n     * means user code will not normally set the parent widget directly.\n     *\n     * The widget will be automatically removed from its old parent.\n     *\n     * This is a no-op if there is no effective parent change.\n     */\n    set parent(value) {\n        if (this._parent === value) {\n            return;\n        }\n        if (value && this.contains(value)) {\n            throw new Error('Invalid parent widget.');\n        }\n        if (this._parent && !this._parent.isDisposed) {\n            let msg = new Widget.ChildMessage('child-removed', this);\n            MessageLoop.sendMessage(this._parent, msg);\n        }\n        this._parent = value;\n        if (this._parent && !this._parent.isDisposed) {\n            let msg = new Widget.ChildMessage('child-added', this);\n            MessageLoop.sendMessage(this._parent, msg);\n        }\n        if (!this.isDisposed) {\n            MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);\n        }\n    }\n    /**\n     * Get the layout for the widget.\n     */\n    get layout() {\n        return this._layout;\n    }\n    /**\n     * Set the layout for the widget.\n     *\n     * #### Notes\n     * The layout is single-use only. It cannot be changed after the\n     * first assignment.\n     *\n     * The layout is disposed automatically when the widget is disposed.\n     */\n    set layout(value) {\n        if (this._layout === value) {\n            return;\n        }\n        if (this.testFlag(Widget.Flag.DisallowLayout)) {\n            throw new Error('Cannot set widget layout.');\n        }\n        if (this._layout) {\n            throw new Error('Cannot change widget layout.');\n        }\n        if (value.parent) {\n            throw new Error('Cannot change layout parent.');\n        }\n        this._layout = value;\n        value.parent = this;\n    }\n    /**\n     * Create an iterator over the widget's children.\n     *\n     * @returns A new iterator over the children of the widget.\n     *\n     * #### Notes\n     * The widget must have a populated layout in order to have children.\n     *\n     * If a layout is not installed, the returned iterator will be empty.\n     */\n    *children() {\n        if (this._layout) {\n            yield* this._layout;\n        }\n    }\n    /**\n     * Test whether a widget is a descendant of this widget.\n     *\n     * @param widget - The descendant widget of interest.\n     *\n     * @returns `true` if the widget is a descendant, `false` otherwise.\n     */\n    contains(widget) {\n        for (let value = widget; value; value = value._parent) {\n            if (value === this) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Test whether the widget's DOM node has the given class name.\n     *\n     * @param name - The class name of interest.\n     *\n     * @returns `true` if the node has the class, `false` otherwise.\n     */\n    hasClass(name) {\n        return this.node.classList.contains(name);\n    }\n    /**\n     * Add a class name to the widget's DOM node.\n     *\n     * @param name - The class name to add to the node.\n     *\n     * #### Notes\n     * If the class name is already added to the node, this is a no-op.\n     *\n     * The class name must not contain whitespace.\n     */\n    addClass(name) {\n        this.node.classList.add(name);\n    }\n    /**\n     * Remove a class name from the widget's DOM node.\n     *\n     * @param name - The class name to remove from the node.\n     *\n     * #### Notes\n     * If the class name is not yet added to the node, this is a no-op.\n     *\n     * The class name must not contain whitespace.\n     */\n    removeClass(name) {\n        this.node.classList.remove(name);\n    }\n    /**\n     * Toggle a class name on the widget's DOM node.\n     *\n     * @param name - The class name to toggle on the node.\n     *\n     * @param force - Whether to force add the class (`true`) or force\n     *   remove the class (`false`). If not provided, the presence of\n     *   the class will be toggled from its current state.\n     *\n     * @returns `true` if the class is now present, `false` otherwise.\n     *\n     * #### Notes\n     * The class name must not contain whitespace.\n     */\n    toggleClass(name, force) {\n        if (force === true) {\n            this.node.classList.add(name);\n            return true;\n        }\n        if (force === false) {\n            this.node.classList.remove(name);\n            return false;\n        }\n        return this.node.classList.toggle(name);\n    }\n    /**\n     * Post an `'update-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    update() {\n        MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);\n    }\n    /**\n     * Post a `'fit-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    fit() {\n        MessageLoop.postMessage(this, Widget.Msg.FitRequest);\n    }\n    /**\n     * Post an `'activate-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for posting the message.\n     */\n    activate() {\n        MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);\n    }\n    /**\n     * Send a `'close-request'` message to the widget.\n     *\n     * #### Notes\n     * This is a simple convenience method for sending the message.\n     */\n    close() {\n        MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);\n    }\n    /**\n     * Show the widget and make it visible to its parent widget.\n     *\n     * #### Notes\n     * This causes the {@link isHidden} property to be `false`.\n     *\n     * If the widget is not explicitly hidden, this is a no-op.\n     */\n    show() {\n        if (!this.testFlag(Widget.Flag.IsHidden)) {\n            return;\n        }\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);\n        }\n        this.clearFlag(Widget.Flag.IsHidden);\n        this._toggleHidden(false);\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            MessageLoop.sendMessage(this, Widget.Msg.AfterShow);\n        }\n        if (this.parent) {\n            let msg = new Widget.ChildMessage('child-shown', this);\n            MessageLoop.sendMessage(this.parent, msg);\n        }\n    }\n    /**\n     * Hide the widget and make it hidden to its parent widget.\n     *\n     * #### Notes\n     * This causes the {@link isHidden} property to be `true`.\n     *\n     * If the widget is explicitly hidden, this is a no-op.\n     */\n    hide() {\n        if (this.testFlag(Widget.Flag.IsHidden)) {\n            return;\n        }\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);\n        }\n        this.setFlag(Widget.Flag.IsHidden);\n        this._toggleHidden(true);\n        if (this.isAttached && (!this.parent || this.parent.isVisible)) {\n            MessageLoop.sendMessage(this, Widget.Msg.AfterHide);\n        }\n        if (this.parent) {\n            let msg = new Widget.ChildMessage('child-hidden', this);\n            MessageLoop.sendMessage(this.parent, msg);\n        }\n    }\n    /**\n     * Show or hide the widget according to a boolean value.\n     *\n     * @param hidden - `true` to hide the widget, or `false` to show it.\n     *\n     * #### Notes\n     * This is a convenience method for `hide()` and `show()`.\n     */\n    setHidden(hidden) {\n        if (hidden) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    /**\n     * Test whether the given widget flag is set.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    testFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n    /**\n     * Set the given widget flag.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    setFlag(flag) {\n        this._flags |= flag;\n    }\n    /**\n     * Clear the given widget flag.\n     *\n     * #### Notes\n     * This will not typically be called directly by user code.\n     */\n    clearFlag(flag) {\n        this._flags &= ~flag;\n    }\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     *\n     * #### Notes\n     * Subclasses may reimplement this method as needed.\n     */\n    processMessage(msg) {\n        switch (msg.type) {\n            case 'resize':\n                this.notifyLayout(msg);\n                this.onResize(msg);\n                break;\n            case 'update-request':\n                this.notifyLayout(msg);\n                this.onUpdateRequest(msg);\n                break;\n            case 'fit-request':\n                this.notifyLayout(msg);\n                this.onFitRequest(msg);\n                break;\n            case 'before-show':\n                this.notifyLayout(msg);\n                this.onBeforeShow(msg);\n                break;\n            case 'after-show':\n                this.setFlag(Widget.Flag.IsVisible);\n                this.notifyLayout(msg);\n                this.onAfterShow(msg);\n                break;\n            case 'before-hide':\n                this.notifyLayout(msg);\n                this.onBeforeHide(msg);\n                break;\n            case 'after-hide':\n                this.clearFlag(Widget.Flag.IsVisible);\n                this.notifyLayout(msg);\n                this.onAfterHide(msg);\n                break;\n            case 'before-attach':\n                this.notifyLayout(msg);\n                this.onBeforeAttach(msg);\n                break;\n            case 'after-attach':\n                if (!this.isHidden && (!this.parent || this.parent.isVisible)) {\n                    this.setFlag(Widget.Flag.IsVisible);\n                }\n                this.setFlag(Widget.Flag.IsAttached);\n                this.notifyLayout(msg);\n                this.onAfterAttach(msg);\n                break;\n            case 'before-detach':\n                this.notifyLayout(msg);\n                this.onBeforeDetach(msg);\n                break;\n            case 'after-detach':\n                this.clearFlag(Widget.Flag.IsVisible);\n                this.clearFlag(Widget.Flag.IsAttached);\n                this.notifyLayout(msg);\n                this.onAfterDetach(msg);\n                break;\n            case 'activate-request':\n                this.notifyLayout(msg);\n                this.onActivateRequest(msg);\n                break;\n            case 'close-request':\n                this.notifyLayout(msg);\n                this.onCloseRequest(msg);\n                break;\n            case 'child-added':\n                this.notifyLayout(msg);\n                this.onChildAdded(msg);\n                break;\n            case 'child-removed':\n                this.notifyLayout(msg);\n                this.onChildRemoved(msg);\n                break;\n            default:\n                this.notifyLayout(msg);\n                break;\n        }\n    }\n    /**\n     * Invoke the message processing routine of the widget's layout.\n     *\n     * @param msg - The message to dispatch to the layout.\n     *\n     * #### Notes\n     * This is a no-op if the widget does not have a layout.\n     *\n     * This will not typically be called directly by user code.\n     */\n    notifyLayout(msg) {\n        if (this._layout) {\n            this._layout.processParentMessage(msg);\n        }\n    }\n    /**\n     * A message handler invoked on a `'close-request'` message.\n     *\n     * #### Notes\n     * The default implementation unparents or detaches the widget.\n     */\n    onCloseRequest(msg) {\n        if (this.parent) {\n            this.parent = null;\n        }\n        else if (this.isAttached) {\n            Widget.detach(this);\n        }\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onResize(msg) { }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onUpdateRequest(msg) { }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onFitRequest(msg) { }\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onActivateRequest(msg) { }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onBeforeShow(msg) { }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onAfterShow(msg) { }\n    /**\n     * A message handler invoked on a `'before-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onBeforeHide(msg) { }\n    /**\n     * A message handler invoked on an `'after-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onAfterHide(msg) { }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onBeforeAttach(msg) { }\n    /**\n     * A message handler invoked on an `'after-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onAfterAttach(msg) { }\n    /**\n     * A message handler invoked on a `'before-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onBeforeDetach(msg) { }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onAfterDetach(msg) { }\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onChildAdded(msg) { }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onChildRemoved(msg) { }\n    _toggleHidden(hidden) {\n        if (hidden) {\n            switch (this._hiddenMode) {\n                case Widget.HiddenMode.Display:\n                    this.addClass('lm-mod-hidden');\n                    break;\n                case Widget.HiddenMode.Scale:\n                    this.node.style.transform = 'scale(0)';\n                    this.node.setAttribute('aria-hidden', 'true');\n                    break;\n                case Widget.HiddenMode.ContentVisibility:\n                    // @ts-expect-error content-visibility unknown by DOM lib types\n                    this.node.style.contentVisibility = 'hidden';\n                    this.node.style.zIndex = '-1';\n                    break;\n            }\n        }\n        else {\n            switch (this._hiddenMode) {\n                case Widget.HiddenMode.Display:\n                    this.removeClass('lm-mod-hidden');\n                    break;\n                case Widget.HiddenMode.Scale:\n                    this.node.style.transform = '';\n                    this.node.removeAttribute('aria-hidden');\n                    break;\n                case Widget.HiddenMode.ContentVisibility:\n                    // @ts-expect-error content-visibility unknown by DOM lib types\n                    this.node.style.contentVisibility = '';\n                    this.node.style.zIndex = '';\n                    break;\n            }\n        }\n    }\n}\n/**\n * The namespace for the `Widget` class statics.\n */\n(function (Widget) {\n    (function (HiddenMode) {\n        /**\n         * Set a `lm-mod-hidden` CSS class to hide the widget using `display:none`\n         * CSS from the standard Lumino CSS.\n         */\n        HiddenMode[HiddenMode[\"Display\"] = 0] = \"Display\";\n        /**\n         * Hide the widget by setting the `transform` to `'scale(0)'`.\n         */\n        HiddenMode[HiddenMode[\"Scale\"] = 1] = \"Scale\";\n        /**\n         *Hide the widget by setting the `content-visibility` to `'hidden'`.\n         */\n        HiddenMode[HiddenMode[\"ContentVisibility\"] = 2] = \"ContentVisibility\";\n    })(Widget.HiddenMode || (Widget.HiddenMode = {}));\n    (function (Flag) {\n        /**\n         * The widget has been disposed.\n         */\n        Flag[Flag[\"IsDisposed\"] = 1] = \"IsDisposed\";\n        /**\n         * The widget is attached to the DOM.\n         */\n        Flag[Flag[\"IsAttached\"] = 2] = \"IsAttached\";\n        /**\n         * The widget is hidden.\n         */\n        Flag[Flag[\"IsHidden\"] = 4] = \"IsHidden\";\n        /**\n         * The widget is visible.\n         */\n        Flag[Flag[\"IsVisible\"] = 8] = \"IsVisible\";\n        /**\n         * A layout cannot be set on the widget.\n         */\n        Flag[Flag[\"DisallowLayout\"] = 16] = \"DisallowLayout\";\n    })(Widget.Flag || (Widget.Flag = {}));\n    (function (Msg) {\n        /**\n         * A singleton `'before-show'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it becomes visible.\n         *\n         * This message is **not** sent when the widget is being attached.\n         */\n        Msg.BeforeShow = new Message('before-show');\n        /**\n         * A singleton `'after-show'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it becomes visible.\n         *\n         * This message is **not** sent when the widget is being attached.\n         */\n        Msg.AfterShow = new Message('after-show');\n        /**\n         * A singleton `'before-hide'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it becomes not-visible.\n         *\n         * This message is **not** sent when the widget is being detached.\n         */\n        Msg.BeforeHide = new Message('before-hide');\n        /**\n         * A singleton `'after-hide'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it becomes not-visible.\n         *\n         * This message is **not** sent when the widget is being detached.\n         */\n        Msg.AfterHide = new Message('after-hide');\n        /**\n         * A singleton `'before-attach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it is attached.\n         */\n        Msg.BeforeAttach = new Message('before-attach');\n        /**\n         * A singleton `'after-attach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it is attached.\n         */\n        Msg.AfterAttach = new Message('after-attach');\n        /**\n         * A singleton `'before-detach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget before it is detached.\n         */\n        Msg.BeforeDetach = new Message('before-detach');\n        /**\n         * A singleton `'after-detach'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget after it is detached.\n         */\n        Msg.AfterDetach = new Message('after-detach');\n        /**\n         * A singleton `'parent-changed'` message.\n         *\n         * #### Notes\n         * This message is sent to a widget when its parent has changed.\n         */\n        Msg.ParentChanged = new Message('parent-changed');\n        /**\n         * A singleton conflatable `'update-request'` message.\n         *\n         * #### Notes\n         * This message can be dispatched to supporting widgets in order to\n         * update their content based on the current widget state. Not all\n         * widgets will respond to messages of this type.\n         *\n         * For widgets with a layout, this message will inform the layout to\n         * update the position and size of its child widgets.\n         */\n        Msg.UpdateRequest = new ConflatableMessage('update-request');\n        /**\n         * A singleton conflatable `'fit-request'` message.\n         *\n         * #### Notes\n         * For widgets with a layout, this message will inform the layout to\n         * recalculate its size constraints to fit the space requirements of\n         * its child widgets, and to update their position and size. Not all\n         * layouts will respond to messages of this type.\n         */\n        Msg.FitRequest = new ConflatableMessage('fit-request');\n        /**\n         * A singleton conflatable `'activate-request'` message.\n         *\n         * #### Notes\n         * This message should be dispatched to a widget when it should\n         * perform the actions necessary to activate the widget, which\n         * may include focusing its node or descendant node.\n         */\n        Msg.ActivateRequest = new ConflatableMessage('activate-request');\n        /**\n         * A singleton conflatable `'close-request'` message.\n         *\n         * #### Notes\n         * This message should be dispatched to a widget when it should close\n         * and remove itself from the widget hierarchy.\n         */\n        Msg.CloseRequest = new ConflatableMessage('close-request');\n    })(Widget.Msg || (Widget.Msg = {}));\n    /**\n     * A message class for child related messages.\n     */\n    class ChildMessage extends Message {\n        /**\n         * Construct a new child message.\n         *\n         * @param type - The message type.\n         *\n         * @param child - The child widget for the message.\n         */\n        constructor(type, child) {\n            super(type);\n            this.child = child;\n        }\n    }\n    Widget.ChildMessage = ChildMessage;\n    /**\n     * A message class for `'resize'` messages.\n     */\n    class ResizeMessage extends Message {\n        /**\n         * Construct a new resize message.\n         *\n         * @param width - The **offset width** of the widget, or `-1` if\n         *   the width is not known.\n         *\n         * @param height - The **offset height** of the widget, or `-1` if\n         *   the height is not known.\n         */\n        constructor(width, height) {\n            super('resize');\n            this.width = width;\n            this.height = height;\n        }\n    }\n    Widget.ResizeMessage = ResizeMessage;\n    /**\n     * The namespace for the `ResizeMessage` class statics.\n     */\n    (function (ResizeMessage) {\n        /**\n         * A singleton `'resize'` message with an unknown size.\n         */\n        ResizeMessage.UnknownSize = new ResizeMessage(-1, -1);\n    })(ResizeMessage = Widget.ResizeMessage || (Widget.ResizeMessage = {}));\n    /**\n     * Attach a widget to a host DOM node.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param host - The DOM node to use as the widget's host.\n     *\n     * @param ref - The child of `host` to use as the reference element.\n     *   If this is provided, the widget will be inserted before this\n     *   node in the host. The default is `null`, which will cause the\n     *   widget to be added as the last child of the host.\n     *\n     * #### Notes\n     * This will throw an error if the widget is not a root widget, if\n     * the widget is already attached, or if the host is not attached\n     * to the DOM.\n     */\n    function attach(widget, host, ref = null) {\n        if (widget.parent) {\n            throw new Error('Cannot attach a child widget.');\n        }\n        if (widget.isAttached || widget.node.isConnected) {\n            throw new Error('Widget is already attached.');\n        }\n        if (!host.isConnected) {\n            throw new Error('Host is not attached.');\n        }\n        MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        host.insertBefore(widget.node, ref);\n        MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n    }\n    Widget.attach = attach;\n    /**\n     * Detach the widget from its host DOM node.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will throw an error if the widget is not a root widget,\n     * or if the widget is not attached to the DOM.\n     */\n    function detach(widget) {\n        if (widget.parent) {\n            throw new Error('Cannot detach a child widget.');\n        }\n        if (!widget.isAttached || !widget.node.isConnected) {\n            throw new Error('Widget is not attached.');\n        }\n        MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        widget.node.parentNode.removeChild(widget.node);\n        MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n    }\n    Widget.detach = detach;\n})(Widget || (Widget = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$j;\n(function (Private) {\n    /**\n     * An attached property for the widget title object.\n     */\n    Private.titleProperty = new AttachedProperty({\n        name: 'title',\n        create: owner => new Title({ owner })\n    });\n    /**\n     * Create a DOM node for the given widget options.\n     */\n    function createNode(options) {\n        return options.node || document.createElement(options.tag || 'div');\n    }\n    Private.createNode = createNode;\n})(Private$j || (Private$j = {}));\n\n/**\n * An abstract base class for creating lumino layouts.\n *\n * #### Notes\n * A layout is used to add widgets to a parent and to arrange those\n * widgets within the parent's DOM node.\n *\n * This class implements the base functionality which is required of\n * nearly all layouts. It must be subclassed in order to be useful.\n *\n * Notably, this class does not define a uniform interface for adding\n * widgets to the layout. A subclass should define that API in a way\n * which is meaningful for its intended use.\n */\nclass Layout {\n    /**\n     * Construct a new layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    constructor(options = {}) {\n        this._disposed = false;\n        this._parent = null;\n        this._fitPolicy = options.fitPolicy || 'set-min-size';\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This should be reimplemented to clear and dispose of the widgets.\n     *\n     * All reimplementations should call the superclass method.\n     *\n     * This method is called automatically when the parent is disposed.\n     */\n    dispose() {\n        this._parent = null;\n        this._disposed = true;\n        Signal.clearData(this);\n        AttachedProperty.clearData(this);\n    }\n    /**\n     * Test whether the layout is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Get the parent widget of the layout.\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Set the parent widget of the layout.\n     *\n     * #### Notes\n     * This is set automatically when installing the layout on the parent\n     * widget. The parent widget should not be set directly by user code.\n     */\n    set parent(value) {\n        if (this._parent === value) {\n            return;\n        }\n        if (this._parent) {\n            throw new Error('Cannot change parent widget.');\n        }\n        if (value.layout !== this) {\n            throw new Error('Invalid parent widget.');\n        }\n        this._parent = value;\n        this.init();\n    }\n    /**\n     * Get the fit policy for the layout.\n     *\n     * #### Notes\n     * The fit policy controls the computed size constraints which are\n     * applied to the parent widget by the layout.\n     *\n     * Some layout implementations may ignore the fit policy.\n     */\n    get fitPolicy() {\n        return this._fitPolicy;\n    }\n    /**\n     * Set the fit policy for the layout.\n     *\n     * #### Notes\n     * The fit policy controls the computed size constraints which are\n     * applied to the parent widget by the layout.\n     *\n     * Some layout implementations may ignore the fit policy.\n     *\n     * Changing the fit policy will clear the current size constraint\n     * for the parent widget and then re-fit the parent.\n     */\n    set fitPolicy(value) {\n        // Bail if the policy does not change\n        if (this._fitPolicy === value) {\n            return;\n        }\n        // Update the internal policy.\n        this._fitPolicy = value;\n        // Clear the size constraints and schedule a fit of the parent.\n        if (this._parent) {\n            let style = this._parent.node.style;\n            style.minWidth = '';\n            style.minHeight = '';\n            style.maxWidth = '';\n            style.maxHeight = '';\n            this._parent.fit();\n        }\n    }\n    /**\n     * Process a message sent to the parent widget.\n     *\n     * @param msg - The message sent to the parent widget.\n     *\n     * #### Notes\n     * This method is called by the parent widget to process a message.\n     *\n     * Subclasses may reimplement this method as needed.\n     */\n    processParentMessage(msg) {\n        switch (msg.type) {\n            case 'resize':\n                this.onResize(msg);\n                break;\n            case 'update-request':\n                this.onUpdateRequest(msg);\n                break;\n            case 'fit-request':\n                this.onFitRequest(msg);\n                break;\n            case 'before-show':\n                this.onBeforeShow(msg);\n                break;\n            case 'after-show':\n                this.onAfterShow(msg);\n                break;\n            case 'before-hide':\n                this.onBeforeHide(msg);\n                break;\n            case 'after-hide':\n                this.onAfterHide(msg);\n                break;\n            case 'before-attach':\n                this.onBeforeAttach(msg);\n                break;\n            case 'after-attach':\n                this.onAfterAttach(msg);\n                break;\n            case 'before-detach':\n                this.onBeforeDetach(msg);\n                break;\n            case 'after-detach':\n                this.onAfterDetach(msg);\n                break;\n            case 'child-removed':\n                this.onChildRemoved(msg);\n                break;\n            case 'child-shown':\n                this.onChildShown(msg);\n                break;\n            case 'child-hidden':\n                this.onChildHidden(msg);\n                break;\n        }\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     *\n     * #### Notes\n     * This method is invoked immediately after the layout is installed\n     * on the parent widget.\n     *\n     * The default implementation reparents all of the widgets to the\n     * layout parent widget.\n     *\n     * Subclasses should reimplement this method and attach the child\n     * widget nodes to the parent widget's node.\n     */\n    init() {\n        for (const widget of this) {\n            widget.parent = this.parent;\n        }\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     *\n     * #### Notes\n     * The layout should ensure that its widgets are resized according\n     * to the specified layout space, and that they are sent a `'resize'`\n     * message if appropriate.\n     *\n     * The default implementation of this method sends an `UnknownSize`\n     * resize message to all widgets.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onResize(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The layout should ensure that its widgets are resized according\n     * to the available layout space, and that they are sent a `'resize'`\n     * message if appropriate.\n     *\n     * The default implementation of this method sends an `UnknownSize`\n     * resize message to all widgets.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onUpdateRequest(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onBeforeAttach(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, msg);\n        }\n    }\n    /**\n     * A message handler invoked on an `'after-attach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onAfterAttach(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, msg);\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onBeforeDetach(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, msg);\n        }\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message\n     * to all widgets. It assumes all widget nodes are attached to the\n     * parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onAfterDetach(msg) {\n        for (const widget of this) {\n            MessageLoop.sendMessage(widget, msg);\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onBeforeShow(msg) {\n        for (const widget of this) {\n            if (!widget.isHidden) {\n                MessageLoop.sendMessage(widget, msg);\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onAfterShow(msg) {\n        for (const widget of this) {\n            if (!widget.isHidden) {\n                MessageLoop.sendMessage(widget, msg);\n            }\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onBeforeHide(msg) {\n        for (const widget of this) {\n            if (!widget.isHidden) {\n                MessageLoop.sendMessage(widget, msg);\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'after-hide'` message.\n     *\n     * #### Notes\n     * The default implementation of this method forwards the message to\n     * all non-hidden widgets. It assumes all widget nodes are attached\n     * to the parent widget node.\n     *\n     * This may be reimplemented by subclasses as needed.\n     */\n    onAfterHide(msg) {\n        for (const widget of this) {\n            if (!widget.isHidden) {\n                MessageLoop.sendMessage(widget, msg);\n            }\n        }\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * #### Notes\n     * This will remove the child widget from the layout.\n     *\n     * Subclasses should **not** typically reimplement this method.\n     */\n    onChildRemoved(msg) {\n        this.removeWidget(msg.child);\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onFitRequest(msg) { }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onChildShown(msg) { }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onChildHidden(msg) { }\n}\n/**\n * The namespace for the `Layout` class statics.\n */\n(function (Layout) {\n    /**\n     * Get the horizontal alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The horizontal alignment for the widget.\n     *\n     * #### Notes\n     * If the layout width allocated to a widget is larger than its max\n     * width, the horizontal alignment controls how the widget is placed\n     * within the extra horizontal space.\n     *\n     * If the allocated width is less than the widget's max width, the\n     * horizontal alignment has no effect.\n     *\n     * Some layout implementations may ignore horizontal alignment.\n     */\n    function getHorizontalAlignment(widget) {\n        return Private$i.horizontalAlignmentProperty.get(widget);\n    }\n    Layout.getHorizontalAlignment = getHorizontalAlignment;\n    /**\n     * Set the horizontal alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the horizontal alignment.\n     *\n     * #### Notes\n     * If the layout width allocated to a widget is larger than its max\n     * width, the horizontal alignment controls how the widget is placed\n     * within the extra horizontal space.\n     *\n     * If the allocated width is less than the widget's max width, the\n     * horizontal alignment has no effect.\n     *\n     * Some layout implementations may ignore horizontal alignment.\n     *\n     * Changing the horizontal alignment will post an `update-request`\n     * message to widget's parent, provided the parent has a layout\n     * installed.\n     */\n    function setHorizontalAlignment(widget, value) {\n        Private$i.horizontalAlignmentProperty.set(widget, value);\n    }\n    Layout.setHorizontalAlignment = setHorizontalAlignment;\n    /**\n     * Get the vertical alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The vertical alignment for the widget.\n     *\n     * #### Notes\n     * If the layout height allocated to a widget is larger than its max\n     * height, the vertical alignment controls how the widget is placed\n     * within the extra vertical space.\n     *\n     * If the allocated height is less than the widget's max height, the\n     * vertical alignment has no effect.\n     *\n     * Some layout implementations may ignore vertical alignment.\n     */\n    function getVerticalAlignment(widget) {\n        return Private$i.verticalAlignmentProperty.get(widget);\n    }\n    Layout.getVerticalAlignment = getVerticalAlignment;\n    /**\n     * Set the vertical alignment for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the vertical alignment.\n     *\n     * #### Notes\n     * If the layout height allocated to a widget is larger than its max\n     * height, the vertical alignment controls how the widget is placed\n     * within the extra vertical space.\n     *\n     * If the allocated height is less than the widget's max height, the\n     * vertical alignment has no effect.\n     *\n     * Some layout implementations may ignore vertical alignment.\n     *\n     * Changing the horizontal alignment will post an `update-request`\n     * message to widget's parent, provided the parent has a layout\n     * installed.\n     */\n    function setVerticalAlignment(widget, value) {\n        Private$i.verticalAlignmentProperty.set(widget, value);\n    }\n    Layout.setVerticalAlignment = setVerticalAlignment;\n})(Layout || (Layout = {}));\n/**\n * An object which assists in the absolute layout of widgets.\n *\n * #### Notes\n * This class is useful when implementing a layout which arranges its\n * widgets using absolute positioning.\n *\n * This class is used by nearly all of the built-in lumino layouts.\n */\nclass LayoutItem {\n    /**\n     * Construct a new layout item.\n     *\n     * @param widget - The widget to be managed by the item.\n     *\n     * #### Notes\n     * The widget will be set to absolute positioning.\n     * The widget will use strict CSS containment.\n     */\n    constructor(widget) {\n        this._top = NaN;\n        this._left = NaN;\n        this._width = NaN;\n        this._height = NaN;\n        this._minWidth = 0;\n        this._minHeight = 0;\n        this._maxWidth = Infinity;\n        this._maxHeight = Infinity;\n        this._disposed = false;\n        this.widget = widget;\n        this.widget.node.style.position = 'absolute';\n        this.widget.node.style.contain = 'strict';\n    }\n    /**\n     * Dispose of the the layout item.\n     *\n     * #### Notes\n     * This will reset the positioning of the widget.\n     */\n    dispose() {\n        // Do nothing if the item is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Mark the item as disposed.\n        this._disposed = true;\n        // Reset the widget style.\n        let style = this.widget.node.style;\n        style.position = '';\n        style.top = '';\n        style.left = '';\n        style.width = '';\n        style.height = '';\n        style.contain = '';\n    }\n    /**\n     * The computed minimum width of the widget.\n     *\n     * #### Notes\n     * This value can be updated by calling the `fit` method.\n     */\n    get minWidth() {\n        return this._minWidth;\n    }\n    /**\n     * The computed minimum height of the widget.\n     *\n     * #### Notes\n     * This value can be updated by calling the `fit` method.\n     */\n    get minHeight() {\n        return this._minHeight;\n    }\n    /**\n     * The computed maximum width of the widget.\n     *\n     * #### Notes\n     * This value can be updated by calling the `fit` method.\n     */\n    get maxWidth() {\n        return this._maxWidth;\n    }\n    /**\n     * The computed maximum height of the widget.\n     *\n     * #### Notes\n     * This value can be updated by calling the `fit` method.\n     */\n    get maxHeight() {\n        return this._maxHeight;\n    }\n    /**\n     * Whether the layout item is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Whether the managed widget is hidden.\n     */\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    /**\n     * Whether the managed widget is visible.\n     */\n    get isVisible() {\n        return this.widget.isVisible;\n    }\n    /**\n     * Whether the managed widget is attached.\n     */\n    get isAttached() {\n        return this.widget.isAttached;\n    }\n    /**\n     * Update the computed size limits of the managed widget.\n     */\n    fit() {\n        let limits = ElementExt.sizeLimits(this.widget.node);\n        this._minWidth = limits.minWidth;\n        this._minHeight = limits.minHeight;\n        this._maxWidth = limits.maxWidth;\n        this._maxHeight = limits.maxHeight;\n    }\n    /**\n     * Update the position and size of the managed widget.\n     *\n     * @param left - The left edge position of the layout box.\n     *\n     * @param top - The top edge position of the layout box.\n     *\n     * @param width - The width of the layout box.\n     *\n     * @param height - The height of the layout box.\n     */\n    update(left, top, width, height) {\n        // Clamp the size to the computed size limits.\n        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));\n        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));\n        // Adjust the left edge for the horizontal alignment, if needed.\n        if (clampW < width) {\n            switch (Layout.getHorizontalAlignment(this.widget)) {\n                case 'left':\n                    break;\n                case 'center':\n                    left += (width - clampW) / 2;\n                    break;\n                case 'right':\n                    left += width - clampW;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Adjust the top edge for the vertical alignment, if needed.\n        if (clampH < height) {\n            switch (Layout.getVerticalAlignment(this.widget)) {\n                case 'top':\n                    break;\n                case 'center':\n                    top += (height - clampH) / 2;\n                    break;\n                case 'bottom':\n                    top += height - clampH;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Set up the resize variables.\n        let resized = false;\n        let style = this.widget.node.style;\n        // Update the top edge of the widget if needed.\n        if (this._top !== top) {\n            this._top = top;\n            style.top = `${top}px`;\n        }\n        // Update the left edge of the widget if needed.\n        if (this._left !== left) {\n            this._left = left;\n            style.left = `${left}px`;\n        }\n        // Update the width of the widget if needed.\n        if (this._width !== clampW) {\n            resized = true;\n            this._width = clampW;\n            style.width = `${clampW}px`;\n        }\n        // Update the height of the widget if needed.\n        if (this._height !== clampH) {\n            resized = true;\n            this._height = clampH;\n            style.height = `${clampH}px`;\n        }\n        // Send a resize message to the widget if needed.\n        if (resized) {\n            let msg = new Widget.ResizeMessage(clampW, clampH);\n            MessageLoop.sendMessage(this.widget, msg);\n        }\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$i;\n(function (Private) {\n    /**\n     * The attached property for a widget horizontal alignment.\n     */\n    Private.horizontalAlignmentProperty = new AttachedProperty({\n        name: 'horizontalAlignment',\n        create: () => 'center',\n        changed: onAlignmentChanged\n    });\n    /**\n     * The attached property for a widget vertical alignment.\n     */\n    Private.verticalAlignmentProperty = new AttachedProperty({\n        name: 'verticalAlignment',\n        create: () => 'top',\n        changed: onAlignmentChanged\n    });\n    /**\n     * The change handler for the attached alignment properties.\n     */\n    function onAlignmentChanged(child) {\n        if (child.parent && child.parent.layout) {\n            child.parent.update();\n        }\n    }\n})(Private$i || (Private$i = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A concrete layout implementation suitable for many use cases.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * layouts, but can also be used directly with standard CSS to layout a\n * collection of widgets.\n */\nclass PanelLayout extends Layout {\n    constructor() {\n        super(...arguments);\n        this._widgets = [];\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This will clear and dispose all widgets in the layout.\n     *\n     * All reimplementations should call the superclass method.\n     *\n     * This method is called automatically when the parent is disposed.\n     */\n    dispose() {\n        while (this._widgets.length > 0) {\n            this._widgets.pop().dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * A read-only array of the widgets in the layout.\n     */\n    get widgets() {\n        return this._widgets;\n    }\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    *[Symbol.iterator]() {\n        yield* this._widgets;\n    }\n    /**\n     * Add a widget to the end of the layout.\n     *\n     * @param widget - The widget to add to the layout.\n     *\n     * #### Notes\n     * If the widget is already contained in the layout, it will be moved.\n     */\n    addWidget(widget) {\n        this.insertWidget(this._widgets.length, widget);\n    }\n    /**\n     * Insert a widget into the layout at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into the layout.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the widgets.\n     *\n     * If the widget is already added to the layout, it will be moved.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    insertWidget(index, widget) {\n        // Remove the widget from its current parent. This is a no-op\n        // if the widget's parent is already the layout parent widget.\n        widget.parent = this.parent;\n        // Look up the current index of the widget.\n        let i = this._widgets.indexOf(widget);\n        // Clamp the insert index to the array bounds.\n        let j = Math.max(0, Math.min(index, this._widgets.length));\n        // If the widget is not in the array, insert it.\n        if (i === -1) {\n            // Insert the widget into the array.\n            ArrayExt.insert(this._widgets, j, widget);\n            // If the layout is parented, attach the widget to the DOM.\n            if (this.parent) {\n                this.attachWidget(j, widget);\n            }\n            // There is nothing more to do.\n            return;\n        }\n        // Otherwise, the widget exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._widgets.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return;\n        }\n        // Move the widget to the new location.\n        ArrayExt.move(this._widgets, i, j);\n        // If the layout is parented, move the widget in the DOM.\n        if (this.parent) {\n            this.moveWidget(i, j, widget);\n        }\n    }\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        this.removeWidgetAt(this._widgets.indexOf(widget));\n    }\n    /**\n     * Remove the widget at a given index from the layout.\n     *\n     * @param index - The index of the widget to remove.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    removeWidgetAt(index) {\n        // Remove the widget from the array.\n        let widget = ArrayExt.removeAt(this._widgets, index);\n        // If the layout is parented, detach the widget from the DOM.\n        if (widget && this.parent) {\n            this.detachWidget(index, widget);\n        }\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        super.init();\n        let index = 0;\n        for (const widget of this) {\n            this.attachWidget(index++, widget);\n        }\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    attachWidget(index, widget) {\n        // Look up the next sibling reference node.\n        let ref = this.parent.node.children[index];\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Insert the widget's node before the sibling.\n        this.parent.node.insertBefore(widget.node, ref);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation moves the widget's node to the proper\n     * location in the parent's node and sends the appropriate attach and\n     * detach messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is moved in the parent's node.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` and  message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Look up the next sibling reference node.\n        let ref = this.parent.node.children[toIndex];\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Insert the widget's node before the sibling.\n        this.parent.node.insertBefore(widget.node, ref);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    detachWidget(index, widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    }\n}\n\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nvar Utils;\n(function (Utils) {\n    /**\n     * Clamp a dimension value to an integer >= 0.\n     */\n    function clampDimension(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Utils.clampDimension = clampDimension;\n})(Utils || (Utils = {}));\nvar Utils$1 = Utils;\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A layout which arranges its widgets into resizable sections.\n */\nclass SplitLayout extends PanelLayout {\n    /**\n     * Construct a new split layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    constructor(options) {\n        super();\n        this.widgetOffset = 0;\n        this._fixed = 0;\n        this._spacing = 4;\n        this._dirty = false;\n        this._hasNormedSizes = false;\n        this._sizers = [];\n        this._items = [];\n        this._handles = [];\n        this._box = null;\n        this._alignment = 'start';\n        this._orientation = 'horizontal';\n        this.renderer = options.renderer;\n        if (options.orientation !== undefined) {\n            this._orientation = options.orientation;\n        }\n        if (options.alignment !== undefined) {\n            this._alignment = options.alignment;\n        }\n        if (options.spacing !== undefined) {\n            this._spacing = Utils.clampDimension(options.spacing);\n        }\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        // Dispose of the layout items.\n        for (const item of this._items) {\n            item.dispose();\n        }\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._sizers.length = 0;\n        this._handles.length = 0;\n        // Dispose of the rest of the layout.\n        super.dispose();\n    }\n    /**\n     * Get the layout orientation for the split layout.\n     */\n    get orientation() {\n        return this._orientation;\n    }\n    /**\n     * Set the layout orientation for the split layout.\n     */\n    set orientation(value) {\n        if (this._orientation === value) {\n            return;\n        }\n        this._orientation = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.dataset['orientation'] = value;\n        this.parent.fit();\n    }\n    /**\n     * Get the content alignment for the split layout.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand  to fill the\n     * entire split layout.\n     */\n    get alignment() {\n        return this._alignment;\n    }\n    /**\n     * Set the content alignment for the split layout.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand  to fill the\n     * entire split layout.\n     */\n    set alignment(value) {\n        if (this._alignment === value) {\n            return;\n        }\n        this._alignment = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.dataset['alignment'] = value;\n        this.parent.update();\n    }\n    /**\n     * Get the inter-element spacing for the split layout.\n     */\n    get spacing() {\n        return this._spacing;\n    }\n    /**\n     * Set the inter-element spacing for the split layout.\n     */\n    set spacing(value) {\n        value = Utils.clampDimension(value);\n        if (this._spacing === value) {\n            return;\n        }\n        this._spacing = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.fit();\n    }\n    /**\n     * A read-only array of the split handles in the layout.\n     */\n    get handles() {\n        return this._handles;\n    }\n    /**\n     * Get the absolute sizes of the widgets in the layout.\n     *\n     * @returns A new array of the absolute sizes of the widgets.\n     *\n     * This method **does not** measure the DOM nodes.\n     */\n    absoluteSizes() {\n        return this._sizers.map(sizer => sizer.size);\n    }\n    /**\n     * Get the relative sizes of the widgets in the layout.\n     *\n     * @returns A new array of the relative sizes of the widgets.\n     *\n     * #### Notes\n     * The returned sizes reflect the sizes of the widgets normalized\n     * relative to their siblings.\n     *\n     * This method **does not** measure the DOM nodes.\n     */\n    relativeSizes() {\n        return Private$h.normalize(this._sizers.map(sizer => sizer.size));\n    }\n    /**\n     * Set the relative sizes for the widgets in the layout.\n     *\n     * @param sizes - The relative sizes for the widgets in the panel.\n     * @param update - Update the layout after setting relative sizes.\n     * Default is True.\n     *\n     * #### Notes\n     * Extra values are ignored, too few will yield an undefined layout.\n     *\n     * The actual geometry of the DOM nodes is updated asynchronously.\n     */\n    setRelativeSizes(sizes, update = true) {\n        // Copy the sizes and pad with zeros as needed.\n        let n = this._sizers.length;\n        let temp = sizes.slice(0, n);\n        while (temp.length < n) {\n            temp.push(0);\n        }\n        // Normalize the padded sizes.\n        let normed = Private$h.normalize(temp);\n        // Apply the normalized sizes to the sizers.\n        for (let i = 0; i < n; ++i) {\n            let sizer = this._sizers[i];\n            sizer.sizeHint = normed[i];\n            sizer.size = normed[i];\n        }\n        // Set the flag indicating the sizes are normalized.\n        this._hasNormedSizes = true;\n        // Trigger an update of the parent widget.\n        if (update && this.parent) {\n            this.parent.update();\n        }\n    }\n    /**\n     * Move the offset position of a split handle.\n     *\n     * @param index - The index of the handle of the interest.\n     *\n     * @param position - The desired offset position of the handle.\n     *\n     * #### Notes\n     * The position is relative to the offset parent.\n     *\n     * This will move the handle as close as possible to the desired\n     * position. The sibling widgets will be adjusted as necessary.\n     */\n    moveHandle(index, position) {\n        // Bail if the index is invalid or the handle is hidden.\n        let handle = this._handles[index];\n        if (!handle || handle.classList.contains('lm-mod-hidden')) {\n            return;\n        }\n        // Compute the desired delta movement for the handle.\n        let delta;\n        if (this._orientation === 'horizontal') {\n            delta = position - handle.offsetLeft;\n        }\n        else {\n            delta = position - handle.offsetTop;\n        }\n        // Bail if there is no handle movement.\n        if (delta === 0) {\n            return;\n        }\n        // Prevent widget resizing unless needed.\n        for (let sizer of this._sizers) {\n            if (sizer.size > 0) {\n                sizer.sizeHint = sizer.size;\n            }\n        }\n        // Adjust the sizers to reflect the handle movement.\n        BoxEngine.adjust(this._sizers, index, delta);\n        // Update the layout of the widgets.\n        if (this.parent) {\n            this.parent.update();\n        }\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        this.parent.dataset['orientation'] = this.orientation;\n        this.parent.dataset['alignment'] = this.alignment;\n        super.init();\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    attachWidget(index, widget) {\n        // Create the item, handle, and sizer for the new widget.\n        let item = new LayoutItem(widget);\n        let handle = Private$h.createHandle(this.renderer);\n        let average = Private$h.averageSize(this._sizers);\n        let sizer = Private$h.createSizer(average);\n        // Insert the item, handle, and sizer into the internal arrays.\n        ArrayExt.insert(this._items, index, item);\n        ArrayExt.insert(this._sizers, index, sizer);\n        ArrayExt.insert(this._handles, index, handle);\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget and handle nodes to the parent.\n        this.parent.node.appendChild(widget.node);\n        this.parent.node.appendChild(handle);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Move the item, sizer, and handle for the widget.\n        ArrayExt.move(this._items, fromIndex, toIndex);\n        ArrayExt.move(this._sizers, fromIndex, toIndex);\n        ArrayExt.move(this._handles, fromIndex, toIndex);\n        // Post a fit request to the parent to show/hide last handle.\n        this.parent.fit();\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    detachWidget(index, widget) {\n        // Remove the item, handle, and sizer for the widget.\n        let item = ArrayExt.removeAt(this._items, index);\n        let handle = ArrayExt.removeAt(this._handles, index);\n        ArrayExt.removeAt(this._sizers, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget and handle nodes from the parent.\n        this.parent.node.removeChild(widget.node);\n        this.parent.node.removeChild(handle);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        super.onBeforeShow(msg);\n        this.parent.update();\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        super.onBeforeAttach(msg);\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    onChildShown(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    onChildHidden(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    onFitRequest(msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    }\n    /**\n     * Update the item position.\n     *\n     * @param i Item index\n     * @param isHorizontal Whether the layout is horizontal or not\n     * @param left Left position in pixels\n     * @param top Top position in pixels\n     * @param height Item height\n     * @param width Item width\n     * @param size Item size\n     */\n    updateItemPosition(i, isHorizontal, left, top, height, width, size) {\n        const item = this._items[i];\n        if (item.isHidden) {\n            return;\n        }\n        // Fetch the style for the handle.\n        let handleStyle = this._handles[i].style;\n        // Update the widget and handle, and advance the relevant edge.\n        if (isHorizontal) {\n            left += this.widgetOffset;\n            item.update(left, top, size, height);\n            left += size;\n            handleStyle.top = `${top}px`;\n            handleStyle.left = `${left}px`;\n            handleStyle.width = `${this._spacing}px`;\n            handleStyle.height = `${height}px`;\n        }\n        else {\n            top += this.widgetOffset;\n            item.update(left, top, width, size);\n            top += size;\n            handleStyle.top = `${top}px`;\n            handleStyle.left = `${left}px`;\n            handleStyle.width = `${width}px`;\n            handleStyle.height = `${this._spacing}px`;\n        }\n    }\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    _fit() {\n        // Update the handles and track the visible widget count.\n        let nVisible = 0;\n        let lastHandleIndex = -1;\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            if (this._items[i].isHidden) {\n                this._handles[i].classList.add('lm-mod-hidden');\n            }\n            else {\n                this._handles[i].classList.remove('lm-mod-hidden');\n                lastHandleIndex = i;\n                nVisible++;\n            }\n        }\n        // Hide the handle for the last visible widget.\n        if (lastHandleIndex !== -1) {\n            this._handles[lastHandleIndex].classList.add('lm-mod-hidden');\n        }\n        // Update the fixed space for the visible items.\n        this._fixed =\n            this._spacing * Math.max(0, nVisible - 1) +\n                this.widgetOffset * this._items.length;\n        // Setup the computed minimum size.\n        let horz = this._orientation === 'horizontal';\n        let minW = horz ? this._fixed : 0;\n        let minH = horz ? 0 : this._fixed;\n        // Update the sizers and computed size limits.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item and corresponding box sizer.\n            let item = this._items[i];\n            let sizer = this._sizers[i];\n            // Prevent resizing unless necessary.\n            if (sizer.size > 0) {\n                sizer.sizeHint = sizer.size;\n            }\n            // If the item is hidden, it should consume zero size.\n            if (item.isHidden) {\n                sizer.minSize = 0;\n                sizer.maxSize = 0;\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the stretch factor.\n            sizer.stretch = SplitLayout.getStretch(item.widget);\n            // Update the sizer limits and computed min size.\n            if (horz) {\n                sizer.minSize = item.minWidth;\n                sizer.maxSize = item.maxWidth;\n                minW += item.minWidth;\n                minH = Math.max(minH, item.minHeight);\n            }\n            else {\n                sizer.minSize = item.minHeight;\n                sizer.maxSize = item.maxHeight;\n                minH += item.minHeight;\n                minW = Math.max(minW, item.minWidth);\n            }\n        }\n        // Update the box sizing and add it to the computed min size.\n        let box = (this._box = ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        let style = this.parent.node.style;\n        style.minWidth = `${minW}px`;\n        style.minHeight = `${minH}px`;\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    }\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    _update(offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        let nVisible = 0;\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0 && this.widgetOffset === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        let top = this._box.paddingTop;\n        let left = this._box.paddingLeft;\n        let width = offsetWidth - this._box.horizontalSum;\n        let height = offsetHeight - this._box.verticalSum;\n        // Set up the variables for justification and alignment offset.\n        let extra = 0;\n        let offset = 0;\n        let horz = this._orientation === 'horizontal';\n        if (nVisible > 0) {\n            // Compute the adjusted layout space.\n            let space;\n            if (horz) {\n                // left += this.widgetOffset;\n                space = Math.max(0, width - this._fixed);\n            }\n            else {\n                // top += this.widgetOffset;\n                space = Math.max(0, height - this._fixed);\n            }\n            // Scale the size hints if they are normalized.\n            if (this._hasNormedSizes) {\n                for (let sizer of this._sizers) {\n                    sizer.sizeHint *= space;\n                }\n                this._hasNormedSizes = false;\n            }\n            // Distribute the layout space to the box sizers.\n            let delta = BoxEngine.calc(this._sizers, space);\n            // Account for alignment if there is extra layout space.\n            if (delta > 0) {\n                switch (this._alignment) {\n                    case 'start':\n                        break;\n                    case 'center':\n                        extra = 0;\n                        offset = delta / 2;\n                        break;\n                    case 'end':\n                        extra = 0;\n                        offset = delta;\n                        break;\n                    case 'justify':\n                        extra = delta / nVisible;\n                        offset = 0;\n                        break;\n                    default:\n                        throw 'unreachable';\n                }\n            }\n        }\n        // Layout the items using the computed box sizes.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            const item = this._items[i];\n            // Fetch the computed size for the widget.\n            const size = item.isHidden ? 0 : this._sizers[i].size + extra;\n            this.updateItemPosition(i, horz, horz ? left + offset : left, horz ? top : top + offset, height, width, size);\n            const fullOffset = this.widgetOffset +\n                (this._handles[i].classList.contains('lm-mod-hidden')\n                    ? 0\n                    : this._spacing);\n            if (horz) {\n                left += size + fullOffset;\n            }\n            else {\n                top += size + fullOffset;\n            }\n        }\n    }\n}\n/**\n * The namespace for the `SplitLayout` class statics.\n */\n(function (SplitLayout) {\n    /**\n     * Get the split layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The split layout stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return Private$h.stretchProperty.get(widget);\n    }\n    SplitLayout.getStretch = getStretch;\n    /**\n     * Set the split layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        Private$h.stretchProperty.set(widget, value);\n    }\n    SplitLayout.setStretch = setStretch;\n})(SplitLayout || (SplitLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$h;\n(function (Private) {\n    /**\n     * The property descriptor for a widget stretch factor.\n     */\n    Private.stretchProperty = new AttachedProperty({\n        name: 'stretch',\n        create: () => 0,\n        coerce: (owner, value) => Math.max(0, Math.floor(value)),\n        changed: onChildSizingChanged\n    });\n    /**\n     * Create a new box sizer with the given size hint.\n     */\n    function createSizer(size) {\n        let sizer = new BoxSizer();\n        sizer.sizeHint = Math.floor(size);\n        return sizer;\n    }\n    Private.createSizer = createSizer;\n    /**\n     * Create a new split handle node using the given renderer.\n     */\n    function createHandle(renderer) {\n        let handle = renderer.createHandle();\n        handle.style.position = 'absolute';\n        // Do not use size containment to allow the handle to fill the available space\n        handle.style.contain = 'style';\n        return handle;\n    }\n    Private.createHandle = createHandle;\n    /**\n     * Compute the average size of an array of box sizers.\n     */\n    function averageSize(sizers) {\n        return sizers.reduce((v, s) => v + s.size, 0) / sizers.length || 0;\n    }\n    Private.averageSize = averageSize;\n    /**\n     * Normalize an array of values.\n     */\n    function normalize(values) {\n        let n = values.length;\n        if (n === 0) {\n            return [];\n        }\n        let sum = values.reduce((a, b) => a + Math.abs(b), 0);\n        return sum === 0 ? values.map(v => 1 / n) : values.map(v => v / sum);\n    }\n    Private.normalize = normalize;\n    /**\n     * The change handler for the attached sizing properties.\n     */\n    function onChildSizingChanged(child) {\n        if (child.parent && child.parent.layout instanceof SplitLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$h || (Private$h = {}));\n\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/**\n * A layout which arranges its widgets into collapsible resizable sections.\n */\nclass AccordionLayout extends SplitLayout {\n    /**\n     * Construct a new accordion layout.\n     *\n     * @param options - The options for initializing the layout.\n     *\n     * #### Notes\n     * The default orientation will be vertical.\n     *\n     * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n     */\n    constructor(options) {\n        super({ ...options, orientation: options.orientation || 'vertical' });\n        this._titles = [];\n        this.titleSpace = options.titleSpace || 22;\n    }\n    /**\n     * The section title height or width depending on the orientation.\n     */\n    get titleSpace() {\n        return this.widgetOffset;\n    }\n    set titleSpace(value) {\n        value = Utils$1.clampDimension(value);\n        if (this.widgetOffset === value) {\n            return;\n        }\n        this.widgetOffset = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.fit();\n    }\n    /**\n     * A read-only array of the section titles in the panel.\n     */\n    get titles() {\n        return this._titles;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        // Clear the layout state.\n        this._titles.length = 0;\n        // Dispose of the rest of the layout.\n        super.dispose();\n    }\n    updateTitle(index, widget) {\n        const oldTitle = this._titles[index];\n        const expanded = oldTitle.classList.contains('lm-mod-expanded');\n        const newTitle = Private$g.createTitle(this.renderer, widget.title, expanded);\n        this._titles[index] = newTitle;\n        // Add the title node to the parent before the widget.\n        this.parent.node.replaceChild(newTitle, oldTitle);\n    }\n    /**\n     * Insert a widget into the layout at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into the layout.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the widgets.\n     *\n     * If the widget is already added to the layout, it will be moved.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     */\n    insertWidget(index, widget) {\n        if (!widget.id) {\n            widget.id = `id-${UUID.uuid4()}`;\n        }\n        super.insertWidget(index, widget);\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     */\n    attachWidget(index, widget) {\n        const title = Private$g.createTitle(this.renderer, widget.title);\n        ArrayExt.insert(this._titles, index, title);\n        // Add the title node to the parent before the widget.\n        this.parent.node.appendChild(title);\n        widget.node.setAttribute('role', 'region');\n        widget.node.setAttribute('aria-labelledby', title.id);\n        super.attachWidget(index, widget);\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        ArrayExt.move(this._titles, fromIndex, toIndex);\n        super.moveWidget(fromIndex, toIndex, widget);\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    detachWidget(index, widget) {\n        const title = ArrayExt.removeAt(this._titles, index);\n        this.parent.node.removeChild(title);\n        super.detachWidget(index, widget);\n    }\n    /**\n     * Update the item position.\n     *\n     * @param i Item index\n     * @param isHorizontal Whether the layout is horizontal or not\n     * @param left Left position in pixels\n     * @param top Top position in pixels\n     * @param height Item height\n     * @param width Item width\n     * @param size Item size\n     */\n    updateItemPosition(i, isHorizontal, left, top, height, width, size) {\n        const titleStyle = this._titles[i].style;\n        // Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css\n        titleStyle.top = `${top}px`;\n        titleStyle.left = `${left}px`;\n        titleStyle.height = `${this.widgetOffset}px`;\n        if (isHorizontal) {\n            titleStyle.width = `${height}px`;\n        }\n        else {\n            titleStyle.width = `${width}px`;\n        }\n        super.updateItemPosition(i, isHorizontal, left, top, height, width, size);\n    }\n}\nvar Private$g;\n(function (Private) {\n    /**\n     * Create the title HTML element.\n     *\n     * @param renderer Accordion renderer\n     * @param data Widget title\n     * @returns Title HTML element\n     */\n    function createTitle(renderer, data, expanded = true) {\n        const title = renderer.createSectionTitle(data);\n        title.style.position = 'absolute';\n        title.style.contain = 'strict';\n        title.setAttribute('aria-label', `${data.label} Section`);\n        title.setAttribute('aria-expanded', expanded ? 'true' : 'false');\n        title.setAttribute('aria-controls', data.owner.id);\n        if (expanded) {\n            title.classList.add('lm-mod-expanded');\n        }\n        return title;\n    }\n    Private.createTitle = createTitle;\n})(Private$g || (Private$g = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A simple and convenient panel widget class.\n *\n * #### Notes\n * This class is suitable as a base class for implementing a variety of\n * convenience panel widgets, but can also be used directly with CSS to\n * arrange a collection of widgets.\n *\n * This class provides a convenience wrapper around a {@link PanelLayout}.\n */\nclass Panel extends Widget {\n    /**\n     * Construct a new panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    constructor(options = {}) {\n        super();\n        this.addClass('lm-Panel');\n        this.layout = Private$f.createLayout(options);\n    }\n    /**\n     * A read-only array of the widgets in the panel.\n     */\n    get widgets() {\n        return this.layout.widgets;\n    }\n    /**\n     * Add a widget to the end of the panel.\n     *\n     * @param widget - The widget to add to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    addWidget(widget) {\n        this.layout.addWidget(widget);\n    }\n    /**\n     * Insert a widget at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    insertWidget(index, widget) {\n        this.layout.insertWidget(index, widget);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$f;\n(function (Private) {\n    /**\n     * Create a panel layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new PanelLayout();\n    }\n    Private.createLayout = createLayout;\n})(Private$f || (Private$f = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A panel which arranges its widgets into resizable sections.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link SplitLayout}.\n */\nclass SplitPanel extends Panel {\n    /**\n     * Construct a new split panel.\n     *\n     * @param options - The options for initializing the split panel.\n     */\n    constructor(options = {}) {\n        super({ layout: Private$e.createLayout(options) });\n        this._handleMoved = new Signal(this);\n        this._pressData = null;\n        this.addClass('lm-SplitPanel');\n    }\n    /**\n     * Dispose of the resources held by the panel.\n     */\n    dispose() {\n        this._releaseMouse();\n        super.dispose();\n    }\n    /**\n     * Get the layout orientation for the split panel.\n     */\n    get orientation() {\n        return this.layout.orientation;\n    }\n    /**\n     * Set the layout orientation for the split panel.\n     */\n    set orientation(value) {\n        this.layout.orientation = value;\n    }\n    /**\n     * Get the content alignment for the split panel.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire split panel.\n     */\n    get alignment() {\n        return this.layout.alignment;\n    }\n    /**\n     * Set the content alignment for the split panel.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire split panel.\n     */\n    set alignment(value) {\n        this.layout.alignment = value;\n    }\n    /**\n     * Get the inter-element spacing for the split panel.\n     */\n    get spacing() {\n        return this.layout.spacing;\n    }\n    /**\n     * Set the inter-element spacing for the split panel.\n     */\n    set spacing(value) {\n        this.layout.spacing = value;\n    }\n    /**\n     * The renderer used by the split panel.\n     */\n    get renderer() {\n        return this.layout.renderer;\n    }\n    /**\n     * A signal emitted when a split handle has moved.\n     */\n    get handleMoved() {\n        return this._handleMoved;\n    }\n    /**\n     * A read-only array of the split handles in the panel.\n     */\n    get handles() {\n        return this.layout.handles;\n    }\n    /**\n     * Get the relative sizes of the widgets in the panel.\n     *\n     * @returns A new array of the relative sizes of the widgets.\n     *\n     * #### Notes\n     * The returned sizes reflect the sizes of the widgets normalized\n     * relative to their siblings.\n     *\n     * This method **does not** measure the DOM nodes.\n     */\n    relativeSizes() {\n        return this.layout.relativeSizes();\n    }\n    /**\n     * Set the relative sizes for the widgets in the panel.\n     *\n     * @param sizes - The relative sizes for the widgets in the panel.\n     * @param update - Update the layout after setting relative sizes.\n     * Default is True.\n     *\n     * #### Notes\n     * Extra values are ignored, too few will yield an undefined layout.\n     *\n     * The actual geometry of the DOM nodes is updated asynchronously.\n     */\n    setRelativeSizes(sizes, update = true) {\n        this.layout.setRelativeSizes(sizes, update);\n    }\n    /**\n     * Handle the DOM events for the split panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'pointerdown':\n                this._evtPointerDown(event);\n                break;\n            case 'pointermove':\n                this._evtPointerMove(event);\n                break;\n            case 'pointerup':\n                this._evtPointerUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('pointerdown', this);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('pointerdown', this);\n        this._releaseMouse();\n    }\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    onChildAdded(msg) {\n        msg.child.addClass('lm-SplitPanel-child');\n        this._releaseMouse();\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    onChildRemoved(msg) {\n        msg.child.removeClass('lm-SplitPanel-child');\n        this._releaseMouse();\n    }\n    /**\n     * Handle the `'keydown'` event for the split panel.\n     */\n    _evtKeyDown(event) {\n        // Stop input events during drag.\n        if (this._pressData) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Release the mouse if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            this._releaseMouse();\n        }\n    }\n    /**\n     * Handle the `'pointerdown'` event for the split panel.\n     */\n    _evtPointerDown(event) {\n        // Do nothing if the primary button is not pressed.\n        if (event.button !== 0) {\n            return;\n        }\n        // Find the handle which contains the target, if any.\n        let layout = this.layout;\n        let index = ArrayExt.findFirstIndex(layout.handles, handle => {\n            return handle.contains(event.target);\n        });\n        // Bail early if the mouse press was not on a handle.\n        if (index === -1) {\n            return;\n        }\n        // Stop the event when a split handle is pressed.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        document.addEventListener('pointerup', this, true);\n        document.addEventListener('pointermove', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Compute the offset delta for the handle press.\n        let delta;\n        let handle = layout.handles[index];\n        let rect = handle.getBoundingClientRect();\n        if (layout.orientation === 'horizontal') {\n            delta = event.clientX - rect.left;\n        }\n        else {\n            delta = event.clientY - rect.top;\n        }\n        // Override the cursor and store the press data.\n        let style = window.getComputedStyle(handle);\n        let override = Drag.overrideCursor(style.cursor);\n        this._pressData = { index, delta, override };\n    }\n    /**\n     * Handle the `'pointermove'` event for the split panel.\n     */\n    _evtPointerMove(event) {\n        // Stop the event when dragging a split handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Compute the desired offset position for the handle.\n        let pos;\n        let layout = this.layout;\n        let rect = this.node.getBoundingClientRect();\n        if (layout.orientation === 'horizontal') {\n            pos = event.clientX - rect.left - this._pressData.delta;\n        }\n        else {\n            pos = event.clientY - rect.top - this._pressData.delta;\n        }\n        // Move the handle as close to the desired position as possible.\n        layout.moveHandle(this._pressData.index, pos);\n    }\n    /**\n     * Handle the `'pointerup'` event for the split panel.\n     */\n    _evtPointerUp(event) {\n        // Do nothing if the primary button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event when releasing a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Finalize the mouse release.\n        this._releaseMouse();\n    }\n    /**\n     * Release the mouse grab for the split panel.\n     */\n    _releaseMouse() {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the override cursor.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Emit the handle moved signal.\n        this._handleMoved.emit();\n        // Remove the extra document listeners.\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('pointerup', this, true);\n        document.removeEventListener('pointermove', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    }\n}\n/**\n * The namespace for the `SplitPanel` class statics.\n */\n(function (SplitPanel) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    class Renderer {\n        /**\n         * Create a new handle for use with a split panel.\n         *\n         * @returns A new handle element for a split panel.\n         */\n        createHandle() {\n            let handle = document.createElement('div');\n            handle.className = 'lm-SplitPanel-handle';\n            return handle;\n        }\n    }\n    SplitPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    SplitPanel.defaultRenderer = new Renderer();\n    /**\n     * Get the split panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The split panel stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return SplitLayout.getStretch(widget);\n    }\n    SplitPanel.getStretch = getStretch;\n    /**\n     * Set the split panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        SplitLayout.setStretch(widget, value);\n    }\n    SplitPanel.setStretch = setStretch;\n})(SplitPanel || (SplitPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$e;\n(function (Private) {\n    /**\n     * Create a split layout for the given panel options.\n     */\n    function createLayout(options) {\n        return (options.layout ||\n            new SplitLayout({\n                renderer: options.renderer || SplitPanel.defaultRenderer,\n                orientation: options.orientation,\n                alignment: options.alignment,\n                spacing: options.spacing\n            }));\n    }\n    Private.createLayout = createLayout;\n})(Private$e || (Private$e = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A panel which arranges its widgets into resizable sections separated by a title widget.\n *\n * #### Notes\n * This class provides a convenience wrapper around {@link AccordionLayout}.\n */\nclass AccordionPanel extends SplitPanel {\n    /**\n     * Construct a new accordion panel.\n     *\n     * @param options - The options for initializing the accordion panel.\n     */\n    constructor(options = {}) {\n        super({ ...options, layout: Private$d.createLayout(options) });\n        this._widgetSizesCache = new WeakMap();\n        this._expansionToggled = new Signal(this);\n        this.addClass('lm-AccordionPanel');\n    }\n    /**\n     * The renderer used by the accordion panel.\n     */\n    get renderer() {\n        return this.layout.renderer;\n    }\n    /**\n     * The section title space.\n     *\n     * This is the height if the panel is vertical and the width if it is\n     * horizontal.\n     */\n    get titleSpace() {\n        return this.layout.titleSpace;\n    }\n    set titleSpace(value) {\n        this.layout.titleSpace = value;\n    }\n    /**\n     * A read-only array of the section titles in the panel.\n     */\n    get titles() {\n        return this.layout.titles;\n    }\n    /**\n     * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.\n     */\n    get expansionToggled() {\n        return this._expansionToggled;\n    }\n    /**\n     * Add a widget to the end of the panel.\n     *\n     * @param widget - The widget to add to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    addWidget(widget) {\n        super.addWidget(widget);\n        widget.title.changed.connect(this._onTitleChanged, this);\n    }\n    /**\n     * Collapse the widget at position `index`.\n     *\n     * #### Notes\n     * If no widget is found for `index`, this will bail.\n     *\n     * @param index Widget index\n     */\n    collapse(index) {\n        const widget = this.layout.widgets[index];\n        if (widget && !widget.isHidden) {\n            this._toggleExpansion(index);\n        }\n    }\n    /**\n     * Expand the widget at position `index`.\n     *\n     * #### Notes\n     * If no widget is found for `index`, this will bail.\n     *\n     * @param index Widget index\n     */\n    expand(index) {\n        const widget = this.layout.widgets[index];\n        if (widget && widget.isHidden) {\n            this._toggleExpansion(index);\n        }\n    }\n    /**\n     * Insert a widget at the specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into to the panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     */\n    insertWidget(index, widget) {\n        super.insertWidget(index, widget);\n        widget.title.changed.connect(this._onTitleChanged, this);\n    }\n    /**\n     * Handle the DOM events for the accordion panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        super.handleEvent(event);\n        switch (event.type) {\n            case 'click':\n                this._evtClick(event);\n                break;\n            case 'keydown':\n                this._eventKeyDown(event);\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n        super.onBeforeAttach(msg);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        super.onAfterDetach(msg);\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n    }\n    /**\n     * Handle the `changed` signal of a title object.\n     */\n    _onTitleChanged(sender) {\n        const index = ArrayExt.findFirstIndex(this.widgets, widget => {\n            return widget.contains(sender.owner);\n        });\n        if (index >= 0) {\n            this.layout.updateTitle(index, sender.owner);\n            this.update();\n        }\n    }\n    /**\n     * Compute the size of widgets in this panel on the title click event.\n     * On closing, the size of the widget is cached and we will try to expand\n     * the last opened widget.\n     * On opening, we will use the cached size if it is available to restore the\n     * widget.\n     * In both cases, if we can not compute the size of widgets, we will let\n     * `SplitLayout` decide.\n     *\n     * @param index - The index of widget to be opened of closed\n     *\n     * @returns Relative size of widgets in this panel, if this size can\n     * not be computed, return `undefined`\n     */\n    _computeWidgetSize(index) {\n        const layout = this.layout;\n        const widget = layout.widgets[index];\n        if (!widget) {\n            return undefined;\n        }\n        const isHidden = widget.isHidden;\n        const widgetSizes = layout.absoluteSizes();\n        const delta = (isHidden ? -1 : 1) * this.spacing;\n        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);\n        let newSize = [...widgetSizes];\n        if (!isHidden) {\n            // Hide the widget\n            const currentSize = widgetSizes[index];\n            this._widgetSizesCache.set(widget, currentSize);\n            newSize[index] = 0;\n            const widgetToCollapse = newSize.map(sz => sz > 0).lastIndexOf(true);\n            if (widgetToCollapse === -1) {\n                // All widget are closed, let the `SplitLayout` compute widget sizes.\n                return undefined;\n            }\n            newSize[widgetToCollapse] =\n                widgetSizes[widgetToCollapse] + currentSize + delta;\n        }\n        else {\n            // Show the widget\n            const previousSize = this._widgetSizesCache.get(widget);\n            if (!previousSize) {\n                // Previous size is unavailable, let the `SplitLayout` compute widget sizes.\n                return undefined;\n            }\n            newSize[index] += previousSize;\n            const widgetToCollapse = newSize\n                .map(sz => sz - previousSize > 0)\n                .lastIndexOf(true);\n            if (widgetToCollapse === -1) {\n                // Can not reduce the size of one widget, reduce all opened widgets\n                // proportionally with its size.\n                newSize.forEach((_, idx) => {\n                    if (idx !== index) {\n                        newSize[idx] -=\n                            (widgetSizes[idx] / totalSize) * (previousSize - delta);\n                    }\n                });\n            }\n            else {\n                newSize[widgetToCollapse] -= previousSize - delta;\n            }\n        }\n        return newSize.map(sz => sz / (totalSize + delta));\n    }\n    /**\n     * Handle the `'click'` event for the accordion panel\n     */\n    _evtClick(event) {\n        const target = event.target;\n        if (target) {\n            const index = ArrayExt.findFirstIndex(this.titles, title => {\n                return title.contains(target);\n            });\n            if (index >= 0) {\n                event.preventDefault();\n                event.stopPropagation();\n                this._toggleExpansion(index);\n            }\n        }\n    }\n    /**\n     * Handle the `'keydown'` event for the accordion panel.\n     */\n    _eventKeyDown(event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        const target = event.target;\n        let handled = false;\n        if (target) {\n            const index = ArrayExt.findFirstIndex(this.titles, title => {\n                return title.contains(target);\n            });\n            if (index >= 0) {\n                const keyCode = event.keyCode.toString();\n                // If Space or Enter is pressed on title, emulate click event\n                if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {\n                    target.click();\n                    handled = true;\n                }\n                else if (this.orientation === 'horizontal'\n                    ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/)\n                    : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {\n                    // If Up or Down (for vertical) / Left or Right (for horizontal) is pressed on title, loop on titles\n                    const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/)\n                        ? -1\n                        : 1;\n                    const length = this.titles.length;\n                    const newIndex = (index + length + direction) % length;\n                    this.titles[newIndex].focus();\n                    handled = true;\n                }\n                else if (event.key === 'End' || keyCode === '35') {\n                    // If End is pressed on title, focus on the last title\n                    this.titles[this.titles.length - 1].focus();\n                    handled = true;\n                }\n                else if (event.key === 'Home' || keyCode === '36') {\n                    // If Home is pressed on title, focus on the first title\n                    this.titles[0].focus();\n                    handled = true;\n                }\n            }\n            if (handled) {\n                event.preventDefault();\n            }\n        }\n    }\n    _toggleExpansion(index) {\n        const title = this.titles[index];\n        const widget = this.layout.widgets[index];\n        const newSize = this._computeWidgetSize(index);\n        if (newSize) {\n            this.setRelativeSizes(newSize, false);\n        }\n        if (widget.isHidden) {\n            title.classList.add('lm-mod-expanded');\n            title.setAttribute('aria-expanded', 'true');\n            widget.show();\n        }\n        else {\n            title.classList.remove('lm-mod-expanded');\n            title.setAttribute('aria-expanded', 'false');\n            widget.hide();\n        }\n        // Emit the expansion state signal.\n        this._expansionToggled.emit(index);\n    }\n}\n/**\n * The namespace for the `AccordionPanel` class statics.\n */\n(function (AccordionPanel) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    class Renderer extends SplitPanel.Renderer {\n        constructor() {\n            super();\n            /**\n             * A selector which matches any title node in the accordion.\n             */\n            this.titleClassName = 'lm-AccordionPanel-title';\n            this._titleID = 0;\n            this._titleKeys = new WeakMap();\n            this._uuid = ++Renderer._nInstance;\n        }\n        /**\n         * Render the collapse indicator for a section title.\n         *\n         * @param data - The data to use for rendering the section title.\n         *\n         * @returns A element representing the collapse indicator.\n         */\n        createCollapseIcon(data) {\n            return document.createElement('span');\n        }\n        /**\n         * Render the element for a section title.\n         *\n         * @param data - The data to use for rendering the section title.\n         *\n         * @returns A element representing the section title.\n         */\n        createSectionTitle(data) {\n            const handle = document.createElement('h3');\n            handle.setAttribute('tabindex', '0');\n            handle.id = this.createTitleKey(data);\n            handle.className = this.titleClassName;\n            for (const aData in data.dataset) {\n                handle.dataset[aData] = data.dataset[aData];\n            }\n            const collapser = handle.appendChild(this.createCollapseIcon(data));\n            collapser.className = 'lm-AccordionPanel-titleCollapser';\n            const label = handle.appendChild(document.createElement('span'));\n            label.className = 'lm-AccordionPanel-titleLabel';\n            label.textContent = data.label;\n            label.title = data.caption || data.label;\n            return handle;\n        }\n        /**\n         * Create a unique render key for the title.\n         *\n         * @param data - The data to use for the title.\n         *\n         * @returns The unique render key for the title.\n         *\n         * #### Notes\n         * This method caches the key against the section title the first time\n         * the key is generated.\n         */\n        createTitleKey(data) {\n            let key = this._titleKeys.get(data);\n            if (key === undefined) {\n                key = `title-key-${this._uuid}-${this._titleID++}`;\n                this._titleKeys.set(data, key);\n            }\n            return key;\n        }\n    }\n    Renderer._nInstance = 0;\n    AccordionPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    AccordionPanel.defaultRenderer = new Renderer();\n})(AccordionPanel || (AccordionPanel = {}));\nvar Private$d;\n(function (Private) {\n    /**\n     * Create an accordion layout for the given panel options.\n     *\n     * @param options Panel options\n     * @returns Panel layout\n     */\n    function createLayout(options) {\n        return (options.layout ||\n            new AccordionLayout({\n                renderer: options.renderer || AccordionPanel.defaultRenderer,\n                orientation: options.orientation,\n                alignment: options.alignment,\n                spacing: options.spacing,\n                titleSpace: options.titleSpace\n            }));\n    }\n    Private.createLayout = createLayout;\n})(Private$d || (Private$d = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A layout which arranges its widgets in a single row or column.\n */\nclass BoxLayout extends PanelLayout {\n    /**\n     * Construct a new box layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    constructor(options = {}) {\n        super();\n        this._fixed = 0;\n        this._spacing = 4;\n        this._dirty = false;\n        this._sizers = [];\n        this._items = [];\n        this._box = null;\n        this._alignment = 'start';\n        this._direction = 'top-to-bottom';\n        if (options.direction !== undefined) {\n            this._direction = options.direction;\n        }\n        if (options.alignment !== undefined) {\n            this._alignment = options.alignment;\n        }\n        if (options.spacing !== undefined) {\n            this._spacing = Utils$1.clampDimension(options.spacing);\n        }\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        // Dispose of the layout items.\n        for (const item of this._items) {\n            item.dispose();\n        }\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._sizers.length = 0;\n        // Dispose of the rest of the layout.\n        super.dispose();\n    }\n    /**\n     * Get the layout direction for the box layout.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * Set the layout direction for the box layout.\n     */\n    set direction(value) {\n        if (this._direction === value) {\n            return;\n        }\n        this._direction = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.dataset['direction'] = value;\n        this.parent.fit();\n    }\n    /**\n     * Get the content alignment for the box layout.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire box layout.\n     */\n    get alignment() {\n        return this._alignment;\n    }\n    /**\n     * Set the content alignment for the box layout.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire box layout.\n     */\n    set alignment(value) {\n        if (this._alignment === value) {\n            return;\n        }\n        this._alignment = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.dataset['alignment'] = value;\n        this.parent.update();\n    }\n    /**\n     * Get the inter-element spacing for the box layout.\n     */\n    get spacing() {\n        return this._spacing;\n    }\n    /**\n     * Set the inter-element spacing for the box layout.\n     */\n    set spacing(value) {\n        value = Utils$1.clampDimension(value);\n        if (this._spacing === value) {\n            return;\n        }\n        this._spacing = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.fit();\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        this.parent.dataset['direction'] = this.direction;\n        this.parent.dataset['alignment'] = this.alignment;\n        super.init();\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    attachWidget(index, widget) {\n        // Create and add a new layout item for the widget.\n        ArrayExt.insert(this._items, index, new LayoutItem(widget));\n        // Create and add a new sizer for the widget.\n        ArrayExt.insert(this._sizers, index, new BoxSizer());\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Move the layout item for the widget.\n        ArrayExt.move(this._items, fromIndex, toIndex);\n        // Move the sizer for the widget.\n        ArrayExt.move(this._sizers, fromIndex, toIndex);\n        // Post an update request for the parent widget.\n        this.parent.update();\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    detachWidget(index, widget) {\n        // Remove the layout item for the widget.\n        let item = ArrayExt.removeAt(this._items, index);\n        // Remove the sizer for the widget.\n        ArrayExt.removeAt(this._sizers, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        super.onBeforeShow(msg);\n        this.parent.update();\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        super.onBeforeAttach(msg);\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    onChildShown(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    onChildHidden(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    onFitRequest(msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    }\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    _fit() {\n        // Compute the visible item count.\n        let nVisible = 0;\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Update the fixed space for the visible items.\n        this._fixed = this._spacing * Math.max(0, nVisible - 1);\n        // Setup the computed minimum size.\n        let horz = Private$c.isHorizontal(this._direction);\n        let minW = horz ? this._fixed : 0;\n        let minH = horz ? 0 : this._fixed;\n        // Update the sizers and computed minimum size.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item and corresponding box sizer.\n            let item = this._items[i];\n            let sizer = this._sizers[i];\n            // If the item is hidden, it should consume zero size.\n            if (item.isHidden) {\n                sizer.minSize = 0;\n                sizer.maxSize = 0;\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the size basis and stretch factor.\n            sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);\n            sizer.stretch = BoxLayout.getStretch(item.widget);\n            // Update the sizer limits and computed min size.\n            if (horz) {\n                sizer.minSize = item.minWidth;\n                sizer.maxSize = item.maxWidth;\n                minW += item.minWidth;\n                minH = Math.max(minH, item.minHeight);\n            }\n            else {\n                sizer.minSize = item.minHeight;\n                sizer.maxSize = item.maxHeight;\n                minH += item.minHeight;\n                minW = Math.max(minW, item.minWidth);\n            }\n        }\n        // Update the box sizing and add it to the computed min size.\n        let box = (this._box = ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        let style = this.parent.node.style;\n        style.minWidth = `${minW}px`;\n        style.minHeight = `${minH}px`;\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    }\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    _update(offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        let nVisible = 0;\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the layout area adjusted for border and padding.\n        let top = this._box.paddingTop;\n        let left = this._box.paddingLeft;\n        let width = offsetWidth - this._box.horizontalSum;\n        let height = offsetHeight - this._box.verticalSum;\n        // Distribute the layout space and adjust the start position.\n        let delta;\n        switch (this._direction) {\n            case 'left-to-right':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n                break;\n            case 'top-to-bottom':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n                break;\n            case 'right-to-left':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));\n                left += width;\n                break;\n            case 'bottom-to-top':\n                delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));\n                top += height;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Setup the variables for justification and alignment offset.\n        let extra = 0;\n        let offset = 0;\n        // Account for alignment if there is extra layout space.\n        if (delta > 0) {\n            switch (this._alignment) {\n                case 'start':\n                    break;\n                case 'center':\n                    extra = 0;\n                    offset = delta / 2;\n                    break;\n                case 'end':\n                    extra = 0;\n                    offset = delta;\n                    break;\n                case 'justify':\n                    extra = delta / nVisible;\n                    offset = 0;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Layout the items using the computed box sizes.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Fetch the computed size for the widget.\n            let size = this._sizers[i].size;\n            // Update the widget geometry and advance the relevant edge.\n            switch (this._direction) {\n                case 'left-to-right':\n                    item.update(left + offset, top, size + extra, height);\n                    left += size + extra + this._spacing;\n                    break;\n                case 'top-to-bottom':\n                    item.update(left, top + offset, width, size + extra);\n                    top += size + extra + this._spacing;\n                    break;\n                case 'right-to-left':\n                    item.update(left - offset - size - extra, top, size + extra, height);\n                    left -= size + extra + this._spacing;\n                    break;\n                case 'bottom-to-top':\n                    item.update(left, top - offset - size - extra, width, size + extra);\n                    top -= size + extra + this._spacing;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n    }\n}\n/**\n * The namespace for the `BoxLayout` class statics.\n */\n(function (BoxLayout) {\n    /**\n     * Get the box layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box layout stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return Private$c.stretchProperty.get(widget);\n    }\n    BoxLayout.getStretch = getStretch;\n    /**\n     * Set the box layout stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        Private$c.stretchProperty.set(widget, value);\n    }\n    BoxLayout.setStretch = setStretch;\n    /**\n     * Get the box layout size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box layout size basis for the widget.\n     */\n    function getSizeBasis(widget) {\n        return Private$c.sizeBasisProperty.get(widget);\n    }\n    BoxLayout.getSizeBasis = getSizeBasis;\n    /**\n     * Set the box layout size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the size basis.\n     */\n    function setSizeBasis(widget, value) {\n        Private$c.sizeBasisProperty.set(widget, value);\n    }\n    BoxLayout.setSizeBasis = setSizeBasis;\n})(BoxLayout || (BoxLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$c;\n(function (Private) {\n    /**\n     * The property descriptor for a widget stretch factor.\n     */\n    Private.stretchProperty = new AttachedProperty({\n        name: 'stretch',\n        create: () => 0,\n        coerce: (owner, value) => Math.max(0, Math.floor(value)),\n        changed: onChildSizingChanged\n    });\n    /**\n     * The property descriptor for a widget size basis.\n     */\n    Private.sizeBasisProperty = new AttachedProperty({\n        name: 'sizeBasis',\n        create: () => 0,\n        coerce: (owner, value) => Math.max(0, Math.floor(value)),\n        changed: onChildSizingChanged\n    });\n    /**\n     * Test whether a direction has horizontal orientation.\n     */\n    function isHorizontal(dir) {\n        return dir === 'left-to-right' || dir === 'right-to-left';\n    }\n    Private.isHorizontal = isHorizontal;\n    /**\n     * Clamp a spacing value to an integer >= 0.\n     */\n    function clampSpacing(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Private.clampSpacing = clampSpacing;\n    /**\n     * The change handler for the attached sizing properties.\n     */\n    function onChildSizingChanged(child) {\n        if (child.parent && child.parent.layout instanceof BoxLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$c || (Private$c = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A panel which arranges its widgets in a single row or column.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link BoxLayout}.\n */\nclass BoxPanel extends Panel {\n    /**\n     * Construct a new box panel.\n     *\n     * @param options - The options for initializing the box panel.\n     */\n    constructor(options = {}) {\n        super({ layout: Private$b.createLayout(options) });\n        this.addClass('lm-BoxPanel');\n    }\n    /**\n     * Get the layout direction for the box panel.\n     */\n    get direction() {\n        return this.layout.direction;\n    }\n    /**\n     * Set the layout direction for the box panel.\n     */\n    set direction(value) {\n        this.layout.direction = value;\n    }\n    /**\n     * Get the content alignment for the box panel.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire box layout.\n     */\n    get alignment() {\n        return this.layout.alignment;\n    }\n    /**\n     * Set the content alignment for the box panel.\n     *\n     * #### Notes\n     * This is the alignment of the widgets in the layout direction.\n     *\n     * The alignment has no effect if the widgets can expand to fill the\n     * entire box layout.\n     */\n    set alignment(value) {\n        this.layout.alignment = value;\n    }\n    /**\n     * Get the inter-element spacing for the box panel.\n     */\n    get spacing() {\n        return this.layout.spacing;\n    }\n    /**\n     * Set the inter-element spacing for the box panel.\n     */\n    set spacing(value) {\n        this.layout.spacing = value;\n    }\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    onChildAdded(msg) {\n        msg.child.addClass('lm-BoxPanel-child');\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    onChildRemoved(msg) {\n        msg.child.removeClass('lm-BoxPanel-child');\n    }\n}\n/**\n * The namespace for the `BoxPanel` class statics.\n */\n(function (BoxPanel) {\n    /**\n     * Get the box panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box panel stretch factor for the widget.\n     */\n    function getStretch(widget) {\n        return BoxLayout.getStretch(widget);\n    }\n    BoxPanel.getStretch = getStretch;\n    /**\n     * Set the box panel stretch factor for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the stretch factor.\n     */\n    function setStretch(widget, value) {\n        BoxLayout.setStretch(widget, value);\n    }\n    BoxPanel.setStretch = setStretch;\n    /**\n     * Get the box panel size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The box panel size basis for the widget.\n     */\n    function getSizeBasis(widget) {\n        return BoxLayout.getSizeBasis(widget);\n    }\n    BoxPanel.getSizeBasis = getSizeBasis;\n    /**\n     * Set the box panel size basis for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the size basis.\n     */\n    function setSizeBasis(widget, value) {\n        BoxLayout.setSizeBasis(widget, value);\n    }\n    BoxPanel.setSizeBasis = setSizeBasis;\n})(BoxPanel || (BoxPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$b;\n(function (Private) {\n    /**\n     * Create a box layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new BoxLayout(options);\n    }\n    Private.createLayout = createLayout;\n})(Private$b || (Private$b = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A widget which displays command items as a searchable palette.\n */\nclass CommandPalette extends Widget {\n    /**\n     * Construct a new command palette.\n     *\n     * @param options - The options for initializing the palette.\n     */\n    constructor(options) {\n        super({ node: Private$a.createNode() });\n        this._activeIndex = -1;\n        this._items = [];\n        this._results = null;\n        this.addClass('lm-CommandPalette');\n        this.setFlag(Widget.Flag.DisallowLayout);\n        this.commands = options.commands;\n        this.renderer = options.renderer || CommandPalette.defaultRenderer;\n        this.commands.commandChanged.connect(this._onGenericChange, this);\n        this.commands.keyBindingChanged.connect(this._onGenericChange, this);\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        this._items.length = 0;\n        this._results = null;\n        super.dispose();\n    }\n    /**\n     * The command palette search node.\n     *\n     * #### Notes\n     * This is the node which contains the search-related elements.\n     */\n    get searchNode() {\n        return this.node.getElementsByClassName('lm-CommandPalette-search')[0];\n    }\n    /**\n     * The command palette input node.\n     *\n     * #### Notes\n     * This is the actual input node for the search area.\n     */\n    get inputNode() {\n        return this.node.getElementsByClassName('lm-CommandPalette-input')[0];\n    }\n    /**\n     * The command palette content node.\n     *\n     * #### Notes\n     * This is the node which holds the command item nodes.\n     *\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get contentNode() {\n        return this.node.getElementsByClassName('lm-CommandPalette-content')[0];\n    }\n    /**\n     * A read-only array of the command items in the palette.\n     */\n    get items() {\n        return this._items;\n    }\n    /**\n     * Add a command item to the command palette.\n     *\n     * @param options - The options for creating the command item.\n     *\n     * @returns The command item added to the palette.\n     */\n    addItem(options) {\n        // Create a new command item for the options.\n        let item = Private$a.createItem(this.commands, options);\n        // Add the item to the array.\n        this._items.push(item);\n        // Refresh the search results.\n        this.refresh();\n        // Return the item added to the palette.\n        return item;\n    }\n    /**\n     * Adds command items to the command palette.\n     *\n     * @param items - An array of options for creating each command item.\n     *\n     * @returns The command items added to the palette.\n     */\n    addItems(items) {\n        const newItems = items.map(item => Private$a.createItem(this.commands, item));\n        newItems.forEach(item => this._items.push(item));\n        this.refresh();\n        return newItems;\n    }\n    /**\n     * Remove an item from the command palette.\n     *\n     * @param item - The item to remove from the palette.\n     *\n     * #### Notes\n     * This is a no-op if the item is not in the palette.\n     */\n    removeItem(item) {\n        this.removeItemAt(this._items.indexOf(item));\n    }\n    /**\n     * Remove the item at a given index from the command palette.\n     *\n     * @param index - The index of the item to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    removeItemAt(index) {\n        // Remove the item from the array.\n        let item = ArrayExt.removeAt(this._items, index);\n        // Bail if the index is out of range.\n        if (!item) {\n            return;\n        }\n        // Refresh the search results.\n        this.refresh();\n    }\n    /**\n     * Remove all items from the command palette.\n     */\n    clearItems() {\n        // Bail if there is nothing to remove.\n        if (this._items.length === 0) {\n            return;\n        }\n        // Clear the array of items.\n        this._items.length = 0;\n        // Refresh the search results.\n        this.refresh();\n    }\n    /**\n     * Clear the search results and schedule an update.\n     *\n     * #### Notes\n     * This should be called whenever the search results of the palette\n     * should be updated.\n     *\n     * This is typically called automatically by the palette as needed,\n     * but can be called manually if the input text is programatically\n     * changed.\n     *\n     * The rendered results are updated asynchronously.\n     */\n    refresh() {\n        this._results = null;\n        if (this.inputNode.value !== '') {\n            let clear = this.node.getElementsByClassName('lm-close-icon')[0];\n            clear.style.display = 'inherit';\n        }\n        else {\n            let clear = this.node.getElementsByClassName('lm-close-icon')[0];\n            clear.style.display = 'none';\n        }\n        this.update();\n    }\n    /**\n     * Handle the DOM events for the command palette.\n     *\n     * @param event - The DOM event sent to the command palette.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the command palette's DOM node.\n     * It should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'click':\n                this._evtClick(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'input':\n                this.refresh();\n                break;\n            case 'focus':\n            case 'blur':\n                this._toggleFocused();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('input', this);\n        this.node.addEventListener('focus', this, true);\n        this.node.addEventListener('blur', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('input', this);\n        this.node.removeEventListener('focus', this, true);\n        this.node.removeEventListener('blur', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        this.update();\n        super.onAfterShow(msg);\n    }\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    onActivateRequest(msg) {\n        if (this.isAttached) {\n            let input = this.inputNode;\n            input.focus();\n            input.select();\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.isHidden) {\n            return;\n        }\n        // Fetch the current query text and content node.\n        let query = this.inputNode.value;\n        let contentNode = this.contentNode;\n        // Ensure the search results are generated.\n        let results = this._results;\n        if (!results) {\n            // Generate and store the new search results.\n            results = this._results = Private$a.search(this._items, query);\n            // Reset the active index.\n            this._activeIndex = query\n                ? ArrayExt.findFirstIndex(results, Private$a.canActivate)\n                : -1;\n        }\n        // If there is no query and no results, clear the content.\n        if (!query && results.length === 0) {\n            VirtualDOM.render(null, contentNode);\n            return;\n        }\n        // If the is a query but no results, render the empty message.\n        if (query && results.length === 0) {\n            let content = this.renderer.renderEmptyMessage({ query });\n            VirtualDOM.render(content, contentNode);\n            return;\n        }\n        // Create the render content for the search results.\n        let renderer = this.renderer;\n        let activeIndex = this._activeIndex;\n        let content = new Array(results.length);\n        for (let i = 0, n = results.length; i < n; ++i) {\n            let result = results[i];\n            if (result.type === 'header') {\n                let indices = result.indices;\n                let category = result.category;\n                content[i] = renderer.renderHeader({ category, indices });\n            }\n            else {\n                let item = result.item;\n                let indices = result.indices;\n                let active = i === activeIndex;\n                content[i] = renderer.renderItem({ item, indices, active });\n            }\n        }\n        // Render the search result content.\n        VirtualDOM.render(content, contentNode);\n        // Adjust the scroll position as needed.\n        if (activeIndex < 0 || activeIndex >= results.length) {\n            contentNode.scrollTop = 0;\n        }\n        else {\n            let element = contentNode.children[activeIndex];\n            ElementExt.scrollIntoViewIfNeeded(contentNode, element);\n        }\n    }\n    /**\n     * Handle the `'click'` event for the command palette.\n     */\n    _evtClick(event) {\n        // Bail if the click is not the left button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Clear input if the target is clear button\n        if (event.target.classList.contains('lm-close-icon')) {\n            this.inputNode.value = '';\n            this.refresh();\n            return;\n        }\n        // Find the index of the item which was clicked.\n        let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n            return node.contains(event.target);\n        });\n        // Bail if the click was not on an item.\n        if (index === -1) {\n            return;\n        }\n        // Kill the event when a content item is clicked.\n        event.preventDefault();\n        event.stopPropagation();\n        // Execute the item if possible.\n        this._execute(index);\n    }\n    /**\n     * Handle the `'keydown'` event for the command palette.\n     */\n    _evtKeyDown(event) {\n        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {\n            return;\n        }\n        switch (event.keyCode) {\n            case 13: // Enter\n                event.preventDefault();\n                event.stopPropagation();\n                this._execute(this._activeIndex);\n                break;\n            case 38: // Up Arrow\n                event.preventDefault();\n                event.stopPropagation();\n                this._activatePreviousItem();\n                break;\n            case 40: // Down Arrow\n                event.preventDefault();\n                event.stopPropagation();\n                this._activateNextItem();\n                break;\n        }\n    }\n    /**\n     * Activate the next enabled command item.\n     */\n    _activateNextItem() {\n        // Bail if there are no search results.\n        if (!this._results || this._results.length === 0) {\n            return;\n        }\n        // Find the next enabled item index.\n        let ai = this._activeIndex;\n        let n = this._results.length;\n        let start = ai < n - 1 ? ai + 1 : 0;\n        let stop = start === 0 ? n - 1 : start - 1;\n        this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a.canActivate, start, stop);\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * Activate the previous enabled command item.\n     */\n    _activatePreviousItem() {\n        // Bail if there are no search results.\n        if (!this._results || this._results.length === 0) {\n            return;\n        }\n        // Find the previous enabled item index.\n        let ai = this._activeIndex;\n        let n = this._results.length;\n        let start = ai <= 0 ? n - 1 : ai - 1;\n        let stop = start === n - 1 ? 0 : start + 1;\n        this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a.canActivate, start, stop);\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * Execute the command item at the given index, if possible.\n     */\n    _execute(index) {\n        // Bail if there are no search results.\n        if (!this._results) {\n            return;\n        }\n        // Bail if the index is out of range.\n        let part = this._results[index];\n        if (!part) {\n            return;\n        }\n        // Update the search text if the item is a header.\n        if (part.type === 'header') {\n            let input = this.inputNode;\n            input.value = `${part.category.toLowerCase()} `;\n            input.focus();\n            this.refresh();\n            return;\n        }\n        // Bail if item is not enabled.\n        if (!part.item.isEnabled) {\n            return;\n        }\n        // Execute the item.\n        this.commands.execute(part.item.command, part.item.args);\n        // Clear the query text.\n        this.inputNode.value = '';\n        // Refresh the search results.\n        this.refresh();\n    }\n    /**\n     * Toggle the focused modifier based on the input node focus state.\n     */\n    _toggleFocused() {\n        let focused = document.activeElement === this.inputNode;\n        this.toggleClass('lm-mod-focused', focused);\n    }\n    /**\n     * A signal handler for generic command changes.\n     */\n    _onGenericChange() {\n        this.refresh();\n    }\n}\n/**\n * The namespace for the `CommandPalette` class statics.\n */\n(function (CommandPalette) {\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    class Renderer {\n        /**\n         * Render the virtual element for a command palette header.\n         *\n         * @param data - The data to use for rendering the header.\n         *\n         * @returns A virtual element representing the header.\n         */\n        renderHeader(data) {\n            let content = this.formatHeader(data);\n            return h.li({ className: 'lm-CommandPalette-header' }, content);\n        }\n        /**\n         * Render the virtual element for a command palette item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        renderItem(data) {\n            let className = this.createItemClass(data);\n            let dataset = this.createItemDataset(data);\n            if (data.item.isToggleable) {\n                return h.li({\n                    className,\n                    dataset,\n                    role: 'menuitemcheckbox',\n                    'aria-checked': `${data.item.isToggled}`\n                }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));\n            }\n            return h.li({\n                className,\n                dataset,\n                role: 'menuitem'\n            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));\n        }\n        /**\n         * Render the empty results message for a command palette.\n         *\n         * @param data - The data to use for rendering the message.\n         *\n         * @returns A virtual element representing the message.\n         */\n        renderEmptyMessage(data) {\n            let content = this.formatEmptyMessage(data);\n            return h.li({ className: 'lm-CommandPalette-emptyMessage' }, content);\n        }\n        /**\n         * Render the icon for a command palette item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the icon.\n         */\n        renderItemIcon(data) {\n            let className = this.createIconClass(data);\n            // If data.item.icon is undefined, it will be ignored.\n            return h.div({ className }, data.item.icon, data.item.iconLabel);\n        }\n        /**\n         * Render the content for a command palette item.\n         *\n         * @param data - The data to use for rendering the content.\n         *\n         * @returns A virtual element representing the content.\n         */\n        renderItemContent(data) {\n            return h.div({ className: 'lm-CommandPalette-itemContent' }, this.renderItemLabel(data), this.renderItemCaption(data));\n        }\n        /**\n         * Render the label for a command palette item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the label.\n         */\n        renderItemLabel(data) {\n            let content = this.formatItemLabel(data);\n            return h.div({ className: 'lm-CommandPalette-itemLabel' }, content);\n        }\n        /**\n         * Render the caption for a command palette item.\n         *\n         * @param data - The data to use for rendering the caption.\n         *\n         * @returns A virtual element representing the caption.\n         */\n        renderItemCaption(data) {\n            let content = this.formatItemCaption(data);\n            return h.div({ className: 'lm-CommandPalette-itemCaption' }, content);\n        }\n        /**\n         * Render the shortcut for a command palette item.\n         *\n         * @param data - The data to use for rendering the shortcut.\n         *\n         * @returns A virtual element representing the shortcut.\n         */\n        renderItemShortcut(data) {\n            let content = this.formatItemShortcut(data);\n            return h.div({ className: 'lm-CommandPalette-itemShortcut' }, content);\n        }\n        /**\n         * Create the class name for the command palette item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the command palette item.\n         */\n        createItemClass(data) {\n            // Set up the initial class name.\n            let name = 'lm-CommandPalette-item';\n            // Add the boolean state classes.\n            if (!data.item.isEnabled) {\n                name += ' lm-mod-disabled';\n            }\n            if (data.item.isToggled) {\n                name += ' lm-mod-toggled';\n            }\n            if (data.active) {\n                name += ' lm-mod-active';\n            }\n            // Add the extra class.\n            let extra = data.item.className;\n            if (extra) {\n                name += ` ${extra}`;\n            }\n            // Return the complete class name.\n            return name;\n        }\n        /**\n         * Create the dataset for the command palette item.\n         *\n         * @param data - The data to use for creating the dataset.\n         *\n         * @returns The dataset for the command palette item.\n         */\n        createItemDataset(data) {\n            return { ...data.item.dataset, command: data.item.command };\n        }\n        /**\n         * Create the class name for the command item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        createIconClass(data) {\n            let name = 'lm-CommandPalette-itemIcon';\n            let extra = data.item.iconClass;\n            return extra ? `${name} ${extra}` : name;\n        }\n        /**\n         * Create the render content for the header node.\n         *\n         * @param data - The data to use for the header content.\n         *\n         * @returns The content to add to the header node.\n         */\n        formatHeader(data) {\n            if (!data.indices || data.indices.length === 0) {\n                return data.category;\n            }\n            return StringExt.highlight(data.category, data.indices, h.mark);\n        }\n        /**\n         * Create the render content for the empty message node.\n         *\n         * @param data - The data to use for the empty message content.\n         *\n         * @returns The content to add to the empty message node.\n         */\n        formatEmptyMessage(data) {\n            return `No commands found that match '${data.query}'`;\n        }\n        /**\n         * Create the render content for the item shortcut node.\n         *\n         * @param data - The data to use for the shortcut content.\n         *\n         * @returns The content to add to the shortcut node.\n         */\n        formatItemShortcut(data) {\n            let kb = data.item.keyBinding;\n            return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;\n        }\n        /**\n         * Create the render content for the item label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        formatItemLabel(data) {\n            if (!data.indices || data.indices.length === 0) {\n                return data.item.label;\n            }\n            return StringExt.highlight(data.item.label, data.indices, h.mark);\n        }\n        /**\n         * Create the render content for the item caption node.\n         *\n         * @param data - The data to use for the caption content.\n         *\n         * @returns The content to add to the caption node.\n         */\n        formatItemCaption(data) {\n            return data.item.caption;\n        }\n    }\n    CommandPalette.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    CommandPalette.defaultRenderer = new Renderer();\n})(CommandPalette || (CommandPalette = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$a;\n(function (Private) {\n    /**\n     * Create the DOM node for a command palette.\n     */\n    function createNode() {\n        let node = document.createElement('div');\n        let search = document.createElement('div');\n        let wrapper = document.createElement('div');\n        let input = document.createElement('input');\n        let content = document.createElement('ul');\n        let clear = document.createElement('button');\n        search.className = 'lm-CommandPalette-search';\n        wrapper.className = 'lm-CommandPalette-wrapper';\n        input.className = 'lm-CommandPalette-input';\n        clear.className = 'lm-close-icon';\n        content.className = 'lm-CommandPalette-content';\n        content.setAttribute('role', 'menu');\n        input.spellcheck = false;\n        wrapper.appendChild(input);\n        wrapper.appendChild(clear);\n        search.appendChild(wrapper);\n        node.appendChild(search);\n        node.appendChild(content);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Create a new command item from a command registry and options.\n     */\n    function createItem(commands, options) {\n        return new CommandItem(commands, options);\n    }\n    Private.createItem = createItem;\n    /**\n     * Search an array of command items for fuzzy matches.\n     */\n    function search(items, query) {\n        // Fuzzy match the items for the query.\n        let scores = matchItems(items, query);\n        // Sort the items based on their score.\n        scores.sort(scoreCmp);\n        // Create the results for the search.\n        return createResults(scores);\n    }\n    Private.search = search;\n    /**\n     * Test whether a result item can be activated.\n     */\n    function canActivate(result) {\n        return result.type === 'item' && result.item.isEnabled;\n    }\n    Private.canActivate = canActivate;\n    /**\n     * Normalize a category for a command item.\n     */\n    function normalizeCategory(category) {\n        return category.trim().replace(/\\s+/g, ' ');\n    }\n    /**\n     * Normalize the query text for a fuzzy search.\n     */\n    function normalizeQuery(text) {\n        return text.replace(/\\s+/g, '').toLowerCase();\n    }\n    /**\n     * Perform a fuzzy match on an array of command items.\n     */\n    function matchItems(items, query) {\n        // Normalize the query text to lower case with no whitespace.\n        query = normalizeQuery(query);\n        // Create the array to hold the scores.\n        let scores = [];\n        // Iterate over the items and match against the query.\n        for (let i = 0, n = items.length; i < n; ++i) {\n            // Ignore items which are not visible.\n            let item = items[i];\n            if (!item.isVisible) {\n                continue;\n            }\n            // If the query is empty, all items are matched by default.\n            if (!query) {\n                scores.push({\n                    matchType: 3 /* MatchType.Default */,\n                    categoryIndices: null,\n                    labelIndices: null,\n                    score: 0,\n                    item\n                });\n                continue;\n            }\n            // Run the fuzzy search for the item and query.\n            let score = fuzzySearch(item, query);\n            // Ignore the item if it is not a match.\n            if (!score) {\n                continue;\n            }\n            // Penalize disabled items.\n            // TODO - push disabled items all the way down in sort cmp?\n            if (!item.isEnabled) {\n                score.score += 1000;\n            }\n            // Add the score to the results.\n            scores.push(score);\n        }\n        // Return the final array of scores.\n        return scores;\n    }\n    /**\n     * Perform a fuzzy search on a single command item.\n     */\n    function fuzzySearch(item, query) {\n        // Create the source text to be searched.\n        let category = item.category.toLowerCase();\n        let label = item.label.toLowerCase();\n        let source = `${category} ${label}`;\n        // Set up the match score and indices array.\n        let score = Infinity;\n        let indices = null;\n        // The regex for search word boundaries\n        let rgx = /\\b\\w/g;\n        // Search the source by word boundary.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // Find the next word boundary in the source.\n            let rgxMatch = rgx.exec(source);\n            // Break if there is no more source context.\n            if (!rgxMatch) {\n                break;\n            }\n            // Run the string match on the relevant substring.\n            let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);\n            // Break if there is no match.\n            if (!match) {\n                break;\n            }\n            // Update the match if the score is better.\n            if (match.score <= score) {\n                score = match.score;\n                indices = match.indices;\n            }\n        }\n        // Bail if there was no match.\n        if (!indices || score === Infinity) {\n            return null;\n        }\n        // Compute the pivot index between category and label text.\n        let pivot = category.length + 1;\n        // Find the slice index to separate matched indices.\n        let j = ArrayExt.lowerBound(indices, pivot, (a, b) => a - b);\n        // Extract the matched category and label indices.\n        let categoryIndices = indices.slice(0, j);\n        let labelIndices = indices.slice(j);\n        // Adjust the label indices for the pivot offset.\n        for (let i = 0, n = labelIndices.length; i < n; ++i) {\n            labelIndices[i] -= pivot;\n        }\n        // Handle a pure label match.\n        if (categoryIndices.length === 0) {\n            return {\n                matchType: 0 /* MatchType.Label */,\n                categoryIndices: null,\n                labelIndices,\n                score,\n                item\n            };\n        }\n        // Handle a pure category match.\n        if (labelIndices.length === 0) {\n            return {\n                matchType: 1 /* MatchType.Category */,\n                categoryIndices,\n                labelIndices: null,\n                score,\n                item\n            };\n        }\n        // Handle a split match.\n        return {\n            matchType: 2 /* MatchType.Split */,\n            categoryIndices,\n            labelIndices,\n            score,\n            item\n        };\n    }\n    /**\n     * A sort comparison function for a match score.\n     */\n    function scoreCmp(a, b) {\n        // First compare based on the match type\n        let m1 = a.matchType - b.matchType;\n        if (m1 !== 0) {\n            return m1;\n        }\n        // Otherwise, compare based on the match score.\n        let d1 = a.score - b.score;\n        if (d1 !== 0) {\n            return d1;\n        }\n        // Find the match index based on the match type.\n        let i1 = 0;\n        let i2 = 0;\n        switch (a.matchType) {\n            case 0 /* MatchType.Label */:\n                i1 = a.labelIndices[0];\n                i2 = b.labelIndices[0];\n                break;\n            case 1 /* MatchType.Category */:\n            case 2 /* MatchType.Split */:\n                i1 = a.categoryIndices[0];\n                i2 = b.categoryIndices[0];\n                break;\n        }\n        // Compare based on the match index.\n        if (i1 !== i2) {\n            return i1 - i2;\n        }\n        // Otherwise, compare by category.\n        let d2 = a.item.category.localeCompare(b.item.category);\n        if (d2 !== 0) {\n            return d2;\n        }\n        // Otherwise, compare by rank.\n        let r1 = a.item.rank;\n        let r2 = b.item.rank;\n        if (r1 !== r2) {\n            return r1 < r2 ? -1 : 1; // Infinity safe\n        }\n        // Finally, compare by label.\n        return a.item.label.localeCompare(b.item.label);\n    }\n    /**\n     * Create the results from an array of sorted scores.\n     */\n    function createResults(scores) {\n        // Set up the search results array.\n        let results = [];\n        // Iterate over each score in the array.\n        for (let i = 0, n = scores.length; i < n; ++i) {\n            // Extract the current item and indices.\n            let { item, categoryIndices, labelIndices } = scores[i];\n            // Extract the category for the current item.\n            let category = item.category;\n            // Is this the same category as the preceding result?\n            if (i === 0 || category !== scores[i - 1].item.category) {\n                // Add the header result for the category.\n                results.push({ type: 'header', category, indices: categoryIndices });\n            }\n            // Create the item result for the score.\n            results.push({ type: 'item', item, indices: labelIndices });\n        }\n        // Return the final results.\n        return results;\n    }\n    /**\n     * A concrete implementation of `CommandPalette.IItem`.\n     */\n    class CommandItem {\n        /**\n         * Construct a new command item.\n         */\n        constructor(commands, options) {\n            this._commands = commands;\n            this.category = normalizeCategory(options.category);\n            this.command = options.command;\n            this.args = options.args || JSONExt.emptyObject;\n            this.rank = options.rank !== undefined ? options.rank : Infinity;\n        }\n        /**\n         * The display label for the command item.\n         */\n        get label() {\n            return this._commands.label(this.command, this.args);\n        }\n        /**\n         * The icon renderer for the command item.\n         */\n        get icon() {\n            return this._commands.icon(this.command, this.args);\n        }\n        /**\n         * The icon class for the command item.\n         */\n        get iconClass() {\n            return this._commands.iconClass(this.command, this.args);\n        }\n        /**\n         * The icon label for the command item.\n         */\n        get iconLabel() {\n            return this._commands.iconLabel(this.command, this.args);\n        }\n        /**\n         * The display caption for the command item.\n         */\n        get caption() {\n            return this._commands.caption(this.command, this.args);\n        }\n        /**\n         * The extra class name for the command item.\n         */\n        get className() {\n            return this._commands.className(this.command, this.args);\n        }\n        /**\n         * The dataset for the command item.\n         */\n        get dataset() {\n            return this._commands.dataset(this.command, this.args);\n        }\n        /**\n         * Whether the command item is enabled.\n         */\n        get isEnabled() {\n            return this._commands.isEnabled(this.command, this.args);\n        }\n        /**\n         * Whether the command item is toggled.\n         */\n        get isToggled() {\n            return this._commands.isToggled(this.command, this.args);\n        }\n        /**\n         * Whether the command item is toggleable.\n         */\n        get isToggleable() {\n            return this._commands.isToggleable(this.command, this.args);\n        }\n        /**\n         * Whether the command item is visible.\n         */\n        get isVisible() {\n            return this._commands.isVisible(this.command, this.args);\n        }\n        /**\n         * The key binding for the command item.\n         */\n        get keyBinding() {\n            let { command, args } = this;\n            return (ArrayExt.findLastValue(this._commands.keyBindings, kb => {\n                return kb.command === command && JSONExt.deepEqual(kb.args, args);\n            }) || null);\n        }\n    }\n})(Private$a || (Private$a = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A widget which displays items as a canonical menu.\n */\nclass Menu extends Widget {\n    /**\n     * Construct a new menu.\n     *\n     * @param options - The options for initializing the menu.\n     */\n    constructor(options) {\n        super({ node: Private$9.createNode() });\n        this._childIndex = -1;\n        this._activeIndex = -1;\n        this._openTimerID = 0;\n        this._closeTimerID = 0;\n        this._items = [];\n        this._childMenu = null;\n        this._parentMenu = null;\n        this._aboutToClose = new Signal(this);\n        this._menuRequested = new Signal(this);\n        this.addClass('lm-Menu');\n        this.setFlag(Widget.Flag.DisallowLayout);\n        this.commands = options.commands;\n        this.renderer = options.renderer || Menu.defaultRenderer;\n    }\n    /**\n     * Dispose of the resources held by the menu.\n     */\n    dispose() {\n        this.close();\n        this._items.length = 0;\n        super.dispose();\n    }\n    /**\n     * A signal emitted just before the menu is closed.\n     *\n     * #### Notes\n     * This signal is emitted when the menu receives a `'close-request'`\n     * message, just before it removes itself from the DOM.\n     *\n     * This signal is not emitted if the menu is already detached from\n     * the DOM when it receives the `'close-request'` message.\n     */\n    get aboutToClose() {\n        return this._aboutToClose;\n    }\n    /**\n     * A signal emitted when a new menu is requested by the user.\n     *\n     * #### Notes\n     * This signal is emitted whenever the user presses the right or left\n     * arrow keys, and a submenu cannot be opened or closed in response.\n     *\n     * This signal is useful when implementing menu bars in order to open\n     * the next or previous menu in response to a user key press.\n     *\n     * This signal is only emitted for the root menu in a hierarchy.\n     */\n    get menuRequested() {\n        return this._menuRequested;\n    }\n    /**\n     * The parent menu of the menu.\n     *\n     * #### Notes\n     * This is `null` unless the menu is an open submenu.\n     */\n    get parentMenu() {\n        return this._parentMenu;\n    }\n    /**\n     * The child menu of the menu.\n     *\n     * #### Notes\n     * This is `null` unless the menu has an open submenu.\n     */\n    get childMenu() {\n        return this._childMenu;\n    }\n    /**\n     * The root menu of the menu hierarchy.\n     */\n    get rootMenu() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let menu = this;\n        while (menu._parentMenu) {\n            menu = menu._parentMenu;\n        }\n        return menu;\n    }\n    /**\n     * The leaf menu of the menu hierarchy.\n     */\n    get leafMenu() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let menu = this;\n        while (menu._childMenu) {\n            menu = menu._childMenu;\n        }\n        return menu;\n    }\n    /**\n     * The menu content node.\n     *\n     * #### Notes\n     * This is the node which holds the menu item nodes.\n     *\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get contentNode() {\n        return this.node.getElementsByClassName('lm-Menu-content')[0];\n    }\n    /**\n     * Get the currently active menu item.\n     */\n    get activeItem() {\n        return this._items[this._activeIndex] || null;\n    }\n    /**\n     * Set the currently active menu item.\n     *\n     * #### Notes\n     * If the item cannot be activated, the item will be set to `null`.\n     */\n    set activeItem(value) {\n        this.activeIndex = value ? this._items.indexOf(value) : -1;\n    }\n    /**\n     * Get the index of the currently active menu item.\n     *\n     * #### Notes\n     * This will be `-1` if no menu item is active.\n     */\n    get activeIndex() {\n        return this._activeIndex;\n    }\n    /**\n     * Set the index of the currently active menu item.\n     *\n     * #### Notes\n     * If the item cannot be activated, the index will be set to `-1`.\n     */\n    set activeIndex(value) {\n        // Adjust the value for an out of range index.\n        if (value < 0 || value >= this._items.length) {\n            value = -1;\n        }\n        // Ensure the item can be activated.\n        if (value !== -1 && !Private$9.canActivate(this._items[value])) {\n            value = -1;\n        }\n        // Bail if the index will not change.\n        if (this._activeIndex === value) {\n            return;\n        }\n        // Update the active index.\n        this._activeIndex = value;\n        // Make active element in focus\n        if (this._activeIndex >= 0 &&\n            this.contentNode.childNodes[this._activeIndex]) {\n            this.contentNode.childNodes[this._activeIndex].focus();\n        }\n        // schedule an update of the items.\n        this.update();\n    }\n    /**\n     * A read-only array of the menu items in the menu.\n     */\n    get items() {\n        return this._items;\n    }\n    /**\n     * Activate the next selectable item in the menu.\n     *\n     * #### Notes\n     * If no item is selectable, the index will be set to `-1`.\n     */\n    activateNextItem() {\n        let n = this._items.length;\n        let ai = this._activeIndex;\n        let start = ai < n - 1 ? ai + 1 : 0;\n        let stop = start === 0 ? n - 1 : start - 1;\n        this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$9.canActivate, start, stop);\n    }\n    /**\n     * Activate the previous selectable item in the menu.\n     *\n     * #### Notes\n     * If no item is selectable, the index will be set to `-1`.\n     */\n    activatePreviousItem() {\n        let n = this._items.length;\n        let ai = this._activeIndex;\n        let start = ai <= 0 ? n - 1 : ai - 1;\n        let stop = start === n - 1 ? 0 : start + 1;\n        this.activeIndex = ArrayExt.findLastIndex(this._items, Private$9.canActivate, start, stop);\n    }\n    /**\n     * Trigger the active menu item.\n     *\n     * #### Notes\n     * If the active item is a submenu, it will be opened and the first\n     * item will be activated.\n     *\n     * If the active item is a command, the command will be executed.\n     *\n     * If the menu is not attached, this is a no-op.\n     *\n     * If there is no active item, this is a no-op.\n     */\n    triggerActiveItem() {\n        // Bail if the menu is not attached.\n        if (!this.isAttached) {\n            return;\n        }\n        // Bail if there is no active item.\n        let item = this.activeItem;\n        if (!item) {\n            return;\n        }\n        // Cancel the pending timers.\n        this._cancelOpenTimer();\n        this._cancelCloseTimer();\n        // If the item is a submenu, open it.\n        if (item.type === 'submenu') {\n            this._openChildMenu(true);\n            return;\n        }\n        // Close the root menu before executing the command.\n        this.rootMenu.close();\n        // Execute the command for the item.\n        let { command, args } = item;\n        if (this.commands.isEnabled(command, args)) {\n            this.commands.execute(command, args);\n        }\n        else {\n            console.log(`Command '${command}' is disabled.`);\n        }\n    }\n    /**\n     * Add a menu item to the end of the menu.\n     *\n     * @param options - The options for creating the menu item.\n     *\n     * @returns The menu item added to the menu.\n     */\n    addItem(options) {\n        return this.insertItem(this._items.length, options);\n    }\n    /**\n     * Insert a menu item into the menu at the specified index.\n     *\n     * @param index - The index at which to insert the item.\n     *\n     * @param options - The options for creating the menu item.\n     *\n     * @returns The menu item added to the menu.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the items.\n     */\n    insertItem(index, options) {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Clamp the insert index to the array bounds.\n        let i = Math.max(0, Math.min(index, this._items.length));\n        // Create the item for the options.\n        let item = Private$9.createItem(this, options);\n        // Insert the item into the array.\n        ArrayExt.insert(this._items, i, item);\n        // Schedule an update of the items.\n        this.update();\n        // Return the item added to the menu.\n        return item;\n    }\n    /**\n     * Remove an item from the menu.\n     *\n     * @param item - The item to remove from the menu.\n     *\n     * #### Notes\n     * This is a no-op if the item is not in the menu.\n     */\n    removeItem(item) {\n        this.removeItemAt(this._items.indexOf(item));\n    }\n    /**\n     * Remove the item at a given index from the menu.\n     *\n     * @param index - The index of the item to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    removeItemAt(index) {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Remove the item from the array.\n        let item = ArrayExt.removeAt(this._items, index);\n        // Bail if the index is out of range.\n        if (!item) {\n            return;\n        }\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * Remove all menu items from the menu.\n     */\n    clearItems() {\n        // Close the menu if it's attached.\n        if (this.isAttached) {\n            this.close();\n        }\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Bail if there is nothing to remove.\n        if (this._items.length === 0) {\n            return;\n        }\n        // Clear the items.\n        this._items.length = 0;\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * Open the menu at the specified location.\n     *\n     * @param x - The client X coordinate of the menu location.\n     *\n     * @param y - The client Y coordinate of the menu location.\n     *\n     * @param options - The additional options for opening the menu.\n     *\n     * #### Notes\n     * The menu will be opened at the given location unless it will not\n     * fully fit on the screen. If it will not fit, it will be adjusted\n     * to fit naturally on the screen.\n     *\n     * The menu will be attached under the `host` element in the DOM\n     * (or `document.body` if `host` is `null`) and before the `ref`\n     * element (or as the last child of `host` if `ref` is `null`).\n     * The menu may be displayed outside of the `host` element\n     * following the rules of CSS absolute positioning.\n     *\n     * This is a no-op if the menu is already attached to the DOM.\n     */\n    open(x, y, options = {}) {\n        var _a, _b;\n        // Bail early if the menu is already attached.\n        if (this.isAttached) {\n            return;\n        }\n        // Extract the menu options.\n        let forceX = options.forceX || false;\n        let forceY = options.forceY || false;\n        const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;\n        const ref = (_b = options.ref) !== null && _b !== void 0 ? _b : null;\n        // Open the menu as a root menu.\n        Private$9.openRootMenu(this, x, y, forceX, forceY, host, ref);\n        // Activate the menu to accept keyboard input.\n        this.activate();\n    }\n    /**\n     * Handle the DOM events for the menu.\n     *\n     * @param event - The DOM event sent to the menu.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the menu's DOM nodes. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseenter':\n                this._evtMouseEnter(event);\n                break;\n            case 'mouseleave':\n                this._evtMouseLeave(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('mouseup', this);\n        this.node.addEventListener('mousemove', this);\n        this.node.addEventListener('mouseenter', this);\n        this.node.addEventListener('mouseleave', this);\n        this.node.addEventListener('contextmenu', this);\n        document.addEventListener('mousedown', this, true);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('mouseup', this);\n        this.node.removeEventListener('mousemove', this);\n        this.node.removeEventListener('mouseenter', this);\n        this.node.removeEventListener('mouseleave', this);\n        this.node.removeEventListener('contextmenu', this);\n        document.removeEventListener('mousedown', this, true);\n    }\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    onActivateRequest(msg) {\n        if (this.isAttached) {\n            this.node.focus();\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        let items = this._items;\n        let renderer = this.renderer;\n        let activeIndex = this._activeIndex;\n        let collapsedFlags = Private$9.computeCollapsed(items);\n        let content = new Array(items.length);\n        for (let i = 0, n = items.length; i < n; ++i) {\n            let item = items[i];\n            let active = i === activeIndex;\n            let collapsed = collapsedFlags[i];\n            content[i] = renderer.renderItem({\n                item,\n                active,\n                collapsed,\n                onfocus: () => {\n                    this.activeIndex = i;\n                }\n            });\n        }\n        VirtualDOM.render(content, this.contentNode);\n    }\n    /**\n     * A message handler invoked on a `'close-request'` message.\n     */\n    onCloseRequest(msg) {\n        // Cancel the pending timers.\n        this._cancelOpenTimer();\n        this._cancelCloseTimer();\n        // Reset the active index.\n        this.activeIndex = -1;\n        // Close any open child menu.\n        let childMenu = this._childMenu;\n        if (childMenu) {\n            this._childIndex = -1;\n            this._childMenu = null;\n            childMenu._parentMenu = null;\n            childMenu.close();\n        }\n        // Remove this menu from its parent and activate the parent.\n        let parentMenu = this._parentMenu;\n        if (parentMenu) {\n            this._parentMenu = null;\n            parentMenu._childIndex = -1;\n            parentMenu._childMenu = null;\n            parentMenu.activate();\n        }\n        // Emit the `aboutToClose` signal if the menu is attached.\n        if (this.isAttached) {\n            this._aboutToClose.emit(undefined);\n        }\n        // Finish closing the menu.\n        super.onCloseRequest(msg);\n    }\n    /**\n     * Handle the `'keydown'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    _evtKeyDown(event) {\n        // A menu handles all keydown events.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the key code for the event.\n        let kc = event.keyCode;\n        // Enter\n        if (kc === 13) {\n            this.triggerActiveItem();\n            return;\n        }\n        // Escape\n        if (kc === 27) {\n            this.close();\n            return;\n        }\n        // Left Arrow\n        if (kc === 37) {\n            if (this._parentMenu) {\n                this.close();\n            }\n            else {\n                this._menuRequested.emit('previous');\n            }\n            return;\n        }\n        // Up Arrow\n        if (kc === 38) {\n            this.activatePreviousItem();\n            return;\n        }\n        // Right Arrow\n        if (kc === 39) {\n            let item = this.activeItem;\n            if (item && item.type === 'submenu') {\n                this.triggerActiveItem();\n            }\n            else {\n                this.rootMenu._menuRequested.emit('next');\n            }\n            return;\n        }\n        // Down Arrow\n        if (kc === 40) {\n            this.activateNextItem();\n            return;\n        }\n        // Get the pressed key character.\n        let key = getKeyboardLayout().keyForKeydownEvent(event);\n        // Bail if the key is not valid.\n        if (!key) {\n            return;\n        }\n        // Search for the next best matching mnemonic item.\n        let start = this._activeIndex + 1;\n        let result = Private$9.findMnemonic(this._items, key, start);\n        // Handle the requested mnemonic based on the search results.\n        // If exactly one mnemonic is matched, that item is triggered.\n        // Otherwise, the next mnemonic is activated if available,\n        // followed by the auto mnemonic if available.\n        if (result.index !== -1 && !result.multiple) {\n            this.activeIndex = result.index;\n            this.triggerActiveItem();\n        }\n        else if (result.index !== -1) {\n            this.activeIndex = result.index;\n        }\n        else if (result.auto !== -1) {\n            this.activeIndex = result.auto;\n        }\n    }\n    /**\n     * Handle the `'mouseup'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    _evtMouseUp(event) {\n        if (event.button !== 0) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        this.triggerActiveItem();\n    }\n    /**\n     * Handle the `'mousemove'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    _evtMouseMove(event) {\n        // Hit test the item nodes for the item under the mouse.\n        let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n            return ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // Bail early if the mouse is already over the active index.\n        if (index === this._activeIndex) {\n            return;\n        }\n        // Update and coerce the active index.\n        this.activeIndex = index;\n        index = this.activeIndex;\n        // If the index is the current child index, cancel the timers.\n        if (index === this._childIndex) {\n            this._cancelOpenTimer();\n            this._cancelCloseTimer();\n            return;\n        }\n        // If a child menu is currently open, start the close timer.\n        if (this._childIndex !== -1) {\n            this._startCloseTimer();\n        }\n        // Cancel the open timer to give a full delay for opening.\n        this._cancelOpenTimer();\n        // Bail if the active item is not a valid submenu item.\n        let item = this.activeItem;\n        if (!item || item.type !== 'submenu' || !item.submenu) {\n            return;\n        }\n        // Start the open timer to open the active item submenu.\n        this._startOpenTimer();\n    }\n    /**\n     * Handle the `'mouseenter'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    _evtMouseEnter(event) {\n        // Synchronize the active ancestor items.\n        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {\n            menu._cancelOpenTimer();\n            menu._cancelCloseTimer();\n            menu.activeIndex = menu._childIndex;\n        }\n    }\n    /**\n     * Handle the `'mouseleave'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the menu node.\n     */\n    _evtMouseLeave(event) {\n        // Cancel any pending submenu opening.\n        this._cancelOpenTimer();\n        // If there is no open child menu, just reset the active index.\n        if (!this._childMenu) {\n            this.activeIndex = -1;\n            return;\n        }\n        // If the mouse is over the child menu, cancel the close timer.\n        let { clientX, clientY } = event;\n        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {\n            this._cancelCloseTimer();\n            return;\n        }\n        // Otherwise, reset the active index and start the close timer.\n        this.activeIndex = -1;\n        this._startCloseTimer();\n    }\n    /**\n     * Handle the `'mousedown'` event for the menu.\n     *\n     * #### Notes\n     * This listener is attached to the document node.\n     */\n    _evtMouseDown(event) {\n        // Bail if the menu is not a root menu.\n        if (this._parentMenu) {\n            return;\n        }\n        // The mouse button which is pressed is irrelevant. If the press\n        // is not on a menu, the entire hierarchy is closed and the event\n        // is allowed to propagate. This allows other code to act on the\n        // event, such as focusing the clicked element.\n        if (Private$9.hitTestMenus(this, event.clientX, event.clientY)) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else {\n            this.close();\n        }\n    }\n    /**\n     * Open the child menu at the active index immediately.\n     *\n     * If a different child menu is already open, it will be closed,\n     * even if the active item is not a valid submenu.\n     */\n    _openChildMenu(activateFirst = false) {\n        // If the item is not a valid submenu, close the child menu.\n        let item = this.activeItem;\n        if (!item || item.type !== 'submenu' || !item.submenu) {\n            this._closeChildMenu();\n            return;\n        }\n        // Do nothing if the child menu will not change.\n        let submenu = item.submenu;\n        if (submenu === this._childMenu) {\n            return;\n        }\n        // Prior to any DOM modifications save window data\n        Menu.saveWindowData();\n        // Ensure the current child menu is closed.\n        this._closeChildMenu();\n        // Update the private child state.\n        this._childMenu = submenu;\n        this._childIndex = this._activeIndex;\n        // Set the parent menu reference for the child.\n        submenu._parentMenu = this;\n        // Ensure the menu is updated and lookup the item node.\n        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n        let itemNode = this.contentNode.children[this._activeIndex];\n        // Open the submenu at the active node.\n        Private$9.openSubmenu(submenu, itemNode);\n        // Activate the first item if desired.\n        if (activateFirst) {\n            submenu.activeIndex = -1;\n            submenu.activateNextItem();\n        }\n        // Activate the child menu.\n        submenu.activate();\n    }\n    /**\n     * Close the child menu immediately.\n     *\n     * This is a no-op if a child menu is not open.\n     */\n    _closeChildMenu() {\n        if (this._childMenu) {\n            this._childMenu.close();\n        }\n    }\n    /**\n     * Start the open timer, unless it is already pending.\n     */\n    _startOpenTimer() {\n        if (this._openTimerID === 0) {\n            this._openTimerID = window.setTimeout(() => {\n                this._openTimerID = 0;\n                this._openChildMenu();\n            }, Private$9.TIMER_DELAY);\n        }\n    }\n    /**\n     * Start the close timer, unless it is already pending.\n     */\n    _startCloseTimer() {\n        if (this._closeTimerID === 0) {\n            this._closeTimerID = window.setTimeout(() => {\n                this._closeTimerID = 0;\n                this._closeChildMenu();\n            }, Private$9.TIMER_DELAY);\n        }\n    }\n    /**\n     * Cancel the open timer, if the timer is pending.\n     */\n    _cancelOpenTimer() {\n        if (this._openTimerID !== 0) {\n            clearTimeout(this._openTimerID);\n            this._openTimerID = 0;\n        }\n    }\n    /**\n     * Cancel the close timer, if the timer is pending.\n     */\n    _cancelCloseTimer() {\n        if (this._closeTimerID !== 0) {\n            clearTimeout(this._closeTimerID);\n            this._closeTimerID = 0;\n        }\n    }\n    /**\n     * Save window data used for menu positioning in transient cache.\n     *\n     * In order to avoid layout trashing it is recommended to invoke this\n     * method immediately prior to opening the menu and any DOM modifications\n     * (like closing previously visible menu, or adding a class to menu widget).\n     *\n     * The transient cache will be released upon `open()` call.\n     */\n    static saveWindowData() {\n        Private$9.saveWindowData();\n    }\n}\n/**\n * The namespace for the `Menu` class statics.\n */\n(function (Menu) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    class Renderer {\n        /**\n         * Render the virtual element for a menu item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        renderItem(data) {\n            let className = this.createItemClass(data);\n            let dataset = this.createItemDataset(data);\n            let aria = this.createItemARIA(data);\n            return h.li({\n                className,\n                dataset,\n                tabindex: '0',\n                onfocus: data.onfocus,\n                ...aria\n            }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));\n        }\n        /**\n         * Render the icon element for a menu item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the item icon.\n         */\n        renderIcon(data) {\n            let className = this.createIconClass(data);\n            // If data.item.icon is undefined, it will be ignored.\n            return h.div({ className }, data.item.icon, data.item.iconLabel);\n        }\n        /**\n         * Render the label element for a menu item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the item label.\n         */\n        renderLabel(data) {\n            let content = this.formatLabel(data);\n            return h.div({ className: 'lm-Menu-itemLabel' }, content);\n        }\n        /**\n         * Render the shortcut element for a menu item.\n         *\n         * @param data - The data to use for rendering the shortcut.\n         *\n         * @returns A virtual element representing the item shortcut.\n         */\n        renderShortcut(data) {\n            let content = this.formatShortcut(data);\n            return h.div({ className: 'lm-Menu-itemShortcut' }, content);\n        }\n        /**\n         * Render the submenu icon element for a menu item.\n         *\n         * @param data - The data to use for rendering the submenu icon.\n         *\n         * @returns A virtual element representing the submenu icon.\n         */\n        renderSubmenu(data) {\n            return h.div({ className: 'lm-Menu-itemSubmenuIcon' });\n        }\n        /**\n         * Create the class name for the menu item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the menu item.\n         */\n        createItemClass(data) {\n            // Setup the initial class name.\n            let name = 'lm-Menu-item';\n            // Add the boolean state classes.\n            if (!data.item.isEnabled) {\n                name += ' lm-mod-disabled';\n            }\n            if (data.item.isToggled) {\n                name += ' lm-mod-toggled';\n            }\n            if (!data.item.isVisible) {\n                name += ' lm-mod-hidden';\n            }\n            if (data.active) {\n                name += ' lm-mod-active';\n            }\n            if (data.collapsed) {\n                name += ' lm-mod-collapsed';\n            }\n            // Add the extra class.\n            let extra = data.item.className;\n            if (extra) {\n                name += ` ${extra}`;\n            }\n            // Return the complete class name.\n            return name;\n        }\n        /**\n         * Create the dataset for the menu item.\n         *\n         * @param data - The data to use for creating the dataset.\n         *\n         * @returns The dataset for the menu item.\n         */\n        createItemDataset(data) {\n            let result;\n            let { type, command, dataset } = data.item;\n            if (type === 'command') {\n                result = { ...dataset, type, command };\n            }\n            else {\n                result = { ...dataset, type };\n            }\n            return result;\n        }\n        /**\n         * Create the class name for the menu item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        createIconClass(data) {\n            let name = 'lm-Menu-itemIcon';\n            let extra = data.item.iconClass;\n            return extra ? `${name} ${extra}` : name;\n        }\n        /**\n         * Create the aria attributes for menu item.\n         *\n         * @param data - The data to use for the aria attributes.\n         *\n         * @returns The aria attributes object for the item.\n         */\n        createItemARIA(data) {\n            let aria = {};\n            switch (data.item.type) {\n                case 'separator':\n                    aria.role = 'presentation';\n                    break;\n                case 'submenu':\n                    aria['aria-haspopup'] = 'true';\n                    if (!data.item.isEnabled) {\n                        aria['aria-disabled'] = 'true';\n                    }\n                    break;\n                default:\n                    if (!data.item.isEnabled) {\n                        aria['aria-disabled'] = 'true';\n                    }\n                    aria.role = 'menuitem';\n            }\n            return aria;\n        }\n        /**\n         * Create the render content for the label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        formatLabel(data) {\n            // Fetch the label text and mnemonic index.\n            let { label, mnemonic } = data.item;\n            // If the index is out of range, do not modify the label.\n            if (mnemonic < 0 || mnemonic >= label.length) {\n                return label;\n            }\n            // Split the label into parts.\n            let prefix = label.slice(0, mnemonic);\n            let suffix = label.slice(mnemonic + 1);\n            let char = label[mnemonic];\n            // Wrap the mnemonic character in a span.\n            let span = h.span({ className: 'lm-Menu-itemMnemonic' }, char);\n            // Return the content parts.\n            return [prefix, span, suffix];\n        }\n        /**\n         * Create the render content for the shortcut node.\n         *\n         * @param data - The data to use for the shortcut content.\n         *\n         * @returns The content to add to the shortcut node.\n         */\n        formatShortcut(data) {\n            let kb = data.item.keyBinding;\n            return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;\n        }\n    }\n    Menu.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    Menu.defaultRenderer = new Renderer();\n})(Menu || (Menu = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$9;\n(function (Private) {\n    /**\n     * The ms delay for opening and closing a submenu.\n     */\n    Private.TIMER_DELAY = 300;\n    /**\n     * The horizontal pixel overlap for an open submenu.\n     */\n    Private.SUBMENU_OVERLAP = 3;\n    let transientWindowDataCache = null;\n    let transientCacheCounter = 0;\n    function getWindowData() {\n        // if transient cache is in use, take one from it\n        if (transientCacheCounter > 0) {\n            transientCacheCounter--;\n            return transientWindowDataCache;\n        }\n        return _getWindowData();\n    }\n    /**\n     * Store window data in transient cache.\n     *\n     * The transient cache will be released upon `getWindowData()` call.\n     * If this function is called multiple times, the cache will be\n     * retained until as many calls to `getWindowData()` were made.\n     *\n     * Note: should be called before any DOM modifications.\n     */\n    function saveWindowData() {\n        transientWindowDataCache = _getWindowData();\n        transientCacheCounter++;\n    }\n    Private.saveWindowData = saveWindowData;\n    /**\n     * Create the DOM node for a menu.\n     */\n    function createNode() {\n        let node = document.createElement('div');\n        let content = document.createElement('ul');\n        content.className = 'lm-Menu-content';\n        node.appendChild(content);\n        content.setAttribute('role', 'menu');\n        node.tabIndex = 0;\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Test whether a menu item can be activated.\n     */\n    function canActivate(item) {\n        return item.type !== 'separator' && item.isEnabled && item.isVisible;\n    }\n    Private.canActivate = canActivate;\n    /**\n     * Create a new menu item for an owner menu.\n     */\n    function createItem(owner, options) {\n        return new MenuItem(owner.commands, options);\n    }\n    Private.createItem = createItem;\n    /**\n     * Hit test a menu hierarchy starting at the given root.\n     */\n    function hitTestMenus(menu, x, y) {\n        for (let temp = menu; temp; temp = temp.childMenu) {\n            if (ElementExt.hitTest(temp.node, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Private.hitTestMenus = hitTestMenus;\n    /**\n     * Compute which extra separator items should be collapsed.\n     */\n    function computeCollapsed(items) {\n        // Allocate the return array and fill it with `false`.\n        let result = new Array(items.length);\n        ArrayExt.fill(result, false);\n        // Collapse the leading separators.\n        let k1 = 0;\n        let n = items.length;\n        for (; k1 < n; ++k1) {\n            let item = items[k1];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                break;\n            }\n            result[k1] = true;\n        }\n        // Hide the trailing separators.\n        let k2 = n - 1;\n        for (; k2 >= 0; --k2) {\n            let item = items[k2];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                break;\n            }\n            result[k2] = true;\n        }\n        // Hide the remaining consecutive separators.\n        let hide = false;\n        while (++k1 < k2) {\n            let item = items[k1];\n            if (!item.isVisible) {\n                continue;\n            }\n            if (item.type !== 'separator') {\n                hide = false;\n            }\n            else if (hide) {\n                result[k1] = true;\n            }\n            else {\n                hide = true;\n            }\n        }\n        // Return the resulting flags.\n        return result;\n    }\n    Private.computeCollapsed = computeCollapsed;\n    function _getWindowData() {\n        return {\n            pageXOffset: window.pageXOffset,\n            pageYOffset: window.pageYOffset,\n            clientWidth: document.documentElement.clientWidth,\n            clientHeight: document.documentElement.clientHeight\n        };\n    }\n    /**\n     * Open a menu as a root menu at the target location.\n     */\n    function openRootMenu(menu, x, y, forceX, forceY, host, ref) {\n        // Get the current position and size of the main viewport.\n        const windowData = getWindowData();\n        let px = windowData.pageXOffset;\n        let py = windowData.pageYOffset;\n        let cw = windowData.clientWidth;\n        let ch = windowData.clientHeight;\n        // Ensure the menu is updated before attaching and measuring.\n        MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);\n        // Compute the maximum allowed height for the menu.\n        let maxHeight = ch - (forceY ? y : 0);\n        // Fetch common variables.\n        let node = menu.node;\n        let style = node.style;\n        // Clear the menu geometry and prepare it for measuring.\n        style.opacity = '0';\n        style.maxHeight = `${maxHeight}px`;\n        // Attach the menu to the document.\n        Widget.attach(menu, host || document.body, ref);\n        // Measure the size of the menu.\n        let { width, height } = node.getBoundingClientRect();\n        // Adjust the X position of the menu to fit on-screen.\n        if (!forceX && x + width > px + cw) {\n            x = px + cw - width;\n        }\n        // Adjust the Y position of the menu to fit on-screen.\n        if (!forceY && y + height > py + ch) {\n            if (y > py + ch) {\n                y = py + ch - height;\n            }\n            else {\n                y = y - height;\n            }\n        }\n        // Update the position of the menu to the computed position.\n        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;\n        // Finally, make the menu visible on the screen.\n        style.opacity = '1';\n    }\n    Private.openRootMenu = openRootMenu;\n    /**\n     * Open a menu as a submenu using an item node for positioning.\n     */\n    function openSubmenu(submenu, itemNode) {\n        // Get the current position and size of the main viewport.\n        const windowData = getWindowData();\n        let px = windowData.pageXOffset;\n        let py = windowData.pageYOffset;\n        let cw = windowData.clientWidth;\n        let ch = windowData.clientHeight;\n        // Ensure the menu is updated before opening.\n        MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);\n        // Compute the maximum allowed height for the menu.\n        let maxHeight = ch;\n        // Fetch common variables.\n        let node = submenu.node;\n        let style = node.style;\n        // Clear the menu geometry and prepare it for measuring.\n        style.opacity = '0';\n        style.maxHeight = `${maxHeight}px`;\n        // Attach the menu to the document.\n        Widget.attach(submenu, document.body);\n        // Measure the size of the menu.\n        let { width, height } = node.getBoundingClientRect();\n        // Compute the box sizing for the menu.\n        let box = ElementExt.boxSizing(submenu.node);\n        // Get the bounding rect for the target item node.\n        let itemRect = itemNode.getBoundingClientRect();\n        // Compute the target X position.\n        let x = itemRect.right - Private.SUBMENU_OVERLAP;\n        // Adjust the X position to fit on the screen.\n        if (x + width > px + cw) {\n            x = itemRect.left + Private.SUBMENU_OVERLAP - width;\n        }\n        // Compute the target Y position.\n        let y = itemRect.top - box.borderTop - box.paddingTop;\n        // Adjust the Y position to fit on the screen.\n        if (y + height > py + ch) {\n            y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;\n        }\n        // Update the position of the menu to the computed position.\n        style.transform = `translate(${Math.max(0, x)}px, ${Math.max(0, y)}px`;\n        // Finally, make the menu visible on the screen.\n        style.opacity = '1';\n    }\n    Private.openSubmenu = openSubmenu;\n    /**\n     * Find the best matching mnemonic item.\n     *\n     * The search starts at the given index and wraps around.\n     */\n    function findMnemonic(items, key, start) {\n        // Setup the result variables.\n        let index = -1;\n        let auto = -1;\n        let multiple = false;\n        // Normalize the key to upper case.\n        let upperKey = key.toUpperCase();\n        // Search the items from the given start index.\n        for (let i = 0, n = items.length; i < n; ++i) {\n            // Compute the wrapped index.\n            let k = (i + start) % n;\n            // Lookup the item\n            let item = items[k];\n            // Ignore items which cannot be activated.\n            if (!canActivate(item)) {\n                continue;\n            }\n            // Ignore items with an empty label.\n            let label = item.label;\n            if (label.length === 0) {\n                continue;\n            }\n            // Lookup the mnemonic index for the label.\n            let mn = item.mnemonic;\n            // Handle a valid mnemonic index.\n            if (mn >= 0 && mn < label.length) {\n                if (label[mn].toUpperCase() === upperKey) {\n                    if (index === -1) {\n                        index = k;\n                    }\n                    else {\n                        multiple = true;\n                    }\n                }\n                continue;\n            }\n            // Finally, handle the auto index if possible.\n            if (auto === -1 && label[0].toUpperCase() === upperKey) {\n                auto = k;\n            }\n        }\n        // Return the search results.\n        return { index, multiple, auto };\n    }\n    Private.findMnemonic = findMnemonic;\n    /**\n     * A concrete implementation of `Menu.IItem`.\n     */\n    class MenuItem {\n        /**\n         * Construct a new menu item.\n         */\n        constructor(commands, options) {\n            this._commands = commands;\n            this.type = options.type || 'command';\n            this.command = options.command || '';\n            this.args = options.args || JSONExt.emptyObject;\n            this.submenu = options.submenu || null;\n        }\n        /**\n         * The display label for the menu item.\n         */\n        get label() {\n            if (this.type === 'command') {\n                return this._commands.label(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.label;\n            }\n            return '';\n        }\n        /**\n         * The mnemonic index for the menu item.\n         */\n        get mnemonic() {\n            if (this.type === 'command') {\n                return this._commands.mnemonic(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.mnemonic;\n            }\n            return -1;\n        }\n        /**\n         * The icon renderer for the menu item.\n         */\n        get icon() {\n            if (this.type === 'command') {\n                return this._commands.icon(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.icon;\n            }\n            return undefined;\n        }\n        /**\n         * The icon class for the menu item.\n         */\n        get iconClass() {\n            if (this.type === 'command') {\n                return this._commands.iconClass(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.iconClass;\n            }\n            return '';\n        }\n        /**\n         * The icon label for the menu item.\n         */\n        get iconLabel() {\n            if (this.type === 'command') {\n                return this._commands.iconLabel(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.iconLabel;\n            }\n            return '';\n        }\n        /**\n         * The display caption for the menu item.\n         */\n        get caption() {\n            if (this.type === 'command') {\n                return this._commands.caption(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.caption;\n            }\n            return '';\n        }\n        /**\n         * The extra class name for the menu item.\n         */\n        get className() {\n            if (this.type === 'command') {\n                return this._commands.className(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.className;\n            }\n            return '';\n        }\n        /**\n         * The dataset for the menu item.\n         */\n        get dataset() {\n            if (this.type === 'command') {\n                return this._commands.dataset(this.command, this.args);\n            }\n            if (this.type === 'submenu' && this.submenu) {\n                return this.submenu.title.dataset;\n            }\n            return {};\n        }\n        /**\n         * Whether the menu item is enabled.\n         */\n        get isEnabled() {\n            if (this.type === 'command') {\n                return this._commands.isEnabled(this.command, this.args);\n            }\n            if (this.type === 'submenu') {\n                return this.submenu !== null;\n            }\n            return true;\n        }\n        /**\n         * Whether the menu item is toggled.\n         */\n        get isToggled() {\n            if (this.type === 'command') {\n                return this._commands.isToggled(this.command, this.args);\n            }\n            return false;\n        }\n        /**\n         * Whether the menu item is visible.\n         */\n        get isVisible() {\n            if (this.type === 'command') {\n                return this._commands.isVisible(this.command, this.args);\n            }\n            if (this.type === 'submenu') {\n                return this.submenu !== null;\n            }\n            return true;\n        }\n        /**\n         * The key binding for the menu item.\n         */\n        get keyBinding() {\n            if (this.type === 'command') {\n                let { command, args } = this;\n                return (ArrayExt.findLastValue(this._commands.keyBindings, kb => {\n                    return kb.command === command && JSONExt.deepEqual(kb.args, args);\n                }) || null);\n            }\n            return null;\n        }\n    }\n})(Private$9 || (Private$9 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * An object which implements a universal context menu.\n *\n * #### Notes\n * The items shown in the context menu are determined by CSS selector\n * matching against the DOM hierarchy at the site of the mouse click.\n * This is similar in concept to how keyboard shortcuts are matched\n * in the command registry.\n */\nclass ContextMenu {\n    /**\n     * Construct a new context menu.\n     *\n     * @param options - The options for initializing the menu.\n     */\n    constructor(options) {\n        this._groupByTarget = true;\n        this._idTick = 0;\n        this._items = [];\n        this._sortBySelector = true;\n        const { groupByTarget, sortBySelector, ...others } = options;\n        this.menu = new Menu(others);\n        this._groupByTarget = groupByTarget !== false;\n        this._sortBySelector = sortBySelector !== false;\n    }\n    /**\n     * Add an item to the context menu.\n     *\n     * @param options - The options for creating the item.\n     *\n     * @returns A disposable which will remove the item from the menu.\n     */\n    addItem(options) {\n        // Create an item from the given options.\n        let item = Private$8.createItem(options, this._idTick++);\n        // Add the item to the internal array.\n        this._items.push(item);\n        // Return a disposable which will remove the item.\n        return new DisposableDelegate(() => {\n            ArrayExt.removeFirstOf(this._items, item);\n        });\n    }\n    /**\n     * Open the context menu in response to a `'contextmenu'` event.\n     *\n     * @param event - The `'contextmenu'` event of interest.\n     *\n     * @returns `true` if the menu was opened, or `false` if no items\n     *   matched the event and the menu was not opened.\n     *\n     * #### Notes\n     * This method will populate the context menu with items which match\n     * the propagation path of the event, then open the menu at the mouse\n     * position indicated by the event.\n     */\n    open(event) {\n        // Prior to any DOM modifications update the window data.\n        Menu.saveWindowData();\n        // Clear the current contents of the context menu.\n        this.menu.clearItems();\n        // Bail early if there are no items to match.\n        if (this._items.length === 0) {\n            return false;\n        }\n        // Find the matching items for the event.\n        let items = Private$8.matchItems(this._items, event, this._groupByTarget, this._sortBySelector);\n        // Bail if there are no matching items.\n        if (!items || items.length === 0) {\n            return false;\n        }\n        // Add the filtered items to the menu.\n        for (const item of items) {\n            this.menu.addItem(item);\n        }\n        // Open the context menu at the current mouse position.\n        this.menu.open(event.clientX, event.clientY);\n        // Indicate success.\n        return true;\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$8;\n(function (Private) {\n    /**\n     * Create a normalized context menu item from an options object.\n     */\n    function createItem(options, id) {\n        let selector = validateSelector(options.selector);\n        let rank = options.rank !== undefined ? options.rank : Infinity;\n        return { ...options, selector, rank, id };\n    }\n    Private.createItem = createItem;\n    /**\n     * Find the items which match a context menu event.\n     *\n     * The results are sorted by DOM level, specificity, and rank.\n     */\n    function matchItems(items, event, groupByTarget, sortBySelector) {\n        // Look up the target of the event.\n        let target = event.target;\n        // Bail if there is no target.\n        if (!target) {\n            return null;\n        }\n        // Look up the current target of the event.\n        let currentTarget = event.currentTarget;\n        // Bail if there is no current target.\n        if (!currentTarget) {\n            return null;\n        }\n        // There are some third party libraries that cause the `target` to\n        // be detached from the DOM before lumino can process the event.\n        // If that happens, search for a new target node by point. If that\n        // node is still dangling, bail.\n        if (!currentTarget.contains(target)) {\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            if (!target || !currentTarget.contains(target)) {\n                return null;\n            }\n        }\n        // Set up the result array.\n        let result = [];\n        // Copy the items array to allow in-place modification.\n        let availableItems = items.slice();\n        // Walk up the DOM hierarchy searching for matches.\n        while (target !== null) {\n            // Set up the match array for this DOM level.\n            let matches = [];\n            // Search the remaining items for matches.\n            for (let i = 0, n = availableItems.length; i < n; ++i) {\n                // Fetch the item.\n                let item = availableItems[i];\n                // Skip items which are already consumed.\n                if (!item) {\n                    continue;\n                }\n                // Skip items which do not match the element.\n                if (!Selector.matches(target, item.selector)) {\n                    continue;\n                }\n                // Add the matched item to the result for this DOM level.\n                matches.push(item);\n                // Mark the item as consumed.\n                availableItems[i] = null;\n            }\n            // Sort the matches for this level and add them to the results.\n            if (matches.length !== 0) {\n                if (groupByTarget) {\n                    matches.sort(sortBySelector ? itemCmp : itemCmpRank);\n                }\n                result.push(...matches);\n            }\n            // Stop searching at the limits of the DOM range.\n            if (target === currentTarget) {\n                break;\n            }\n            // Step to the parent DOM level.\n            target = target.parentElement;\n        }\n        if (!groupByTarget) {\n            result.sort(sortBySelector ? itemCmp : itemCmpRank);\n        }\n        // Return the matched and sorted results.\n        return result;\n    }\n    Private.matchItems = matchItems;\n    /**\n     * Validate the selector for a menu item.\n     *\n     * This returns the validated selector, or throws if the selector is\n     * invalid or contains commas.\n     */\n    function validateSelector(selector) {\n        if (selector.indexOf(',') !== -1) {\n            throw new Error(`Selector cannot contain commas: ${selector}`);\n        }\n        if (!Selector.isValid(selector)) {\n            throw new Error(`Invalid selector: ${selector}`);\n        }\n        return selector;\n    }\n    /**\n     * A sort comparison function for a context menu item by ranks.\n     */\n    function itemCmpRank(a, b) {\n        // Sort based on rank.\n        let r1 = a.rank;\n        let r2 = b.rank;\n        if (r1 !== r2) {\n            return r1 < r2 ? -1 : 1; // Infinity-safe\n        }\n        // When all else fails, sort by item id.\n        return a.id - b.id;\n    }\n    /**\n     * A sort comparison function for a context menu item by selectors and ranks.\n     */\n    function itemCmp(a, b) {\n        // Sort first based on selector specificity.\n        let s1 = Selector.calculateSpecificity(a.selector);\n        let s2 = Selector.calculateSpecificity(b.selector);\n        if (s1 !== s2) {\n            return s2 - s1;\n        }\n        // If specificities are equal\n        return itemCmpRank(a, b);\n    }\n})(Private$8 || (Private$8 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nconst ARROW_KEYS = [\n    'ArrowLeft',\n    'ArrowUp',\n    'ArrowRight',\n    'ArrowDown',\n    'Home',\n    'End'\n];\n/**\n * A widget which displays titles as a single row or column of tabs.\n *\n * #### Notes\n * If CSS transforms are used to rotate nodes for vertically oriented\n * text, then tab dragging will not work correctly. The `tabsMovable`\n * property should be set to `false` when rotating nodes from CSS.\n */\nclass TabBar extends Widget {\n    /**\n     * Construct a new tab bar.\n     *\n     * @param options - The options for initializing the tab bar.\n     */\n    constructor(options = {}) {\n        super({ node: Private$7.createNode() });\n        this._currentIndex = -1;\n        this._titles = [];\n        this._titlesEditable = false;\n        this._previousTitle = null;\n        this._dragData = null;\n        this._addButtonEnabled = false;\n        this._tabMoved = new Signal(this);\n        this._currentChanged = new Signal(this);\n        this._addRequested = new Signal(this);\n        this._tabCloseRequested = new Signal(this);\n        this._tabDetachRequested = new Signal(this);\n        this._tabActivateRequested = new Signal(this);\n        this.addClass('lm-TabBar');\n        this.contentNode.setAttribute('role', 'tablist');\n        this.setFlag(Widget.Flag.DisallowLayout);\n        this._document = options.document || document;\n        this.tabsMovable = options.tabsMovable || false;\n        this.titlesEditable = options.titlesEditable || false;\n        this.allowDeselect = options.allowDeselect || false;\n        this.addButtonEnabled = options.addButtonEnabled || false;\n        this.insertBehavior = options.insertBehavior || 'select-tab-if-needed';\n        this.name = options.name || '';\n        this.orientation = options.orientation || 'horizontal';\n        this.removeBehavior = options.removeBehavior || 'select-tab-after';\n        this.renderer = options.renderer || TabBar.defaultRenderer;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        this._releaseMouse();\n        this._titles.length = 0;\n        this._previousTitle = null;\n        super.dispose();\n    }\n    /**\n     * A signal emitted when the current tab is changed.\n     *\n     * #### Notes\n     * This signal is emitted when the currently selected tab is changed\n     * either through user or programmatic interaction.\n     *\n     * Notably, this signal is not emitted when the index of the current\n     * tab changes due to tabs being inserted, removed, or moved. It is\n     * only emitted when the actual current tab node is changed.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * A signal emitted when a tab is moved by the user.\n     *\n     * #### Notes\n     * This signal is emitted when a tab is moved by user interaction.\n     *\n     * This signal is not emitted when a tab is moved programmatically.\n     */\n    get tabMoved() {\n        return this._tabMoved;\n    }\n    /**\n     * A signal emitted when a tab is clicked by the user.\n     *\n     * #### Notes\n     * If the clicked tab is not the current tab, the clicked tab will be\n     * made current and the `currentChanged` signal will be emitted first.\n     *\n     * This signal is emitted even if the clicked tab is the current tab.\n     */\n    get tabActivateRequested() {\n        return this._tabActivateRequested;\n    }\n    /**\n     * A signal emitted when the tab bar add button is clicked.\n     */\n    get addRequested() {\n        return this._addRequested;\n    }\n    /**\n     * A signal emitted when a tab close icon is clicked.\n     *\n     * #### Notes\n     * This signal is not emitted unless the tab title is `closable`.\n     */\n    get tabCloseRequested() {\n        return this._tabCloseRequested;\n    }\n    /**\n     * A signal emitted when a tab is dragged beyond the detach threshold.\n     *\n     * #### Notes\n     * This signal is emitted when the user drags a tab with the mouse,\n     * and mouse is dragged beyond the detach threshold.\n     *\n     * The consumer of the signal should call `releaseMouse` and remove\n     * the tab in order to complete the detach.\n     *\n     * This signal is only emitted once per drag cycle.\n     */\n    get tabDetachRequested() {\n        return this._tabDetachRequested;\n    }\n    /**\n     * The document to use with the tab bar.\n     *\n     * The default is the global `document` instance.\n     */\n    get document() {\n        return this._document;\n    }\n    /**\n     * Whether the titles can be user-edited.\n     *\n     */\n    get titlesEditable() {\n        return this._titlesEditable;\n    }\n    /**\n     * Set whether titles can be user edited.\n     *\n     */\n    set titlesEditable(value) {\n        this._titlesEditable = value;\n    }\n    /**\n     * Get the currently selected title.\n     *\n     * #### Notes\n     * This will be `null` if no tab is selected.\n     */\n    get currentTitle() {\n        return this._titles[this._currentIndex] || null;\n    }\n    /**\n     * Set the currently selected title.\n     *\n     * #### Notes\n     * If the title does not exist, the title will be set to `null`.\n     */\n    set currentTitle(value) {\n        this.currentIndex = value ? this._titles.indexOf(value) : -1;\n    }\n    /**\n     * Get the index of the currently selected tab.\n     *\n     * #### Notes\n     * This will be `-1` if no tab is selected.\n     */\n    get currentIndex() {\n        return this._currentIndex;\n    }\n    /**\n     * Set the index of the currently selected tab.\n     *\n     * #### Notes\n     * If the value is out of range, the index will be set to `-1`.\n     */\n    set currentIndex(value) {\n        // Adjust for an out of range index.\n        if (value < 0 || value >= this._titles.length) {\n            value = -1;\n        }\n        // Bail early if the index will not change.\n        if (this._currentIndex === value) {\n            return;\n        }\n        // Look up the previous index and title.\n        let pi = this._currentIndex;\n        let pt = this._titles[pi] || null;\n        // Look up the current index and title.\n        let ci = value;\n        let ct = this._titles[ci] || null;\n        // Update the current index and previous title.\n        this._currentIndex = ci;\n        this._previousTitle = pt;\n        // Schedule an update of the tabs.\n        this.update();\n        // Emit the current changed signal.\n        this._currentChanged.emit({\n            previousIndex: pi,\n            previousTitle: pt,\n            currentIndex: ci,\n            currentTitle: ct\n        });\n    }\n    /**\n     * Get the name of the tab bar.\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Set the name of the tab bar.\n     */\n    set name(value) {\n        this._name = value;\n        if (value) {\n            this.contentNode.setAttribute('aria-label', value);\n        }\n        else {\n            this.contentNode.removeAttribute('aria-label');\n        }\n    }\n    /**\n     * Get the orientation of the tab bar.\n     *\n     * #### Notes\n     * This controls whether the tabs are arranged in a row or column.\n     */\n    get orientation() {\n        return this._orientation;\n    }\n    /**\n     * Set the orientation of the tab bar.\n     *\n     * #### Notes\n     * This controls whether the tabs are arranged in a row or column.\n     */\n    set orientation(value) {\n        // Do nothing if the orientation does not change.\n        if (this._orientation === value) {\n            return;\n        }\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Toggle the orientation values.\n        this._orientation = value;\n        this.dataset['orientation'] = value;\n        this.contentNode.setAttribute('aria-orientation', value);\n    }\n    /**\n     * Whether the add button is enabled.\n     */\n    get addButtonEnabled() {\n        return this._addButtonEnabled;\n    }\n    /**\n     * Set whether the add button is enabled.\n     */\n    set addButtonEnabled(value) {\n        // Do nothing if the value does not change.\n        if (this._addButtonEnabled === value) {\n            return;\n        }\n        this._addButtonEnabled = value;\n        if (value) {\n            this.addButtonNode.classList.remove('lm-mod-hidden');\n        }\n        else {\n            this.addButtonNode.classList.add('lm-mod-hidden');\n        }\n    }\n    /**\n     * A read-only array of the titles in the tab bar.\n     */\n    get titles() {\n        return this._titles;\n    }\n    /**\n     * The tab bar content node.\n     *\n     * #### Notes\n     * This is the node which holds the tab nodes.\n     *\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get contentNode() {\n        return this.node.getElementsByClassName('lm-TabBar-content')[0];\n    }\n    /**\n     * The tab bar add button node.\n     *\n     * #### Notes\n     * This is the node which holds the add button.\n     *\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get addButtonNode() {\n        return this.node.getElementsByClassName('lm-TabBar-addButton')[0];\n    }\n    /**\n     * Add a tab to the end of the tab bar.\n     *\n     * @param value - The title which holds the data for the tab,\n     *   or an options object to convert to a title.\n     *\n     * @returns The title object added to the tab bar.\n     *\n     * #### Notes\n     * If the title is already added to the tab bar, it will be moved.\n     */\n    addTab(value) {\n        return this.insertTab(this._titles.length, value);\n    }\n    /**\n     * Insert a tab into the tab bar at the specified index.\n     *\n     * @param index - The index at which to insert the tab.\n     *\n     * @param value - The title which holds the data for the tab,\n     *   or an options object to convert to a title.\n     *\n     * @returns The title object added to the tab bar.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the tabs.\n     *\n     * If the title is already added to the tab bar, it will be moved.\n     */\n    insertTab(index, value) {\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Coerce the value to a title.\n        let title = Private$7.asTitle(value);\n        // Look up the index of the title.\n        let i = this._titles.indexOf(title);\n        // Clamp the insert index to the array bounds.\n        let j = Math.max(0, Math.min(index, this._titles.length));\n        // If the title is not in the array, insert it.\n        if (i === -1) {\n            // Insert the title into the array.\n            ArrayExt.insert(this._titles, j, title);\n            // Connect to the title changed signal.\n            title.changed.connect(this._onTitleChanged, this);\n            // Schedule an update of the tabs.\n            this.update();\n            // Adjust the current index for the insert.\n            this._adjustCurrentForInsert(j, title);\n            // Return the title added to the tab bar.\n            return title;\n        }\n        // Otherwise, the title exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._titles.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return title;\n        }\n        // Move the title to the new location.\n        ArrayExt.move(this._titles, i, j);\n        // Schedule an update of the tabs.\n        this.update();\n        // Adjust the current index for the move.\n        this._adjustCurrentForMove(i, j);\n        // Return the title added to the tab bar.\n        return title;\n    }\n    /**\n     * Remove a tab from the tab bar.\n     *\n     * @param title - The title for the tab to remove.\n     *\n     * #### Notes\n     * This is a no-op if the title is not in the tab bar.\n     */\n    removeTab(title) {\n        this.removeTabAt(this._titles.indexOf(title));\n    }\n    /**\n     * Remove the tab at a given index from the tab bar.\n     *\n     * @param index - The index of the tab to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    removeTabAt(index) {\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Remove the title from the array.\n        let title = ArrayExt.removeAt(this._titles, index);\n        // Bail if the index is out of range.\n        if (!title) {\n            return;\n        }\n        // Disconnect from the title changed signal.\n        title.changed.disconnect(this._onTitleChanged, this);\n        // Clear the previous title if it's being removed.\n        if (title === this._previousTitle) {\n            this._previousTitle = null;\n        }\n        // Schedule an update of the tabs.\n        this.update();\n        // Adjust the current index for the remove.\n        this._adjustCurrentForRemove(index, title);\n    }\n    /**\n     * Remove all tabs from the tab bar.\n     */\n    clearTabs() {\n        // Bail if there is nothing to remove.\n        if (this._titles.length === 0) {\n            return;\n        }\n        // Release the mouse before making any changes.\n        this._releaseMouse();\n        // Disconnect from the title changed signals.\n        for (let title of this._titles) {\n            title.changed.disconnect(this._onTitleChanged, this);\n        }\n        // Get the current index and title.\n        let pi = this.currentIndex;\n        let pt = this.currentTitle;\n        // Reset the current index and previous title.\n        this._currentIndex = -1;\n        this._previousTitle = null;\n        // Clear the title array.\n        this._titles.length = 0;\n        // Schedule an update of the tabs.\n        this.update();\n        // If no tab was selected, there's nothing else to do.\n        if (pi === -1) {\n            return;\n        }\n        // Emit the current changed signal.\n        this._currentChanged.emit({\n            previousIndex: pi,\n            previousTitle: pt,\n            currentIndex: -1,\n            currentTitle: null\n        });\n    }\n    /**\n     * Release the mouse and restore the non-dragged tab positions.\n     *\n     * #### Notes\n     * This will cause the tab bar to stop handling mouse events and to\n     * restore the tabs to their non-dragged positions.\n     */\n    releaseMouse() {\n        this._releaseMouse();\n    }\n    /**\n     * Handle the DOM events for the tab bar.\n     *\n     * @param event - The DOM event sent to the tab bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the tab bar's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'pointerdown':\n                this._evtPointerDown(event);\n                break;\n            case 'pointermove':\n                this._evtPointerMove(event);\n                break;\n            case 'pointerup':\n                this._evtPointerUp(event);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'keydown':\n                event.eventPhase === Event.CAPTURING_PHASE\n                    ? this._evtKeyDownCapturing(event)\n                    : this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('pointerdown', this);\n        this.node.addEventListener('dblclick', this);\n        this.node.addEventListener('keydown', this);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('pointerdown', this);\n        this.node.removeEventListener('dblclick', this);\n        this.node.removeEventListener('keydown', this);\n        this._releaseMouse();\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        var _a;\n        let titles = this._titles;\n        let renderer = this.renderer;\n        let currentTitle = this.currentTitle;\n        let content = new Array(titles.length);\n        // Keep the tabindex=\"0\" attribute to the tab which handled it before the update.\n        // If the add button handles it, no need to do anything. If no element of the tab\n        // bar handles it, set it on the current or the first tab to ensure one element\n        // handles it after update.\n        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : (this._currentIndex > -1 ? this._currentIndex : 0);\n        for (let i = 0, n = titles.length; i < n; ++i) {\n            let title = titles[i];\n            let current = title === currentTitle;\n            let zIndex = current ? n : n - i - 1;\n            let tabIndex = tabHandlingTabindex === i ? 0 : -1;\n            content[i] = renderer.renderTab({ title, current, zIndex, tabIndex });\n        }\n        VirtualDOM.render(content, this.contentNode);\n    }\n    /**\n     * Get the index of the tab which handles tabindex=\"0\".\n     * If the add button handles tabindex=\"0\", -1 is returned.\n     * If none of the previous handles tabindex=\"0\", null is returned.\n     */\n    _getCurrentTabindex() {\n        let index = null;\n        const elemTabindex = this.contentNode.querySelector('li[tabindex=\"0\"]');\n        if (elemTabindex) {\n            index = [...this.contentNode.children].indexOf(elemTabindex);\n        }\n        else if (this._addButtonEnabled &&\n            this.addButtonNode.getAttribute('tabindex') === '0') {\n            index = -1;\n        }\n        return index;\n    }\n    /**\n     * Handle the `'dblclick'` event for the tab bar.\n     */\n    _evtDblClick(event) {\n        // Do nothing if titles are not editable\n        if (!this.titlesEditable) {\n            return;\n        }\n        let tabs = this.contentNode.children;\n        // Find the index of the targeted tab.\n        let index = ArrayExt.findFirstIndex(tabs, tab => {\n            return ElementExt.hitTest(tab, event.clientX, event.clientY);\n        });\n        // Do nothing if the press is not on a tab.\n        if (index === -1) {\n            return;\n        }\n        let title = this.titles[index];\n        let label = tabs[index].querySelector('.lm-TabBar-tabLabel');\n        if (label && label.contains(event.target)) {\n            let value = title.label || '';\n            // Clear the label element\n            let oldValue = label.innerHTML;\n            label.innerHTML = '';\n            let input = document.createElement('input');\n            input.classList.add('lm-TabBar-tabInput');\n            input.value = value;\n            label.appendChild(input);\n            let onblur = () => {\n                input.removeEventListener('blur', onblur);\n                label.innerHTML = oldValue;\n                this.node.addEventListener('keydown', this);\n            };\n            input.addEventListener('dblclick', (event) => event.stopPropagation());\n            input.addEventListener('blur', onblur);\n            input.addEventListener('keydown', (event) => {\n                if (event.key === 'Enter') {\n                    if (input.value !== '') {\n                        title.label = title.caption = input.value;\n                    }\n                    onblur();\n                }\n                else if (event.key === 'Escape') {\n                    onblur();\n                }\n            });\n            this.node.removeEventListener('keydown', this);\n            input.select();\n            input.focus();\n            if (label.children.length > 0) {\n                label.children[0].focus();\n            }\n        }\n    }\n    /**\n     * Handle the `'keydown'` event for the tab bar at capturing phase.\n     */\n    _evtKeyDownCapturing(event) {\n        if (event.eventPhase !== Event.CAPTURING_PHASE) {\n            return;\n        }\n        // Stop all input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse if `Escape` is pressed.\n        if (event.key === 'Escape') {\n            this._releaseMouse();\n        }\n    }\n    /**\n     * Handle the `'keydown'` event for the tab bar at target phase.\n     */\n    _evtKeyDown(event) {\n        var _a, _b, _c;\n        // Allow for navigation using tab key\n        if (event.key === 'Tab' || event.eventPhase === Event.CAPTURING_PHASE) {\n            return;\n        }\n        // Check if Enter or Spacebar key has been pressed and open that tab\n        if (event.key === 'Enter' ||\n            event.key === 'Spacebar' ||\n            event.key === ' ') {\n            // Get focus element that is in focus by the tab key\n            const focusedElement = document.activeElement;\n            // Test first if the focus is on the add button node\n            if (this.addButtonEnabled &&\n                this.addButtonNode.contains(focusedElement)) {\n                event.preventDefault();\n                event.stopPropagation();\n                this._addRequested.emit();\n            }\n            else {\n                const index = ArrayExt.findFirstIndex(this.contentNode.children, tab => tab.contains(focusedElement));\n                if (index >= 0) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this.currentIndex = index;\n                }\n            }\n            // Handle the arrow keys to switch tabs.\n        }\n        else if (ARROW_KEYS.includes(event.key)) {\n            // Create a list of all focusable elements in the tab bar.\n            const focusable = [...this.contentNode.children];\n            if (this.addButtonEnabled) {\n                focusable.push(this.addButtonNode);\n            }\n            // If the tab bar contains only one element, nothing to do.\n            if (focusable.length <= 1) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            // Get the current focused element.\n            let focusedIndex = focusable.indexOf(document.activeElement);\n            if (focusedIndex === -1) {\n                focusedIndex = this._currentIndex;\n            }\n            // Find the next element to focus on.\n            let nextFocused;\n            if ((event.key === 'ArrowRight' && this._orientation === 'horizontal') ||\n                (event.key === 'ArrowDown' && this._orientation === 'vertical')) {\n                nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];\n            }\n            else if ((event.key === 'ArrowLeft' && this._orientation === 'horizontal') ||\n                (event.key === 'ArrowUp' && this._orientation === 'vertical')) {\n                nextFocused =\n                    (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];\n            }\n            else if (event.key === 'Home') {\n                nextFocused = focusable[0];\n            }\n            else if (event.key === 'End') {\n                nextFocused = focusable[focusable.length - 1];\n            }\n            // Change the focused element and the tabindex value.\n            if (nextFocused) {\n                (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute('tabindex', '-1');\n                nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute('tabindex', '0');\n                nextFocused.focus();\n            }\n        }\n    }\n    /**\n     * Handle the `'pointerdown'` event for the tab bar.\n     */\n    _evtPointerDown(event) {\n        // Do nothing if it's not a left or middle mouse press.\n        if (event.button !== 0 && event.button !== 1) {\n            return;\n        }\n        // Do nothing if a drag is in progress.\n        if (this._dragData) {\n            return;\n        }\n        // Do nothing if a title editable input was clicked.\n        if (event.target.classList.contains('lm-TabBar-tabInput')) {\n            return;\n        }\n        // Check if the add button was clicked.\n        let addButtonClicked = this.addButtonEnabled &&\n            this.addButtonNode.contains(event.target);\n        // Lookup the tab nodes.\n        let tabs = this.contentNode.children;\n        // Find the index of the pressed tab.\n        let index = ArrayExt.findFirstIndex(tabs, tab => {\n            return ElementExt.hitTest(tab, event.clientX, event.clientY);\n        });\n        // Do nothing if the press is not on a tab or the add button.\n        if (index === -1 && !addButtonClicked) {\n            return;\n        }\n        // Pressing on a tab stops the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Initialize the non-measured parts of the drag data.\n        this._dragData = {\n            tab: tabs[index],\n            index: index,\n            pressX: event.clientX,\n            pressY: event.clientY,\n            tabPos: -1,\n            tabSize: -1,\n            tabPressPos: -1,\n            targetIndex: -1,\n            tabLayout: null,\n            contentRect: null,\n            override: null,\n            dragActive: false,\n            dragAborted: false,\n            detachRequested: false\n        };\n        // Add the document pointer up listener.\n        this.document.addEventListener('pointerup', this, true);\n        // Do nothing else if the middle button or add button is clicked.\n        if (event.button === 1 || addButtonClicked) {\n            return;\n        }\n        // Do nothing else if the close icon is clicked.\n        let icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n        if (icon && icon.contains(event.target)) {\n            return;\n        }\n        // Add the extra listeners if the tabs are movable.\n        if (this.tabsMovable) {\n            this.document.addEventListener('pointermove', this, true);\n            this.document.addEventListener('keydown', this, true);\n            this.document.addEventListener('contextmenu', this, true);\n        }\n        // Update the current index as appropriate.\n        if (this.allowDeselect && this.currentIndex === index) {\n            this.currentIndex = -1;\n        }\n        else {\n            this.currentIndex = index;\n        }\n        // Do nothing else if there is no current tab.\n        if (this.currentIndex === -1) {\n            return;\n        }\n        // Emit the tab activate request signal.\n        this._tabActivateRequested.emit({\n            index: this.currentIndex,\n            title: this.currentTitle\n        });\n    }\n    /**\n     * Handle the `'pointermove'` event for the tab bar.\n     */\n    _evtPointerMove(event) {\n        // Do nothing if no drag is in progress.\n        let data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Suppress the event during a drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Lookup the tab nodes.\n        let tabs = this.contentNode.children;\n        // Bail early if the drag threshold has not been met.\n        if (!data.dragActive && !Private$7.dragExceeded(data, event)) {\n            return;\n        }\n        // Activate the drag if necessary.\n        if (!data.dragActive) {\n            // Fill in the rest of the drag data measurements.\n            let tabRect = data.tab.getBoundingClientRect();\n            if (this._orientation === 'horizontal') {\n                data.tabPos = data.tab.offsetLeft;\n                data.tabSize = tabRect.width;\n                data.tabPressPos = data.pressX - tabRect.left;\n            }\n            else {\n                data.tabPos = data.tab.offsetTop;\n                data.tabSize = tabRect.height;\n                data.tabPressPos = data.pressY - tabRect.top;\n            }\n            data.tabPressOffset = {\n                x: data.pressX - tabRect.left,\n                y: data.pressY - tabRect.top\n            };\n            data.tabLayout = Private$7.snapTabLayout(tabs, this._orientation);\n            data.contentRect = this.contentNode.getBoundingClientRect();\n            data.override = Drag.overrideCursor('default');\n            // Add the dragging style classes.\n            data.tab.classList.add('lm-mod-dragging');\n            this.addClass('lm-mod-dragging');\n            // Mark the drag as active.\n            data.dragActive = true;\n        }\n        // Emit the detach requested signal if the threshold is exceeded.\n        if (!data.detachRequested && Private$7.detachExceeded(data, event)) {\n            // Only emit the signal once per drag cycle.\n            data.detachRequested = true;\n            // Setup the arguments for the signal.\n            let index = data.index;\n            let clientX = event.clientX;\n            let clientY = event.clientY;\n            let tab = tabs[index];\n            let title = this._titles[index];\n            // Emit the tab detach requested signal.\n            this._tabDetachRequested.emit({\n                index,\n                title,\n                tab,\n                clientX,\n                clientY,\n                offset: data.tabPressOffset\n            });\n            // Bail if the signal handler aborted the drag.\n            if (data.dragAborted) {\n                return;\n            }\n        }\n        // Update the positions of the tabs.\n        Private$7.layoutTabs(tabs, data, event, this._orientation);\n    }\n    /**\n     * Handle the `'pointerup'` event for the document.\n     */\n    _evtPointerUp(event) {\n        // Do nothing if it's not a left or middle mouse release.\n        if (event.button !== 0 && event.button !== 1) {\n            return;\n        }\n        // Do nothing if no drag is in progress.\n        const data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the extra mouse event listeners.\n        this.document.removeEventListener('pointermove', this, true);\n        this.document.removeEventListener('pointerup', this, true);\n        this.document.removeEventListener('keydown', this, true);\n        this.document.removeEventListener('contextmenu', this, true);\n        // Handle a release when the drag is not active.\n        if (!data.dragActive) {\n            // Clear the drag data.\n            this._dragData = null;\n            // Handle clicking the add button.\n            let addButtonClicked = this.addButtonEnabled &&\n                this.addButtonNode.contains(event.target);\n            if (addButtonClicked) {\n                this._addRequested.emit(undefined);\n                return;\n            }\n            // Lookup the tab nodes.\n            let tabs = this.contentNode.children;\n            // Find the index of the released tab.\n            let index = ArrayExt.findFirstIndex(tabs, tab => {\n                return ElementExt.hitTest(tab, event.clientX, event.clientY);\n            });\n            // Do nothing if the release is not on the original pressed tab.\n            if (index !== data.index) {\n                return;\n            }\n            // Ignore the release if the title is not closable.\n            let title = this._titles[index];\n            if (!title.closable) {\n                return;\n            }\n            // Emit the close requested signal if the middle button is released.\n            if (event.button === 1) {\n                this._tabCloseRequested.emit({ index, title });\n                return;\n            }\n            // Emit the close requested signal if the close icon was released.\n            let icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n            if (icon && icon.contains(event.target)) {\n                this._tabCloseRequested.emit({ index, title });\n                return;\n            }\n            // Otherwise, there is nothing left to do.\n            return;\n        }\n        // Do nothing if the left button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Position the tab at its final resting position.\n        Private$7.finalizeTabPosition(data, this._orientation);\n        // Remove the dragging class from the tab so it can be transitioned.\n        data.tab.classList.remove('lm-mod-dragging');\n        // Parse the transition duration for releasing the tab.\n        let duration = Private$7.parseTransitionDuration(data.tab);\n        // Complete the release on a timer to allow the tab to transition.\n        setTimeout(() => {\n            // Do nothing if the drag has been aborted.\n            if (data.dragAborted) {\n                return;\n            }\n            // Clear the drag data reference.\n            this._dragData = null;\n            // Reset the positions of the tabs.\n            Private$7.resetTabPositions(this.contentNode.children, this._orientation);\n            // Clear the cursor grab.\n            data.override.dispose();\n            // Remove the remaining dragging style.\n            this.removeClass('lm-mod-dragging');\n            // If the tab was not moved, there is nothing else to do.\n            let i = data.index;\n            let j = data.targetIndex;\n            if (j === -1 || i === j) {\n                return;\n            }\n            // Move the title to the new locations.\n            ArrayExt.move(this._titles, i, j);\n            // Adjust the current index for the move.\n            this._adjustCurrentForMove(i, j);\n            // Emit the tab moved signal.\n            this._tabMoved.emit({\n                fromIndex: i,\n                toIndex: j,\n                title: this._titles[j]\n            });\n            // Update the tabs immediately to prevent flicker.\n            MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n        }, duration);\n    }\n    /**\n     * Release the mouse and restore the non-dragged tab positions.\n     */\n    _releaseMouse() {\n        // Do nothing if no drag is in progress.\n        let data = this._dragData;\n        if (!data) {\n            return;\n        }\n        // Clear the drag data reference.\n        this._dragData = null;\n        // Remove the extra document event listeners.\n        this.document.removeEventListener('pointermove', this, true);\n        this.document.removeEventListener('pointerup', this, true);\n        this.document.removeEventListener('keydown', this, true);\n        this.document.removeEventListener('contextmenu', this, true);\n        // Indicate the drag has been aborted. This allows the mouse\n        // event handlers to return early when the drag is canceled.\n        data.dragAborted = true;\n        // If the drag is not active, there's nothing more to do.\n        if (!data.dragActive) {\n            return;\n        }\n        // Reset the tabs to their non-dragged positions.\n        Private$7.resetTabPositions(this.contentNode.children, this._orientation);\n        // Clear the cursor override.\n        data.override.dispose();\n        // Clear the dragging style classes.\n        data.tab.classList.remove('lm-mod-dragging');\n        this.removeClass('lm-mod-dragging');\n    }\n    /**\n     * Adjust the current index for a tab insert operation.\n     *\n     * This method accounts for the tab bar's insertion behavior when\n     * adjusting the current index and emitting the changed signal.\n     */\n    _adjustCurrentForInsert(i, title) {\n        // Lookup commonly used variables.\n        let ct = this.currentTitle;\n        let ci = this._currentIndex;\n        let bh = this.insertBehavior;\n        // TODO: do we need to do an update to update the aria-selected attribute?\n        // Handle the behavior where the new tab is always selected,\n        // or the behavior where the new tab is selected if needed.\n        if (bh === 'select-tab' || (bh === 'select-tab-if-needed' && ci === -1)) {\n            this._currentIndex = i;\n            this._previousTitle = ct;\n            this._currentChanged.emit({\n                previousIndex: ci,\n                previousTitle: ct,\n                currentIndex: i,\n                currentTitle: title\n            });\n            return;\n        }\n        // Otherwise, silently adjust the current index if needed.\n        if (ci >= i) {\n            this._currentIndex++;\n        }\n    }\n    /**\n     * Adjust the current index for a tab move operation.\n     *\n     * This method will not cause the actual current tab to change.\n     * It silently adjusts the index to account for the given move.\n     */\n    _adjustCurrentForMove(i, j) {\n        if (this._currentIndex === i) {\n            this._currentIndex = j;\n        }\n        else if (this._currentIndex < i && this._currentIndex >= j) {\n            this._currentIndex++;\n        }\n        else if (this._currentIndex > i && this._currentIndex <= j) {\n            this._currentIndex--;\n        }\n    }\n    /**\n     * Adjust the current index for a tab remove operation.\n     *\n     * This method accounts for the tab bar's remove behavior when\n     * adjusting the current index and emitting the changed signal.\n     */\n    _adjustCurrentForRemove(i, title) {\n        // Lookup commonly used variables.\n        let ci = this._currentIndex;\n        let bh = this.removeBehavior;\n        // Silently adjust the index if the current tab is not removed.\n        if (ci !== i) {\n            if (ci > i) {\n                this._currentIndex--;\n            }\n            return;\n        }\n        // TODO: do we need to do an update to adjust the aria-selected value?\n        // No tab gets selected if the tab bar is empty.\n        if (this._titles.length === 0) {\n            this._currentIndex = -1;\n            this._currentChanged.emit({\n                previousIndex: i,\n                previousTitle: title,\n                currentIndex: -1,\n                currentTitle: null\n            });\n            return;\n        }\n        // Handle behavior where the next sibling tab is selected.\n        if (bh === 'select-tab-after') {\n            this._currentIndex = Math.min(i, this._titles.length - 1);\n            this._currentChanged.emit({\n                previousIndex: i,\n                previousTitle: title,\n                currentIndex: this._currentIndex,\n                currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Handle behavior where the previous sibling tab is selected.\n        if (bh === 'select-tab-before') {\n            this._currentIndex = Math.max(0, i - 1);\n            this._currentChanged.emit({\n                previousIndex: i,\n                previousTitle: title,\n                currentIndex: this._currentIndex,\n                currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Handle behavior where the previous history tab is selected.\n        if (bh === 'select-previous-tab') {\n            if (this._previousTitle) {\n                this._currentIndex = this._titles.indexOf(this._previousTitle);\n                this._previousTitle = null;\n            }\n            else {\n                this._currentIndex = Math.min(i, this._titles.length - 1);\n            }\n            this._currentChanged.emit({\n                previousIndex: i,\n                previousTitle: title,\n                currentIndex: this._currentIndex,\n                currentTitle: this.currentTitle\n            });\n            return;\n        }\n        // Otherwise, no tab gets selected.\n        this._currentIndex = -1;\n        this._currentChanged.emit({\n            previousIndex: i,\n            previousTitle: title,\n            currentIndex: -1,\n            currentTitle: null\n        });\n    }\n    /**\n     * Handle the `changed` signal of a title object.\n     */\n    _onTitleChanged(sender) {\n        this.update();\n    }\n}\n/**\n * The namespace for the `TabBar` class statics.\n */\n(function (TabBar) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    class Renderer {\n        constructor() {\n            /**\n             * A selector which matches the close icon node in a tab.\n             */\n            this.closeIconSelector = '.lm-TabBar-tabCloseIcon';\n            this._tabID = 0;\n            this._tabKeys = new WeakMap();\n            this._uuid = ++Renderer._nInstance;\n        }\n        /**\n         * Render the virtual element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab.\n         */\n        renderTab(data) {\n            let title = data.title.caption;\n            let key = this.createTabKey(data);\n            let id = key;\n            let style = this.createTabStyle(data);\n            let className = this.createTabClass(data);\n            let dataset = this.createTabDataset(data);\n            let aria = this.createTabARIA(data);\n            if (data.title.closable) {\n                return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));\n            }\n            else {\n                return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));\n            }\n        }\n        /**\n         * Render the icon element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab icon.\n         */\n        renderIcon(data) {\n            const { title } = data;\n            let className = this.createIconClass(data);\n            // If title.icon is undefined, it will be ignored.\n            return h.div({ className }, title.icon, title.iconLabel);\n        }\n        /**\n         * Render the label element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab label.\n         */\n        renderLabel(data) {\n            return h.div({ className: 'lm-TabBar-tabLabel' }, data.title.label);\n        }\n        /**\n         * Render the close icon element for a tab.\n         *\n         * @param data - The data to use for rendering the tab.\n         *\n         * @returns A virtual element representing the tab close icon.\n         */\n        renderCloseIcon(data) {\n            return h.div({ className: 'lm-TabBar-tabCloseIcon' });\n        }\n        /**\n         * Create a unique render key for the tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The unique render key for the tab.\n         *\n         * #### Notes\n         * This method caches the key against the tab title the first time\n         * the key is generated. This enables efficient rendering of moved\n         * tabs and avoids subtle hover style artifacts.\n         */\n        createTabKey(data) {\n            let key = this._tabKeys.get(data.title);\n            if (key === undefined) {\n                key = `tab-key-${this._uuid}-${this._tabID++}`;\n                this._tabKeys.set(data.title, key);\n            }\n            return key;\n        }\n        /**\n         * Create the inline style object for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The inline style data for the tab.\n         */\n        createTabStyle(data) {\n            return { zIndex: `${data.zIndex}` };\n        }\n        /**\n         * Create the class name for the tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The full class name for the tab.\n         */\n        createTabClass(data) {\n            let name = 'lm-TabBar-tab';\n            if (data.title.className) {\n                name += ` ${data.title.className}`;\n            }\n            if (data.title.closable) {\n                name += ' lm-mod-closable';\n            }\n            if (data.current) {\n                name += ' lm-mod-current';\n            }\n            return name;\n        }\n        /**\n         * Create the dataset for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The dataset for the tab.\n         */\n        createTabDataset(data) {\n            return data.title.dataset;\n        }\n        /**\n         * Create the ARIA attributes for a tab.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The ARIA attributes for the tab.\n         */\n        createTabARIA(data) {\n            var _a;\n            return {\n                role: 'tab',\n                'aria-selected': data.current.toString(),\n                tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : '-1'}`\n            };\n        }\n        /**\n         * Create the class name for the tab icon.\n         *\n         * @param data - The data to use for the tab.\n         *\n         * @returns The full class name for the tab icon.\n         */\n        createIconClass(data) {\n            let name = 'lm-TabBar-tabIcon';\n            let extra = data.title.iconClass;\n            return extra ? `${name} ${extra}` : name;\n        }\n    }\n    Renderer._nInstance = 0;\n    TabBar.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    TabBar.defaultRenderer = new Renderer();\n    /**\n     * A selector which matches the add button node in the tab bar.\n     */\n    TabBar.addButtonSelector = '.lm-TabBar-addButton';\n})(TabBar || (TabBar = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$7;\n(function (Private) {\n    /**\n     * The start drag distance threshold.\n     */\n    Private.DRAG_THRESHOLD = 5;\n    /**\n     * The detach distance threshold.\n     */\n    Private.DETACH_THRESHOLD = 20;\n    /**\n     * Create the DOM node for a tab bar.\n     */\n    function createNode() {\n        let node = document.createElement('div');\n        let content = document.createElement('ul');\n        content.setAttribute('role', 'tablist');\n        content.className = 'lm-TabBar-content';\n        node.appendChild(content);\n        let add = document.createElement('div');\n        add.className = 'lm-TabBar-addButton lm-mod-hidden';\n        add.setAttribute('tabindex', '-1');\n        add.setAttribute('role', 'button');\n        node.appendChild(add);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Coerce a title or options into a real title.\n     */\n    function asTitle(value) {\n        return value instanceof Title ? value : new Title(value);\n    }\n    Private.asTitle = asTitle;\n    /**\n     * Parse the transition duration for a tab node.\n     */\n    function parseTransitionDuration(tab) {\n        let style = window.getComputedStyle(tab);\n        return 1000 * (parseFloat(style.transitionDuration) || 0);\n    }\n    Private.parseTransitionDuration = parseTransitionDuration;\n    /**\n     * Get a snapshot of the current tab layout values.\n     */\n    function snapTabLayout(tabs, orientation) {\n        let layout = new Array(tabs.length);\n        for (let i = 0, n = tabs.length; i < n; ++i) {\n            let node = tabs[i];\n            let style = window.getComputedStyle(node);\n            if (orientation === 'horizontal') {\n                layout[i] = {\n                    pos: node.offsetLeft,\n                    size: node.offsetWidth,\n                    margin: parseFloat(style.marginLeft) || 0\n                };\n            }\n            else {\n                layout[i] = {\n                    pos: node.offsetTop,\n                    size: node.offsetHeight,\n                    margin: parseFloat(style.marginTop) || 0\n                };\n            }\n        }\n        return layout;\n    }\n    Private.snapTabLayout = snapTabLayout;\n    /**\n     * Test if the event exceeds the drag threshold.\n     */\n    function dragExceeded(data, event) {\n        let dx = Math.abs(event.clientX - data.pressX);\n        let dy = Math.abs(event.clientY - data.pressY);\n        return dx >= Private.DRAG_THRESHOLD || dy >= Private.DRAG_THRESHOLD;\n    }\n    Private.dragExceeded = dragExceeded;\n    /**\n     * Test if the event exceeds the drag detach threshold.\n     */\n    function detachExceeded(data, event) {\n        let rect = data.contentRect;\n        return (event.clientX < rect.left - Private.DETACH_THRESHOLD ||\n            event.clientX >= rect.right + Private.DETACH_THRESHOLD ||\n            event.clientY < rect.top - Private.DETACH_THRESHOLD ||\n            event.clientY >= rect.bottom + Private.DETACH_THRESHOLD);\n    }\n    Private.detachExceeded = detachExceeded;\n    /**\n     * Update the relative tab positions and computed target index.\n     */\n    function layoutTabs(tabs, data, event, orientation) {\n        // Compute the orientation-sensitive values.\n        let pressPos;\n        let localPos;\n        let clientPos;\n        let clientSize;\n        if (orientation === 'horizontal') {\n            pressPos = data.pressX;\n            localPos = event.clientX - data.contentRect.left;\n            clientPos = event.clientX;\n            clientSize = data.contentRect.width;\n        }\n        else {\n            pressPos = data.pressY;\n            localPos = event.clientY - data.contentRect.top;\n            clientPos = event.clientY;\n            clientSize = data.contentRect.height;\n        }\n        // Compute the target data.\n        let targetIndex = data.index;\n        let targetPos = localPos - data.tabPressPos;\n        let targetEnd = targetPos + data.tabSize;\n        // Update the relative tab positions.\n        for (let i = 0, n = tabs.length; i < n; ++i) {\n            let pxPos;\n            let layout = data.tabLayout[i];\n            let threshold = layout.pos + (layout.size >> 1);\n            if (i < data.index && targetPos < threshold) {\n                pxPos = `${data.tabSize + data.tabLayout[i + 1].margin}px`;\n                targetIndex = Math.min(targetIndex, i);\n            }\n            else if (i > data.index && targetEnd > threshold) {\n                pxPos = `${-data.tabSize - layout.margin}px`;\n                targetIndex = Math.max(targetIndex, i);\n            }\n            else if (i === data.index) {\n                let ideal = clientPos - pressPos;\n                let limit = clientSize - (data.tabPos + data.tabSize);\n                pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;\n            }\n            else {\n                pxPos = '';\n            }\n            if (orientation === 'horizontal') {\n                tabs[i].style.left = pxPos;\n            }\n            else {\n                tabs[i].style.top = pxPos;\n            }\n        }\n        // Update the computed target index.\n        data.targetIndex = targetIndex;\n    }\n    Private.layoutTabs = layoutTabs;\n    /**\n     * Position the drag tab at its final resting relative position.\n     */\n    function finalizeTabPosition(data, orientation) {\n        // Compute the orientation-sensitive client size.\n        let clientSize;\n        if (orientation === 'horizontal') {\n            clientSize = data.contentRect.width;\n        }\n        else {\n            clientSize = data.contentRect.height;\n        }\n        // Compute the ideal final tab position.\n        let ideal;\n        if (data.targetIndex === data.index) {\n            ideal = 0;\n        }\n        else if (data.targetIndex > data.index) {\n            let tgt = data.tabLayout[data.targetIndex];\n            ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;\n        }\n        else {\n            let tgt = data.tabLayout[data.targetIndex];\n            ideal = tgt.pos - data.tabPos;\n        }\n        // Compute the tab position limit.\n        let limit = clientSize - (data.tabPos + data.tabSize);\n        let final = Math.max(-data.tabPos, Math.min(ideal, limit));\n        // Set the final orientation-sensitive position.\n        if (orientation === 'horizontal') {\n            data.tab.style.left = `${final}px`;\n        }\n        else {\n            data.tab.style.top = `${final}px`;\n        }\n    }\n    Private.finalizeTabPosition = finalizeTabPosition;\n    /**\n     * Reset the relative positions of the given tabs.\n     */\n    function resetTabPositions(tabs, orientation) {\n        for (const tab of tabs) {\n            if (orientation === 'horizontal') {\n                tab.style.left = '';\n            }\n            else {\n                tab.style.top = '';\n            }\n        }\n    }\n    Private.resetTabPositions = resetTabPositions;\n})(Private$7 || (Private$7 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A layout which provides a flexible docking arrangement.\n *\n * #### Notes\n * The consumer of this layout is responsible for handling all signals\n * from the generated tab bars and managing the visibility of widgets\n * and tab bars as needed.\n */\nclass DockLayout extends Layout {\n    /**\n     * Construct a new dock layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    constructor(options) {\n        super();\n        this._spacing = 4;\n        this._dirty = false;\n        this._root = null;\n        this._box = null;\n        this._items = new Map();\n        this.renderer = options.renderer;\n        if (options.spacing !== undefined) {\n            this._spacing = Utils$1.clampDimension(options.spacing);\n        }\n        this._document = options.document || document;\n        this._hiddenMode =\n            options.hiddenMode !== undefined\n                ? options.hiddenMode\n                : Widget.HiddenMode.Display;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     *\n     * #### Notes\n     * This will clear and dispose all widgets in the layout.\n     */\n    dispose() {\n        // Get an iterator over the widgets in the layout.\n        let widgets = this[Symbol.iterator]();\n        // Dispose of the layout items.\n        this._items.forEach(item => {\n            item.dispose();\n        });\n        // Clear the layout state before disposing the widgets.\n        this._box = null;\n        this._root = null;\n        this._items.clear();\n        // Dispose of the widgets contained in the old layout root.\n        for (const widget of widgets) {\n            widget.dispose();\n        }\n        // Dispose of the base class.\n        super.dispose();\n    }\n    /**\n     * The method for hiding child widgets.\n     *\n     * #### Notes\n     * If there is only one child widget, `Display` hiding mode will be used\n     * regardless of this setting.\n     */\n    get hiddenMode() {\n        return this._hiddenMode;\n    }\n    set hiddenMode(v) {\n        if (this._hiddenMode === v) {\n            return;\n        }\n        this._hiddenMode = v;\n        for (const bar of this.tabBars()) {\n            if (bar.titles.length > 1) {\n                for (const title of bar.titles) {\n                    title.owner.hiddenMode = this._hiddenMode;\n                }\n            }\n        }\n    }\n    /**\n     * Get the inter-element spacing for the dock layout.\n     */\n    get spacing() {\n        return this._spacing;\n    }\n    /**\n     * Set the inter-element spacing for the dock layout.\n     */\n    set spacing(value) {\n        value = Utils$1.clampDimension(value);\n        if (this._spacing === value) {\n            return;\n        }\n        this._spacing = value;\n        if (!this.parent) {\n            return;\n        }\n        this.parent.fit();\n    }\n    /**\n     * Whether the dock layout is empty.\n     */\n    get isEmpty() {\n        return this._root === null;\n    }\n    /**\n     * Create an iterator over all widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     *\n     * #### Notes\n     * This iterator includes the generated tab bars.\n     */\n    [Symbol.iterator]() {\n        return this._root ? this._root.iterAllWidgets() : empty();\n    }\n    /**\n     * Create an iterator over the user widgets in the layout.\n     *\n     * @returns A new iterator over the user widgets in the layout.\n     *\n     * #### Notes\n     * This iterator does not include the generated tab bars.\n     */\n    widgets() {\n        return this._root ? this._root.iterUserWidgets() : empty();\n    }\n    /**\n     * Create an iterator over the selected widgets in the layout.\n     *\n     * @returns A new iterator over the selected user widgets.\n     *\n     * #### Notes\n     * This iterator yields the widgets corresponding to the current tab\n     * of each tab bar in the layout.\n     */\n    selectedWidgets() {\n        return this._root ? this._root.iterSelectedWidgets() : empty();\n    }\n    /**\n     * Create an iterator over the tab bars in the layout.\n     *\n     * @returns A new iterator over the tab bars in the layout.\n     *\n     * #### Notes\n     * This iterator does not include the user widgets.\n     */\n    tabBars() {\n        return this._root ? this._root.iterTabBars() : empty();\n    }\n    /**\n     * Create an iterator over the handles in the layout.\n     *\n     * @returns A new iterator over the handles in the layout.\n     */\n    handles() {\n        return this._root ? this._root.iterHandles() : empty();\n    }\n    /**\n     * Move a handle to the given offset position.\n     *\n     * @param handle - The handle to move.\n     *\n     * @param offsetX - The desired offset X position of the handle.\n     *\n     * @param offsetY - The desired offset Y position of the handle.\n     *\n     * #### Notes\n     * If the given handle is not contained in the layout, this is no-op.\n     *\n     * The handle will be moved as close as possible to the desired\n     * position without violating any of the layout constraints.\n     *\n     * Only one of the coordinates is used depending on the orientation\n     * of the handle. This method accepts both coordinates to make it\n     * easy to invoke from a mouse move event without needing to know\n     * the handle orientation.\n     */\n    moveHandle(handle, offsetX, offsetY) {\n        // Bail early if there is no root or if the handle is hidden.\n        let hidden = handle.classList.contains('lm-mod-hidden');\n        if (!this._root || hidden) {\n            return;\n        }\n        // Lookup the split node for the handle.\n        let data = this._root.findSplitNode(handle);\n        if (!data) {\n            return;\n        }\n        // Compute the desired delta movement for the handle.\n        let delta;\n        if (data.node.orientation === 'horizontal') {\n            delta = offsetX - handle.offsetLeft;\n        }\n        else {\n            delta = offsetY - handle.offsetTop;\n        }\n        // Bail if there is no handle movement.\n        if (delta === 0) {\n            return;\n        }\n        // Prevent sibling resizing unless needed.\n        data.node.holdSizes();\n        // Adjust the sizers to reflect the handle movement.\n        BoxEngine.adjust(data.node.sizers, data.index, delta);\n        // Update the layout of the widgets.\n        if (this.parent) {\n            this.parent.update();\n        }\n    }\n    /**\n     * Save the current configuration of the dock layout.\n     *\n     * @returns A new config object for the current layout state.\n     *\n     * #### Notes\n     * The return value can be provided to the `restoreLayout` method\n     * in order to restore the layout to its current configuration.\n     */\n    saveLayout() {\n        // Bail early if there is no root.\n        if (!this._root) {\n            return { main: null };\n        }\n        // Hold the current sizes in the layout tree.\n        this._root.holdAllSizes();\n        // Return the layout config.\n        return { main: this._root.createConfig() };\n    }\n    /**\n     * Restore the layout to a previously saved configuration.\n     *\n     * @param config - The layout configuration to restore.\n     *\n     * #### Notes\n     * Widgets which currently belong to the layout but which are not\n     * contained in the config will be unparented.\n     */\n    restoreLayout(config) {\n        // Create the widget set for validating the config.\n        let widgetSet = new Set();\n        // Normalize the main area config and collect the widgets.\n        let mainConfig;\n        if (config.main) {\n            mainConfig = Private$6.normalizeAreaConfig(config.main, widgetSet);\n        }\n        else {\n            mainConfig = null;\n        }\n        // Create iterators over the old content.\n        let oldWidgets = this.widgets();\n        let oldTabBars = this.tabBars();\n        let oldHandles = this.handles();\n        // Clear the root before removing the old content.\n        this._root = null;\n        // Unparent the old widgets which are not in the new config.\n        for (const widget of oldWidgets) {\n            if (!widgetSet.has(widget)) {\n                widget.parent = null;\n            }\n        }\n        // Dispose of the old tab bars.\n        for (const tabBar of oldTabBars) {\n            tabBar.dispose();\n        }\n        // Remove the old handles.\n        for (const handle of oldHandles) {\n            if (handle.parentNode) {\n                handle.parentNode.removeChild(handle);\n            }\n        }\n        // Reparent the new widgets to the current parent.\n        for (const widget of widgetSet) {\n            widget.parent = this.parent;\n        }\n        // Create the root node for the new config.\n        if (mainConfig) {\n            this._root = Private$6.realizeAreaConfig(mainConfig, {\n                // Ignoring optional `document` argument as we must reuse `this._document`\n                createTabBar: (document) => this._createTabBar(),\n                createHandle: () => this._createHandle()\n            }, this._document);\n        }\n        else {\n            this._root = null;\n        }\n        // If there is no parent, there is nothing more to do.\n        if (!this.parent) {\n            return;\n        }\n        // Attach the new widgets to the parent.\n        widgetSet.forEach(widget => {\n            this.attachWidget(widget);\n        });\n        // Post a fit request to the parent.\n        this.parent.fit();\n    }\n    /**\n     * Add a widget to the dock layout.\n     *\n     * @param widget - The widget to add to the dock layout.\n     *\n     * @param options - The additional options for adding the widget.\n     *\n     * #### Notes\n     * The widget will be moved if it is already contained in the layout.\n     *\n     * An error will be thrown if the reference widget is invalid.\n     */\n    addWidget(widget, options = {}) {\n        // Parse the options.\n        let ref = options.ref || null;\n        let mode = options.mode || 'tab-after';\n        // Find the tab node which holds the reference widget.\n        let refNode = null;\n        if (this._root && ref) {\n            refNode = this._root.findTabNode(ref);\n        }\n        // Throw an error if the reference widget is invalid.\n        if (ref && !refNode) {\n            throw new Error('Reference widget is not in the layout.');\n        }\n        // Reparent the widget to the current layout parent.\n        widget.parent = this.parent;\n        // Insert the widget according to the insert mode.\n        switch (mode) {\n            case 'tab-after':\n                this._insertTab(widget, ref, refNode, true);\n                break;\n            case 'tab-before':\n                this._insertTab(widget, ref, refNode, false);\n                break;\n            case 'split-top':\n                this._insertSplit(widget, ref, refNode, 'vertical', false);\n                break;\n            case 'split-left':\n                this._insertSplit(widget, ref, refNode, 'horizontal', false);\n                break;\n            case 'split-right':\n                this._insertSplit(widget, ref, refNode, 'horizontal', true);\n                break;\n            case 'split-bottom':\n                this._insertSplit(widget, ref, refNode, 'vertical', true);\n                break;\n            case 'merge-top':\n                this._insertSplit(widget, ref, refNode, 'vertical', false, true);\n                break;\n            case 'merge-left':\n                this._insertSplit(widget, ref, refNode, 'horizontal', false, true);\n                break;\n            case 'merge-right':\n                this._insertSplit(widget, ref, refNode, 'horizontal', true, true);\n                break;\n            case 'merge-bottom':\n                this._insertSplit(widget, ref, refNode, 'vertical', true, true);\n                break;\n        }\n        // Do nothing else if there is no parent widget.\n        if (!this.parent) {\n            return;\n        }\n        // Ensure the widget is attached to the parent widget.\n        this.attachWidget(widget);\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        // Remove the widget from its current layout location.\n        this._removeWidget(widget);\n        // Do nothing else if there is no parent widget.\n        if (!this.parent) {\n            return;\n        }\n        // Detach the widget from the parent widget.\n        this.detachWidget(widget);\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Find the tab area which contains the given client position.\n     *\n     * @param clientX - The client X position of interest.\n     *\n     * @param clientY - The client Y position of interest.\n     *\n     * @returns The geometry of the tab area at the given position, or\n     *   `null` if there is no tab area at the given position.\n     */\n    hitTestTabAreas(clientX, clientY) {\n        // Bail early if hit testing cannot produce valid results.\n        if (!this._root || !this.parent || !this.parent.isVisible) {\n            return null;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Convert from client to local coordinates.\n        let rect = this.parent.node.getBoundingClientRect();\n        let x = clientX - rect.left - this._box.borderLeft;\n        let y = clientY - rect.top - this._box.borderTop;\n        // Find the tab layout node at the local position.\n        let tabNode = this._root.hitTestTabNodes(x, y);\n        // Bail if a tab layout node was not found.\n        if (!tabNode) {\n            return null;\n        }\n        // Extract the data from the tab node.\n        let { tabBar, top, left, width, height } = tabNode;\n        // Compute the right and bottom edges of the tab area.\n        let borderWidth = this._box.borderLeft + this._box.borderRight;\n        let borderHeight = this._box.borderTop + this._box.borderBottom;\n        let right = rect.width - borderWidth - (left + width);\n        let bottom = rect.height - borderHeight - (top + height);\n        // Return the hit test results.\n        return { tabBar, x, y, top, left, right, bottom, width, height };\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        // Perform superclass initialization.\n        super.init();\n        // Attach each widget to the parent.\n        for (const widget of this) {\n            this.attachWidget(widget);\n        }\n        // Attach each handle to the parent.\n        for (const handle of this.handles()) {\n            this.parent.node.appendChild(handle);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Attach the widget to the layout parent widget.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a no-op if the widget is already attached.\n     */\n    attachWidget(widget) {\n        // Do nothing if the widget is already attached.\n        if (this.parent.node === widget.node.parentNode) {\n            return;\n        }\n        // Create the layout item for the widget.\n        this._items.set(widget, new LayoutItem(widget));\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    }\n    /**\n     * Detach the widget from the layout parent widget.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a no-op if the widget is not attached.\n     */\n    detachWidget(widget) {\n        // Do nothing if the widget is not attached.\n        if (this.parent.node !== widget.node.parentNode) {\n            return;\n        }\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Delete the layout item for the widget.\n        let item = this._items.get(widget);\n        if (item) {\n            this._items.delete(widget);\n            item.dispose();\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        super.onBeforeShow(msg);\n        this.parent.update();\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        super.onBeforeAttach(msg);\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    onChildShown(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    onChildHidden(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    onFitRequest(msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    }\n    /**\n     * Remove the specified widget from the layout structure.\n     *\n     * #### Notes\n     * This is a no-op if the widget is not in the layout tree.\n     *\n     * This does not detach the widget from the parent node.\n     */\n    _removeWidget(widget) {\n        // Bail early if there is no layout root.\n        if (!this._root) {\n            return;\n        }\n        // Find the tab node which contains the given widget.\n        let tabNode = this._root.findTabNode(widget);\n        // Bail early if the tab node is not found.\n        if (!tabNode) {\n            return;\n        }\n        Private$6.removeAria(widget);\n        // If there are multiple tabs, just remove the widget's tab.\n        if (tabNode.tabBar.titles.length > 1) {\n            tabNode.tabBar.removeTab(widget.title);\n            if (this._hiddenMode === Widget.HiddenMode.Scale &&\n                tabNode.tabBar.titles.length == 1) {\n                const existingWidget = tabNode.tabBar.titles[0].owner;\n                existingWidget.hiddenMode = Widget.HiddenMode.Display;\n            }\n            return;\n        }\n        // Otherwise, the tab node needs to be removed...\n        // Dispose the tab bar.\n        tabNode.tabBar.dispose();\n        // Handle the case where the tab node is the root.\n        if (this._root === tabNode) {\n            this._root = null;\n            return;\n        }\n        // Otherwise, remove the tab node from its parent...\n        // Prevent widget resizing unless needed.\n        this._root.holdAllSizes();\n        // Clear the parent reference on the tab node.\n        let splitNode = tabNode.parent;\n        tabNode.parent = null;\n        // Remove the tab node from its parent split node.\n        let i = ArrayExt.removeFirstOf(splitNode.children, tabNode);\n        let handle = ArrayExt.removeAt(splitNode.handles, i);\n        ArrayExt.removeAt(splitNode.sizers, i);\n        // Remove the handle from its parent DOM node.\n        if (handle.parentNode) {\n            handle.parentNode.removeChild(handle);\n        }\n        // If there are multiple children, just update the handles.\n        if (splitNode.children.length > 1) {\n            splitNode.syncHandles();\n            return;\n        }\n        // Otherwise, the split node also needs to be removed...\n        // Clear the parent reference on the split node.\n        let maybeParent = splitNode.parent;\n        splitNode.parent = null;\n        // Lookup the remaining child node and handle.\n        let childNode = splitNode.children[0];\n        let childHandle = splitNode.handles[0];\n        // Clear the split node data.\n        splitNode.children.length = 0;\n        splitNode.handles.length = 0;\n        splitNode.sizers.length = 0;\n        // Remove the child handle from its parent node.\n        if (childHandle.parentNode) {\n            childHandle.parentNode.removeChild(childHandle);\n        }\n        // Handle the case where the split node is the root.\n        if (this._root === splitNode) {\n            childNode.parent = null;\n            this._root = childNode;\n            return;\n        }\n        // Otherwise, move the child node to the parent node...\n        let parentNode = maybeParent;\n        // Lookup the index of the split node.\n        let j = parentNode.children.indexOf(splitNode);\n        // Handle the case where the child node is a tab node.\n        if (childNode instanceof Private$6.TabLayoutNode) {\n            childNode.parent = parentNode;\n            parentNode.children[j] = childNode;\n            return;\n        }\n        // Remove the split data from the parent.\n        let splitHandle = ArrayExt.removeAt(parentNode.handles, j);\n        ArrayExt.removeAt(parentNode.children, j);\n        ArrayExt.removeAt(parentNode.sizers, j);\n        // Remove the handle from its parent node.\n        if (splitHandle.parentNode) {\n            splitHandle.parentNode.removeChild(splitHandle);\n        }\n        // The child node and the split parent node will have the same\n        // orientation. Merge the grand-children with the parent node.\n        for (let i = 0, n = childNode.children.length; i < n; ++i) {\n            let gChild = childNode.children[i];\n            let gHandle = childNode.handles[i];\n            let gSizer = childNode.sizers[i];\n            ArrayExt.insert(parentNode.children, j + i, gChild);\n            ArrayExt.insert(parentNode.handles, j + i, gHandle);\n            ArrayExt.insert(parentNode.sizers, j + i, gSizer);\n            gChild.parent = parentNode;\n        }\n        // Clear the child node.\n        childNode.children.length = 0;\n        childNode.handles.length = 0;\n        childNode.sizers.length = 0;\n        childNode.parent = null;\n        // Sync the handles on the parent node.\n        parentNode.syncHandles();\n    }\n    /**\n     * Create the tab layout node to hold the widget.\n     */\n    _createTabNode(widget) {\n        let tabNode = new Private$6.TabLayoutNode(this._createTabBar());\n        tabNode.tabBar.addTab(widget.title);\n        Private$6.addAria(widget, tabNode.tabBar);\n        return tabNode;\n    }\n    /**\n     * Insert a widget next to an existing tab.\n     *\n     * #### Notes\n     * This does not attach the widget to the parent widget.\n     */\n    _insertTab(widget, ref, refNode, after) {\n        // Do nothing if the tab is inserted next to itself.\n        if (widget === ref) {\n            return;\n        }\n        // Create the root if it does not exist.\n        if (!this._root) {\n            let tabNode = new Private$6.TabLayoutNode(this._createTabBar());\n            tabNode.tabBar.addTab(widget.title);\n            this._root = tabNode;\n            Private$6.addAria(widget, tabNode.tabBar);\n            return;\n        }\n        // Use the first tab node as the ref node if needed.\n        if (!refNode) {\n            refNode = this._root.findFirstTabNode();\n        }\n        // If the widget is not contained in the ref node, ensure it is\n        // removed from the layout and hidden before being added again.\n        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {\n            this._removeWidget(widget);\n            widget.hide();\n        }\n        // Lookup the target index for inserting the tab.\n        let index;\n        if (ref) {\n            index = refNode.tabBar.titles.indexOf(ref.title);\n        }\n        else {\n            index = refNode.tabBar.currentIndex;\n        }\n        // Using transform create an additional layer in the pixel pipeline\n        // to limit the number of layer, it is set only if there is more than one widget.\n        if (this._hiddenMode === Widget.HiddenMode.Scale) {\n            if (refNode.tabBar.titles.length === 0) {\n                // Singular tab should use display mode to limit number of layers.\n                widget.hiddenMode = Widget.HiddenMode.Display;\n            }\n            else if (refNode.tabBar.titles.length == 1) {\n                // If we are adding a second tab, switch the existing tab back to scale.\n                const existingWidget = refNode.tabBar.titles[0].owner;\n                existingWidget.hiddenMode = Widget.HiddenMode.Scale;\n            }\n            else {\n                // For the third and subsequent tabs no special action is needed.\n                widget.hiddenMode = Widget.HiddenMode.Scale;\n            }\n        }\n        else {\n            // For all other modes just propagate the current mode.\n            widget.hiddenMode = this._hiddenMode;\n        }\n        // Insert the widget's tab relative to the target index.\n        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);\n        Private$6.addAria(widget, refNode.tabBar);\n    }\n    /**\n     * Insert a widget as a new split area.\n     *\n     * #### Notes\n     * This does not attach the widget to the parent widget.\n     */\n    _insertSplit(widget, ref, refNode, orientation, after, merge = false) {\n        // Do nothing if there is no effective split.\n        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {\n            return;\n        }\n        // Ensure the widget is removed from the current layout.\n        this._removeWidget(widget);\n        // Set the root if it does not exist.\n        if (!this._root) {\n            this._root = this._createTabNode(widget);\n            return;\n        }\n        // If the ref node parent is null, split the root.\n        if (!refNode || !refNode.parent) {\n            // Ensure the root is split with the correct orientation.\n            let root = this._splitRoot(orientation);\n            // Determine the insert index for the new tab node.\n            let i = after ? root.children.length : 0;\n            // Normalize the split node.\n            root.normalizeSizes();\n            // Create the sizer for new tab node.\n            let sizer = Private$6.createSizer(refNode ? 1 : Private$6.GOLDEN_RATIO);\n            // Insert the tab node sized to the golden ratio.\n            let tabNode = this._createTabNode(widget);\n            ArrayExt.insert(root.children, i, tabNode);\n            ArrayExt.insert(root.sizers, i, sizer);\n            ArrayExt.insert(root.handles, i, this._createHandle());\n            tabNode.parent = root;\n            // Re-normalize the split node to maintain the ratios.\n            root.normalizeSizes();\n            // Finally, synchronize the visibility of the handles.\n            root.syncHandles();\n            return;\n        }\n        // Lookup the split node for the ref widget.\n        let splitNode = refNode.parent;\n        // If the split node already had the correct orientation,\n        // the widget can be inserted into the split node directly.\n        if (splitNode.orientation === orientation) {\n            // Find the index of the ref node.\n            let i = splitNode.children.indexOf(refNode);\n            // Conditionally reuse a tab layout found in the wanted position.\n            if (merge) {\n                let j = i + (after ? 1 : -1);\n                let sibling = splitNode.children[j];\n                if (sibling instanceof Private$6.TabLayoutNode) {\n                    this._insertTab(widget, null, sibling, true);\n                    ++sibling.tabBar.currentIndex;\n                    return;\n                }\n            }\n            // Normalize the split node.\n            splitNode.normalizeSizes();\n            // Consume half the space for the insert location.\n            let s = (splitNode.sizers[i].sizeHint /= 2);\n            // Insert the tab node sized to the other half.\n            let j = i + (after ? 1 : 0);\n            let tabNode = this._createTabNode(widget);\n            ArrayExt.insert(splitNode.children, j, tabNode);\n            ArrayExt.insert(splitNode.sizers, j, Private$6.createSizer(s));\n            ArrayExt.insert(splitNode.handles, j, this._createHandle());\n            tabNode.parent = splitNode;\n            // Finally, synchronize the visibility of the handles.\n            splitNode.syncHandles();\n            return;\n        }\n        // Remove the ref node from the split node.\n        let i = ArrayExt.removeFirstOf(splitNode.children, refNode);\n        // Create a new normalized split node for the children.\n        let childNode = new Private$6.SplitLayoutNode(orientation);\n        childNode.normalized = true;\n        // Add the ref node sized to half the space.\n        childNode.children.push(refNode);\n        childNode.sizers.push(Private$6.createSizer(0.5));\n        childNode.handles.push(this._createHandle());\n        refNode.parent = childNode;\n        // Add the tab node sized to the other half.\n        let j = after ? 1 : 0;\n        let tabNode = this._createTabNode(widget);\n        ArrayExt.insert(childNode.children, j, tabNode);\n        ArrayExt.insert(childNode.sizers, j, Private$6.createSizer(0.5));\n        ArrayExt.insert(childNode.handles, j, this._createHandle());\n        tabNode.parent = childNode;\n        // Synchronize the visibility of the handles.\n        childNode.syncHandles();\n        // Finally, add the new child node to the original split node.\n        ArrayExt.insert(splitNode.children, i, childNode);\n        childNode.parent = splitNode;\n    }\n    /**\n     * Ensure the root is a split node with the given orientation.\n     */\n    _splitRoot(orientation) {\n        // Bail early if the root already meets the requirements.\n        let oldRoot = this._root;\n        if (oldRoot instanceof Private$6.SplitLayoutNode) {\n            if (oldRoot.orientation === orientation) {\n                return oldRoot;\n            }\n        }\n        // Create a new root node with the specified orientation.\n        let newRoot = (this._root = new Private$6.SplitLayoutNode(orientation));\n        // Add the old root to the new root.\n        if (oldRoot) {\n            newRoot.children.push(oldRoot);\n            newRoot.sizers.push(Private$6.createSizer(0));\n            newRoot.handles.push(this._createHandle());\n            oldRoot.parent = newRoot;\n        }\n        // Return the new root as a convenience.\n        return newRoot;\n    }\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    _fit() {\n        // Set up the computed minimum size.\n        let minW = 0;\n        let minH = 0;\n        // Update the size limits for the layout tree.\n        if (this._root) {\n            let limits = this._root.fit(this._spacing, this._items);\n            minW = limits.minWidth;\n            minH = limits.minHeight;\n        }\n        // Update the box sizing and add it to the computed min size.\n        let box = (this._box = ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        let style = this.parent.node.style;\n        style.minWidth = `${minW}px`;\n        style.minHeight = `${minH}px`;\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    }\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    _update(offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Bail early if there is no root layout node.\n        if (!this._root) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        let x = this._box.paddingTop;\n        let y = this._box.paddingLeft;\n        let width = offsetWidth - this._box.horizontalSum;\n        let height = offsetHeight - this._box.verticalSum;\n        // Update the geometry of the layout tree.\n        this._root.update(x, y, width, height, this._spacing, this._items);\n    }\n    /**\n     * Create a new tab bar for use by the dock layout.\n     *\n     * #### Notes\n     * The tab bar will be attached to the parent if it exists.\n     */\n    _createTabBar() {\n        // Create the tab bar using the renderer.\n        let tabBar = this.renderer.createTabBar(this._document);\n        // Enforce necessary tab bar behavior.\n        tabBar.orientation = 'horizontal';\n        // Attach the tab bar to the parent if possible.\n        if (this.parent) {\n            this.attachWidget(tabBar);\n        }\n        // Return the initialized tab bar.\n        return tabBar;\n    }\n    /**\n     * Create a new handle for the dock layout.\n     *\n     * #### Notes\n     * The handle will be attached to the parent if it exists.\n     */\n    _createHandle() {\n        // Create the handle using the renderer.\n        let handle = this.renderer.createHandle();\n        // Initialize the handle layout behavior.\n        let style = handle.style;\n        style.position = 'absolute';\n        style.contain = 'strict';\n        style.top = '0';\n        style.left = '0';\n        style.width = '0';\n        style.height = '0';\n        // Attach the handle to the parent if it exists.\n        if (this.parent) {\n            this.parent.node.appendChild(handle);\n        }\n        // Return the initialized handle.\n        return handle;\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$6;\n(function (Private) {\n    /**\n     * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n     */\n    Private.GOLDEN_RATIO = 0.618;\n    /**\n     * Create a box sizer with an initial size hint.\n     */\n    function createSizer(hint) {\n        let sizer = new BoxSizer();\n        sizer.sizeHint = hint;\n        sizer.size = hint;\n        return sizer;\n    }\n    Private.createSizer = createSizer;\n    /**\n     * Normalize an area config object and collect the visited widgets.\n     */\n    function normalizeAreaConfig(config, widgetSet) {\n        let result;\n        if (config.type === 'tab-area') {\n            result = normalizeTabAreaConfig(config, widgetSet);\n        }\n        else {\n            result = normalizeSplitAreaConfig(config, widgetSet);\n        }\n        return result;\n    }\n    Private.normalizeAreaConfig = normalizeAreaConfig;\n    /**\n     * Convert a normalized area config into a layout tree.\n     */\n    function realizeAreaConfig(config, renderer, document) {\n        let node;\n        if (config.type === 'tab-area') {\n            node = realizeTabAreaConfig(config, renderer, document);\n        }\n        else {\n            node = realizeSplitAreaConfig(config, renderer, document);\n        }\n        return node;\n    }\n    Private.realizeAreaConfig = realizeAreaConfig;\n    /**\n     * A layout node which holds the data for a tabbed area.\n     */\n    class TabLayoutNode {\n        /**\n         * Construct a new tab layout node.\n         *\n         * @param tabBar - The tab bar to use for the layout node.\n         */\n        constructor(tabBar) {\n            /**\n             * The parent of the layout node.\n             */\n            this.parent = null;\n            this._top = 0;\n            this._left = 0;\n            this._width = 0;\n            this._height = 0;\n            let tabSizer = new BoxSizer();\n            let widgetSizer = new BoxSizer();\n            tabSizer.stretch = 0;\n            widgetSizer.stretch = 1;\n            this.tabBar = tabBar;\n            this.sizers = [tabSizer, widgetSizer];\n        }\n        /**\n         * The most recent value for the `top` edge of the layout box.\n         */\n        get top() {\n            return this._top;\n        }\n        /**\n         * The most recent value for the `left` edge of the layout box.\n         */\n        get left() {\n            return this._left;\n        }\n        /**\n         * The most recent value for the `width` of the layout box.\n         */\n        get width() {\n            return this._width;\n        }\n        /**\n         * The most recent value for the `height` of the layout box.\n         */\n        get height() {\n            return this._height;\n        }\n        /**\n         * Create an iterator for all widgets in the layout tree.\n         */\n        *iterAllWidgets() {\n            yield this.tabBar;\n            yield* this.iterUserWidgets();\n        }\n        /**\n         * Create an iterator for the user widgets in the layout tree.\n         */\n        *iterUserWidgets() {\n            for (const title of this.tabBar.titles) {\n                yield title.owner;\n            }\n        }\n        /**\n         * Create an iterator for the selected widgets in the layout tree.\n         */\n        *iterSelectedWidgets() {\n            let title = this.tabBar.currentTitle;\n            if (title) {\n                yield title.owner;\n            }\n        }\n        /**\n         * Create an iterator for the tab bars in the layout tree.\n         */\n        *iterTabBars() {\n            yield this.tabBar;\n        }\n        /**\n         * Create an iterator for the handles in the layout tree.\n         */\n        // eslint-disable-next-line require-yield\n        *iterHandles() {\n            return;\n        }\n        /**\n         * Find the tab layout node which contains the given widget.\n         */\n        findTabNode(widget) {\n            return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;\n        }\n        /**\n         * Find the split layout node which contains the given handle.\n         */\n        findSplitNode(handle) {\n            return null;\n        }\n        /**\n         * Find the first tab layout node in a layout tree.\n         */\n        findFirstTabNode() {\n            return this;\n        }\n        /**\n         * Find the tab layout node which contains the local point.\n         */\n        hitTestTabNodes(x, y) {\n            if (x < this._left || x >= this._left + this._width) {\n                return null;\n            }\n            if (y < this._top || y >= this._top + this._height) {\n                return null;\n            }\n            return this;\n        }\n        /**\n         * Create a configuration object for the layout tree.\n         */\n        createConfig() {\n            let widgets = this.tabBar.titles.map(title => title.owner);\n            let currentIndex = this.tabBar.currentIndex;\n            return { type: 'tab-area', widgets, currentIndex };\n        }\n        /**\n         * Recursively hold all of the sizes in the layout tree.\n         *\n         * This ignores the sizers of tab layout nodes.\n         */\n        holdAllSizes() {\n            return;\n        }\n        /**\n         * Fit the layout tree.\n         */\n        fit(spacing, items) {\n            // Set up the limit variables.\n            let minWidth = 0;\n            let minHeight = 0;\n            let maxWidth = Infinity;\n            let maxHeight = Infinity;\n            // Lookup the tab bar layout item.\n            let tabBarItem = items.get(this.tabBar);\n            // Lookup the widget layout item.\n            let current = this.tabBar.currentTitle;\n            let widgetItem = current ? items.get(current.owner) : undefined;\n            // Lookup the tab bar and widget sizers.\n            let [tabBarSizer, widgetSizer] = this.sizers;\n            // Update the tab bar limits.\n            if (tabBarItem) {\n                tabBarItem.fit();\n            }\n            // Update the widget limits.\n            if (widgetItem) {\n                widgetItem.fit();\n            }\n            // Update the results and sizer for the tab bar.\n            if (tabBarItem && !tabBarItem.isHidden) {\n                minWidth = Math.max(minWidth, tabBarItem.minWidth);\n                minHeight += tabBarItem.minHeight;\n                tabBarSizer.minSize = tabBarItem.minHeight;\n                tabBarSizer.maxSize = tabBarItem.maxHeight;\n            }\n            else {\n                tabBarSizer.minSize = 0;\n                tabBarSizer.maxSize = 0;\n            }\n            // Update the results and sizer for the current widget.\n            if (widgetItem && !widgetItem.isHidden) {\n                minWidth = Math.max(minWidth, widgetItem.minWidth);\n                minHeight += widgetItem.minHeight;\n                widgetSizer.minSize = widgetItem.minHeight;\n                widgetSizer.maxSize = Infinity;\n            }\n            else {\n                widgetSizer.minSize = 0;\n                widgetSizer.maxSize = Infinity;\n            }\n            // Return the computed size limits for the layout node.\n            return { minWidth, minHeight, maxWidth, maxHeight };\n        }\n        /**\n         * Update the layout tree.\n         */\n        update(left, top, width, height, spacing, items) {\n            // Update the layout box values.\n            this._top = top;\n            this._left = left;\n            this._width = width;\n            this._height = height;\n            // Lookup the tab bar layout item.\n            let tabBarItem = items.get(this.tabBar);\n            // Lookup the widget layout item.\n            let current = this.tabBar.currentTitle;\n            let widgetItem = current ? items.get(current.owner) : undefined;\n            // Distribute the layout space to the sizers.\n            BoxEngine.calc(this.sizers, height);\n            // Update the tab bar item using the computed size.\n            if (tabBarItem && !tabBarItem.isHidden) {\n                let size = this.sizers[0].size;\n                tabBarItem.update(left, top, width, size);\n                top += size;\n            }\n            // Layout the widget using the computed size.\n            if (widgetItem && !widgetItem.isHidden) {\n                let size = this.sizers[1].size;\n                widgetItem.update(left, top, width, size);\n            }\n        }\n    }\n    Private.TabLayoutNode = TabLayoutNode;\n    /**\n     * A layout node which holds the data for a split area.\n     */\n    class SplitLayoutNode {\n        /**\n         * Construct a new split layout node.\n         *\n         * @param orientation - The orientation of the node.\n         */\n        constructor(orientation) {\n            /**\n             * The parent of the layout node.\n             */\n            this.parent = null;\n            /**\n             * Whether the sizers have been normalized.\n             */\n            this.normalized = false;\n            /**\n             * The child nodes for the split node.\n             */\n            this.children = [];\n            /**\n             * The box sizers for the layout children.\n             */\n            this.sizers = [];\n            /**\n             * The handles for the layout children.\n             */\n            this.handles = [];\n            this.orientation = orientation;\n        }\n        /**\n         * Create an iterator for all widgets in the layout tree.\n         */\n        *iterAllWidgets() {\n            for (const child of this.children) {\n                yield* child.iterAllWidgets();\n            }\n        }\n        /**\n         * Create an iterator for the user widgets in the layout tree.\n         */\n        *iterUserWidgets() {\n            for (const child of this.children) {\n                yield* child.iterUserWidgets();\n            }\n        }\n        /**\n         * Create an iterator for the selected widgets in the layout tree.\n         */\n        *iterSelectedWidgets() {\n            for (const child of this.children) {\n                yield* child.iterSelectedWidgets();\n            }\n        }\n        /**\n         * Create an iterator for the tab bars in the layout tree.\n         */\n        *iterTabBars() {\n            for (const child of this.children) {\n                yield* child.iterTabBars();\n            }\n        }\n        /**\n         * Create an iterator for the handles in the layout tree.\n         */\n        *iterHandles() {\n            yield* this.handles;\n            for (const child of this.children) {\n                yield* child.iterHandles();\n            }\n        }\n        /**\n         * Find the tab layout node which contains the given widget.\n         */\n        findTabNode(widget) {\n            for (let i = 0, n = this.children.length; i < n; ++i) {\n                let result = this.children[i].findTabNode(widget);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * Find the split layout node which contains the given handle.\n         */\n        findSplitNode(handle) {\n            let index = this.handles.indexOf(handle);\n            if (index !== -1) {\n                return { index, node: this };\n            }\n            for (let i = 0, n = this.children.length; i < n; ++i) {\n                let result = this.children[i].findSplitNode(handle);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * Find the first tab layout node in a layout tree.\n         */\n        findFirstTabNode() {\n            if (this.children.length === 0) {\n                return null;\n            }\n            return this.children[0].findFirstTabNode();\n        }\n        /**\n         * Find the tab layout node which contains the local point.\n         */\n        hitTestTabNodes(x, y) {\n            for (let i = 0, n = this.children.length; i < n; ++i) {\n                let result = this.children[i].hitTestTabNodes(x, y);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * Create a configuration object for the layout tree.\n         */\n        createConfig() {\n            let orientation = this.orientation;\n            let sizes = this.createNormalizedSizes();\n            let children = this.children.map(child => child.createConfig());\n            return { type: 'split-area', orientation, children, sizes };\n        }\n        /**\n         * Sync the visibility and orientation of the handles.\n         */\n        syncHandles() {\n            this.handles.forEach((handle, i) => {\n                handle.setAttribute('data-orientation', this.orientation);\n                if (i === this.handles.length - 1) {\n                    handle.classList.add('lm-mod-hidden');\n                }\n                else {\n                    handle.classList.remove('lm-mod-hidden');\n                }\n            });\n        }\n        /**\n         * Hold the current sizes of the box sizers.\n         *\n         * This sets the size hint of each sizer to its current size.\n         */\n        holdSizes() {\n            for (const sizer of this.sizers) {\n                sizer.sizeHint = sizer.size;\n            }\n        }\n        /**\n         * Recursively hold all of the sizes in the layout tree.\n         *\n         * This ignores the sizers of tab layout nodes.\n         */\n        holdAllSizes() {\n            for (const child of this.children) {\n                child.holdAllSizes();\n            }\n            this.holdSizes();\n        }\n        /**\n         * Normalize the sizes of the split layout node.\n         */\n        normalizeSizes() {\n            // Bail early if the sizers are empty.\n            let n = this.sizers.length;\n            if (n === 0) {\n                return;\n            }\n            // Hold the current sizes of the sizers.\n            this.holdSizes();\n            // Compute the sum of the sizes.\n            let sum = this.sizers.reduce((v, sizer) => v + sizer.sizeHint, 0);\n            // Normalize the sizes based on the sum.\n            if (sum === 0) {\n                for (const sizer of this.sizers) {\n                    sizer.size = sizer.sizeHint = 1 / n;\n                }\n            }\n            else {\n                for (const sizer of this.sizers) {\n                    sizer.size = sizer.sizeHint /= sum;\n                }\n            }\n            // Mark the sizes as normalized.\n            this.normalized = true;\n        }\n        /**\n         * Snap the normalized sizes of the split layout node.\n         */\n        createNormalizedSizes() {\n            // Bail early if the sizers are empty.\n            let n = this.sizers.length;\n            if (n === 0) {\n                return [];\n            }\n            // Grab the current sizes of the sizers.\n            let sizes = this.sizers.map(sizer => sizer.size);\n            // Compute the sum of the sizes.\n            let sum = sizes.reduce((v, size) => v + size, 0);\n            // Normalize the sizes based on the sum.\n            if (sum === 0) {\n                for (let i = sizes.length - 1; i > -1; i--) {\n                    sizes[i] = 1 / n;\n                }\n            }\n            else {\n                for (let i = sizes.length - 1; i > -1; i--) {\n                    sizes[i] /= sum;\n                }\n            }\n            // Return the normalized sizes.\n            return sizes;\n        }\n        /**\n         * Fit the layout tree.\n         */\n        fit(spacing, items) {\n            // Compute the required fixed space.\n            let horizontal = this.orientation === 'horizontal';\n            let fixed = Math.max(0, this.children.length - 1) * spacing;\n            // Set up the limit variables.\n            let minWidth = horizontal ? fixed : 0;\n            let minHeight = horizontal ? 0 : fixed;\n            let maxWidth = Infinity;\n            let maxHeight = Infinity;\n            // Fit the children and update the limits.\n            for (let i = 0, n = this.children.length; i < n; ++i) {\n                let limits = this.children[i].fit(spacing, items);\n                if (horizontal) {\n                    minHeight = Math.max(minHeight, limits.minHeight);\n                    minWidth += limits.minWidth;\n                    this.sizers[i].minSize = limits.minWidth;\n                }\n                else {\n                    minWidth = Math.max(minWidth, limits.minWidth);\n                    minHeight += limits.minHeight;\n                    this.sizers[i].minSize = limits.minHeight;\n                }\n            }\n            // Return the computed limits for the layout node.\n            return { minWidth, minHeight, maxWidth, maxHeight };\n        }\n        /**\n         * Update the layout tree.\n         */\n        update(left, top, width, height, spacing, items) {\n            // Compute the available layout space.\n            let horizontal = this.orientation === 'horizontal';\n            let fixed = Math.max(0, this.children.length - 1) * spacing;\n            let space = Math.max(0, (horizontal ? width : height) - fixed);\n            // De-normalize the sizes if needed.\n            if (this.normalized) {\n                for (const sizer of this.sizers) {\n                    sizer.sizeHint *= space;\n                }\n                this.normalized = false;\n            }\n            // Distribute the layout space to the sizers.\n            BoxEngine.calc(this.sizers, space);\n            // Update the geometry of the child nodes and handles.\n            for (let i = 0, n = this.children.length; i < n; ++i) {\n                let child = this.children[i];\n                let size = this.sizers[i].size;\n                let handleStyle = this.handles[i].style;\n                if (horizontal) {\n                    child.update(left, top, size, height, spacing, items);\n                    left += size;\n                    handleStyle.top = `${top}px`;\n                    handleStyle.left = `${left}px`;\n                    handleStyle.width = `${spacing}px`;\n                    handleStyle.height = `${height}px`;\n                    left += spacing;\n                }\n                else {\n                    child.update(left, top, width, size, spacing, items);\n                    top += size;\n                    handleStyle.top = `${top}px`;\n                    handleStyle.left = `${left}px`;\n                    handleStyle.width = `${width}px`;\n                    handleStyle.height = `${spacing}px`;\n                    top += spacing;\n                }\n            }\n        }\n    }\n    Private.SplitLayoutNode = SplitLayoutNode;\n    function addAria(widget, tabBar) {\n        widget.node.setAttribute('role', 'tabpanel');\n        let renderer = tabBar.renderer;\n        if (renderer instanceof TabBar.Renderer) {\n            let tabId = renderer.createTabKey({\n                title: widget.title,\n                current: false,\n                zIndex: 0\n            });\n            widget.node.setAttribute('aria-labelledby', tabId);\n        }\n    }\n    Private.addAria = addAria;\n    function removeAria(widget) {\n        widget.node.removeAttribute('role');\n        widget.node.removeAttribute('aria-labelledby');\n    }\n    Private.removeAria = removeAria;\n    /**\n     * Normalize a tab area config and collect the visited widgets.\n     */\n    function normalizeTabAreaConfig(config, widgetSet) {\n        // Bail early if there is no content.\n        if (config.widgets.length === 0) {\n            return null;\n        }\n        // Setup the filtered widgets array.\n        let widgets = [];\n        // Filter the config for unique widgets.\n        for (const widget of config.widgets) {\n            if (!widgetSet.has(widget)) {\n                widgetSet.add(widget);\n                widgets.push(widget);\n            }\n        }\n        // Bail if there are no effective widgets.\n        if (widgets.length === 0) {\n            return null;\n        }\n        // Normalize the current index.\n        let index = config.currentIndex;\n        if (index !== -1 && (index < 0 || index >= widgets.length)) {\n            index = 0;\n        }\n        // Return a normalized config object.\n        return { type: 'tab-area', widgets, currentIndex: index };\n    }\n    /**\n     * Normalize a split area config and collect the visited widgets.\n     */\n    function normalizeSplitAreaConfig(config, widgetSet) {\n        // Set up the result variables.\n        let orientation = config.orientation;\n        let children = [];\n        let sizes = [];\n        // Normalize the config children.\n        for (let i = 0, n = config.children.length; i < n; ++i) {\n            // Normalize the child config.\n            let child = normalizeAreaConfig(config.children[i], widgetSet);\n            // Ignore an empty child.\n            if (!child) {\n                continue;\n            }\n            // Add the child or hoist its content as appropriate.\n            if (child.type === 'tab-area' || child.orientation !== orientation) {\n                children.push(child);\n                sizes.push(Math.abs(config.sizes[i] || 0));\n            }\n            else {\n                children.push(...child.children);\n                sizes.push(...child.sizes);\n            }\n        }\n        // Bail if there are no effective children.\n        if (children.length === 0) {\n            return null;\n        }\n        // If there is only one effective child, return that child.\n        if (children.length === 1) {\n            return children[0];\n        }\n        // Return a normalized config object.\n        return { type: 'split-area', orientation, children, sizes };\n    }\n    /**\n     * Convert a normalized tab area config into a layout tree.\n     */\n    function realizeTabAreaConfig(config, renderer, document) {\n        // Create the tab bar for the layout node.\n        let tabBar = renderer.createTabBar(document);\n        // Hide each widget and add it to the tab bar.\n        for (const widget of config.widgets) {\n            widget.hide();\n            tabBar.addTab(widget.title);\n            Private.addAria(widget, tabBar);\n        }\n        // Set the current index of the tab bar.\n        tabBar.currentIndex = config.currentIndex;\n        // Return the new tab layout node.\n        return new TabLayoutNode(tabBar);\n    }\n    /**\n     * Convert a normalized split area config into a layout tree.\n     */\n    function realizeSplitAreaConfig(config, renderer, document) {\n        // Create the split layout node.\n        let node = new SplitLayoutNode(config.orientation);\n        // Add each child to the layout node.\n        config.children.forEach((child, i) => {\n            // Create the child data for the layout node.\n            let childNode = realizeAreaConfig(child, renderer, document);\n            let sizer = createSizer(config.sizes[i]);\n            let handle = renderer.createHandle();\n            // Add the child data to the layout node.\n            node.children.push(childNode);\n            node.handles.push(handle);\n            node.sizers.push(sizer);\n            // Update the parent for the child node.\n            childNode.parent = node;\n        });\n        // Synchronize the handle state for the layout node.\n        node.syncHandles();\n        // Normalize the sizes for the layout node.\n        node.normalizeSizes();\n        // Return the new layout node.\n        return node;\n    }\n})(Private$6 || (Private$6 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A widget which provides a flexible docking area for widgets.\n */\nclass DockPanel extends Widget {\n    /**\n     * Construct a new dock panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    constructor(options = {}) {\n        super();\n        this._drag = null;\n        this._tabsMovable = true;\n        this._tabsConstrained = false;\n        this._addButtonEnabled = false;\n        this._pressData = null;\n        this._layoutModified = new Signal(this);\n        this._addRequested = new Signal(this);\n        this.addClass('lm-DockPanel');\n        this._document = options.document || document;\n        this._mode = options.mode || 'multiple-document';\n        this._renderer = options.renderer || DockPanel.defaultRenderer;\n        this._edges = options.edges || Private$5.DEFAULT_EDGES;\n        if (options.tabsMovable !== undefined) {\n            this._tabsMovable = options.tabsMovable;\n        }\n        if (options.tabsConstrained !== undefined) {\n            this._tabsConstrained = options.tabsConstrained;\n        }\n        if (options.addButtonEnabled !== undefined) {\n            this._addButtonEnabled = options.addButtonEnabled;\n        }\n        // Toggle the CSS mode attribute.\n        this.dataset['mode'] = this._mode;\n        // Create the delegate renderer for the layout.\n        let renderer = {\n            createTabBar: () => this._createTabBar(),\n            createHandle: () => this._createHandle()\n        };\n        // Set up the dock layout for the panel.\n        this.layout = new DockLayout({\n            document: this._document,\n            renderer,\n            spacing: options.spacing,\n            hiddenMode: options.hiddenMode\n        });\n        // Set up the overlay drop indicator.\n        this.overlay = options.overlay || new DockPanel.Overlay();\n        this.node.appendChild(this.overlay.node);\n    }\n    /**\n     * Dispose of the resources held by the panel.\n     */\n    dispose() {\n        // Ensure the mouse is released.\n        this._releaseMouse();\n        // Hide the overlay.\n        this.overlay.hide(0);\n        // Cancel a drag if one is in progress.\n        if (this._drag) {\n            this._drag.dispose();\n        }\n        // Dispose of the base class.\n        super.dispose();\n    }\n    /**\n     * The method for hiding widgets.\n     */\n    get hiddenMode() {\n        return this.layout.hiddenMode;\n    }\n    /**\n     * Set the method for hiding widgets.\n     */\n    set hiddenMode(v) {\n        this.layout.hiddenMode = v;\n    }\n    /**\n     * A signal emitted when the layout configuration is modified.\n     *\n     * #### Notes\n     * This signal is emitted whenever the current layout configuration\n     * may have changed.\n     *\n     * This signal is emitted asynchronously in a collapsed fashion, so\n     * that multiple synchronous modifications results in only a single\n     * emit of the signal.\n     */\n    get layoutModified() {\n        return this._layoutModified;\n    }\n    /**\n     * A signal emitted when the add button on a tab bar is clicked.\n     *\n     */\n    get addRequested() {\n        return this._addRequested;\n    }\n    /**\n     * The renderer used by the dock panel.\n     */\n    get renderer() {\n        return this.layout.renderer;\n    }\n    /**\n     * Get the spacing between the widgets.\n     */\n    get spacing() {\n        return this.layout.spacing;\n    }\n    /**\n     * Set the spacing between the widgets.\n     */\n    set spacing(value) {\n        this.layout.spacing = value;\n    }\n    /**\n     * Get the mode for the dock panel.\n     */\n    get mode() {\n        return this._mode;\n    }\n    /**\n     * Set the mode for the dock panel.\n     *\n     * #### Notes\n     * Changing the mode is a destructive operation with respect to the\n     * panel's layout configuration. If layout state must be preserved,\n     * save the current layout config before changing the mode.\n     */\n    set mode(value) {\n        // Bail early if the mode does not change.\n        if (this._mode === value) {\n            return;\n        }\n        // Update the internal mode.\n        this._mode = value;\n        // Toggle the CSS mode attribute.\n        this.dataset['mode'] = value;\n        // Get the layout for the panel.\n        let layout = this.layout;\n        // Configure the layout for the specified mode.\n        switch (value) {\n            case 'multiple-document':\n                for (const tabBar of layout.tabBars()) {\n                    tabBar.show();\n                }\n                break;\n            case 'single-document':\n                layout.restoreLayout(Private$5.createSingleDocumentConfig(this));\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Whether the tabs can be dragged / moved at runtime.\n     */\n    get tabsMovable() {\n        return this._tabsMovable;\n    }\n    /**\n     * Enable / Disable draggable / movable tabs.\n     */\n    set tabsMovable(value) {\n        this._tabsMovable = value;\n        for (const tabBar of this.tabBars()) {\n            tabBar.tabsMovable = value;\n        }\n    }\n    /**\n     * Whether the tabs are constrained to their source dock panel\n     */\n    get tabsConstrained() {\n        return this._tabsConstrained;\n    }\n    /**\n     * Constrain/Allow tabs to be dragged outside of this dock panel\n     */\n    set tabsConstrained(value) {\n        this._tabsConstrained = value;\n    }\n    /**\n     * Whether the add buttons for each tab bar are enabled.\n     */\n    get addButtonEnabled() {\n        return this._addButtonEnabled;\n    }\n    /**\n     * Set whether the add buttons for each tab bar are enabled.\n     */\n    set addButtonEnabled(value) {\n        this._addButtonEnabled = value;\n        for (const tabBar of this.tabBars()) {\n            tabBar.addButtonEnabled = value;\n        }\n    }\n    /**\n     * Whether the dock panel is empty.\n     */\n    get isEmpty() {\n        return this.layout.isEmpty;\n    }\n    /**\n     * Create an iterator over the user widgets in the panel.\n     *\n     * @returns A new iterator over the user widgets in the panel.\n     *\n     * #### Notes\n     * This iterator does not include the generated tab bars.\n     */\n    *widgets() {\n        yield* this.layout.widgets();\n    }\n    /**\n     * Create an iterator over the selected widgets in the panel.\n     *\n     * @returns A new iterator over the selected user widgets.\n     *\n     * #### Notes\n     * This iterator yields the widgets corresponding to the current tab\n     * of each tab bar in the panel.\n     */\n    *selectedWidgets() {\n        yield* this.layout.selectedWidgets();\n    }\n    /**\n     * Create an iterator over the tab bars in the panel.\n     *\n     * @returns A new iterator over the tab bars in the panel.\n     *\n     * #### Notes\n     * This iterator does not include the user widgets.\n     */\n    *tabBars() {\n        yield* this.layout.tabBars();\n    }\n    /**\n     * Create an iterator over the handles in the panel.\n     *\n     * @returns A new iterator over the handles in the panel.\n     */\n    *handles() {\n        yield* this.layout.handles();\n    }\n    /**\n     * Select a specific widget in the dock panel.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will make the widget the current widget in its tab area.\n     */\n    selectWidget(widget) {\n        // Find the tab bar which contains the widget.\n        let tabBar = find(this.tabBars(), bar => {\n            return bar.titles.indexOf(widget.title) !== -1;\n        });\n        // Throw an error if no tab bar is found.\n        if (!tabBar) {\n            throw new Error('Widget is not contained in the dock panel.');\n        }\n        // Ensure the widget is the current widget.\n        tabBar.currentTitle = widget.title;\n    }\n    /**\n     * Activate a specified widget in the dock panel.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * This will select and activate the given widget.\n     */\n    activateWidget(widget) {\n        this.selectWidget(widget);\n        widget.activate();\n    }\n    /**\n     * Save the current layout configuration of the dock panel.\n     *\n     * @returns A new config object for the current layout state.\n     *\n     * #### Notes\n     * The return value can be provided to the `restoreLayout` method\n     * in order to restore the layout to its current configuration.\n     */\n    saveLayout() {\n        return this.layout.saveLayout();\n    }\n    /**\n     * Restore the layout to a previously saved configuration.\n     *\n     * @param config - The layout configuration to restore.\n     *\n     * #### Notes\n     * Widgets which currently belong to the layout but which are not\n     * contained in the config will be unparented.\n     *\n     * The dock panel automatically reverts to `'multiple-document'`\n     * mode when a layout config is restored.\n     */\n    restoreLayout(config) {\n        // Reset the mode.\n        this._mode = 'multiple-document';\n        // Restore the layout.\n        this.layout.restoreLayout(config);\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (Platform.IS_EDGE || Platform.IS_IE) {\n            MessageLoop.flush();\n        }\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Add a widget to the dock panel.\n     *\n     * @param widget - The widget to add to the dock panel.\n     *\n     * @param options - The additional options for adding the widget.\n     *\n     * #### Notes\n     * If the panel is in single document mode, the options are ignored\n     * and the widget is always added as tab in the hidden tab bar.\n     */\n    addWidget(widget, options = {}) {\n        // Add the widget to the layout.\n        if (this._mode === 'single-document') {\n            this.layout.addWidget(widget);\n        }\n        else {\n            this.layout.addWidget(widget, options);\n        }\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     */\n    processMessage(msg) {\n        if (msg.type === 'layout-modified') {\n            this._layoutModified.emit(undefined);\n        }\n        else {\n            super.processMessage(msg);\n        }\n    }\n    /**\n     * Handle the DOM events for the dock panel.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the panel's DOM node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            case 'pointerdown':\n                this._evtPointerDown(event);\n                break;\n            case 'pointermove':\n                this._evtPointerMove(event);\n                break;\n            case 'pointerup':\n                this._evtPointerUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('lm-dragenter', this);\n        this.node.addEventListener('lm-dragleave', this);\n        this.node.addEventListener('lm-dragover', this);\n        this.node.addEventListener('lm-drop', this);\n        this.node.addEventListener('pointerdown', this);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('lm-dragenter', this);\n        this.node.removeEventListener('lm-dragleave', this);\n        this.node.removeEventListener('lm-dragover', this);\n        this.node.removeEventListener('lm-drop', this);\n        this.node.removeEventListener('pointerdown', this);\n        this._releaseMouse();\n    }\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    onChildAdded(msg) {\n        // Ignore the generated tab bars.\n        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {\n            return;\n        }\n        // Add the widget class to the child.\n        msg.child.addClass('lm-DockPanel-widget');\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    onChildRemoved(msg) {\n        // Ignore the generated tab bars.\n        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {\n            return;\n        }\n        // Remove the widget class from the child.\n        msg.child.removeClass('lm-DockPanel-widget');\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the dock panel.\n     */\n    _evtDragEnter(event) {\n        // If the factory mime type is present, mark the event as\n        // handled in order to get the rest of the drag events.\n        if (event.mimeData.hasData('application/vnd.lumino.widget-factory')) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the dock panel.\n     */\n    _evtDragLeave(event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        if (this._tabsConstrained && event.source !== this)\n            return;\n        event.stopPropagation();\n        // The new target might be a descendant, so we might still handle the drop.\n        // Hide asynchronously so that if a lm-dragover event bubbles up to us, the\n        // hide is cancelled by the lm-dragover handler's show overlay logic.\n        this.overlay.hide(1);\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the dock panel.\n     */\n    _evtDragOver(event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        // Show the drop indicator overlay and update the drop\n        // action based on the drop target zone under the mouse.\n        if ((this._tabsConstrained && event.source !== this) ||\n            this._showOverlay(event.clientX, event.clientY) === 'invalid') {\n            event.dropAction = 'none';\n        }\n        else {\n            event.stopPropagation();\n            event.dropAction = event.proposedAction;\n        }\n    }\n    /**\n     * Handle the `'lm-drop'` event for the dock panel.\n     */\n    _evtDrop(event) {\n        // Mark the event as handled.\n        event.preventDefault();\n        // Hide the drop indicator overlay.\n        this.overlay.hide(0);\n        // Bail if the proposed action is to do nothing.\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Find the drop target under the mouse.\n        let { clientX, clientY } = event;\n        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);\n        // Bail if the drop zone is invalid.\n        if ((this._tabsConstrained && event.source !== this) ||\n            zone === 'invalid') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the factory mime type has invalid data.\n        let mimeData = event.mimeData;\n        let factory = mimeData.getData('application/vnd.lumino.widget-factory');\n        if (typeof factory !== 'function') {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the factory does not produce a widget.\n        let widget = factory();\n        if (!(widget instanceof Widget)) {\n            event.dropAction = 'none';\n            return;\n        }\n        // Bail if the widget is an ancestor of the dock panel.\n        if (widget.contains(this)) {\n            event.dropAction = 'none';\n            return;\n        }\n        // Find the reference widget for the drop target.\n        let ref = target ? Private$5.getDropRef(target.tabBar) : null;\n        // Add the widget according to the indicated drop zone.\n        switch (zone) {\n            case 'root-all':\n                this.addWidget(widget);\n                break;\n            case 'root-top':\n                this.addWidget(widget, { mode: 'split-top' });\n                break;\n            case 'root-left':\n                this.addWidget(widget, { mode: 'split-left' });\n                break;\n            case 'root-right':\n                this.addWidget(widget, { mode: 'split-right' });\n                break;\n            case 'root-bottom':\n                this.addWidget(widget, { mode: 'split-bottom' });\n                break;\n            case 'widget-all':\n                this.addWidget(widget, { mode: 'tab-after', ref });\n                break;\n            case 'widget-top':\n                this.addWidget(widget, { mode: 'split-top', ref });\n                break;\n            case 'widget-left':\n                this.addWidget(widget, { mode: 'split-left', ref });\n                break;\n            case 'widget-right':\n                this.addWidget(widget, { mode: 'split-right', ref });\n                break;\n            case 'widget-bottom':\n                this.addWidget(widget, { mode: 'split-bottom', ref });\n                break;\n            case 'widget-tab':\n                this.addWidget(widget, { mode: 'tab-after', ref });\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Accept the proposed drop action.\n        event.dropAction = event.proposedAction;\n        // Stop propagation if we have not bailed so far.\n        event.stopPropagation();\n        // Activate the dropped widget.\n        this.activateWidget(widget);\n    }\n    /**\n     * Handle the `'keydown'` event for the dock panel.\n     */\n    _evtKeyDown(event) {\n        // Stop input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            // Finalize the mouse release.\n            this._releaseMouse();\n            // Schedule an emit of the layout modified signal.\n            MessageLoop.postMessage(this, Private$5.LayoutModified);\n        }\n    }\n    /**\n     * Handle the `'pointerdown'` event for the dock panel.\n     */\n    _evtPointerDown(event) {\n        // Do nothing if the left mouse button is not pressed.\n        if (event.button !== 0) {\n            return;\n        }\n        // Find the handle which contains the mouse target, if any.\n        let layout = this.layout;\n        let target = event.target;\n        let handle = find(layout.handles(), handle => handle.contains(target));\n        if (!handle) {\n            return;\n        }\n        // Stop the event when a handle is pressed.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        this._document.addEventListener('keydown', this, true);\n        this._document.addEventListener('pointerup', this, true);\n        this._document.addEventListener('pointermove', this, true);\n        this._document.addEventListener('contextmenu', this, true);\n        // Compute the offset deltas for the handle press.\n        let rect = handle.getBoundingClientRect();\n        let deltaX = event.clientX - rect.left;\n        let deltaY = event.clientY - rect.top;\n        // Override the cursor and store the press data.\n        let style = window.getComputedStyle(handle);\n        let override = Drag.overrideCursor(style.cursor, this._document);\n        this._pressData = { handle, deltaX, deltaY, override };\n    }\n    /**\n     * Handle the `'pointermove'` event for the dock panel.\n     */\n    _evtPointerMove(event) {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Stop the event when dragging a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Compute the desired offset position for the handle.\n        let rect = this.node.getBoundingClientRect();\n        let xPos = event.clientX - rect.left - this._pressData.deltaX;\n        let yPos = event.clientY - rect.top - this._pressData.deltaY;\n        // Set the handle as close to the desired position as possible.\n        let layout = this.layout;\n        layout.moveHandle(this._pressData.handle, xPos, yPos);\n    }\n    /**\n     * Handle the `'pointerup'` event for the dock panel.\n     */\n    _evtPointerUp(event) {\n        // Do nothing if the left mouse button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event when releasing a handle.\n        event.preventDefault();\n        event.stopPropagation();\n        // Finalize the mouse release.\n        this._releaseMouse();\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Release the mouse grab for the dock panel.\n     */\n    _releaseMouse() {\n        // Bail early if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the override cursor.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Remove the extra document listeners.\n        this._document.removeEventListener('keydown', this, true);\n        this._document.removeEventListener('pointerup', this, true);\n        this._document.removeEventListener('pointermove', this, true);\n        this._document.removeEventListener('contextmenu', this, true);\n    }\n    /**\n     * Show the overlay indicator at the given client position.\n     *\n     * Returns the drop zone at the specified client position.\n     *\n     * #### Notes\n     * If the position is not over a valid zone, the overlay is hidden.\n     */\n    _showOverlay(clientX, clientY) {\n        // Find the dock target for the given client position.\n        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);\n        // If the drop zone is invalid, hide the overlay and bail.\n        if (zone === 'invalid') {\n            this.overlay.hide(100);\n            return zone;\n        }\n        // Setup the variables needed to compute the overlay geometry.\n        let top;\n        let left;\n        let right;\n        let bottom;\n        let box = ElementExt.boxSizing(this.node); // TODO cache this?\n        let rect = this.node.getBoundingClientRect();\n        // Compute the overlay geometry based on the dock zone.\n        switch (zone) {\n            case 'root-all':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-top':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = rect.height * Private$5.GOLDEN_RATIO;\n                break;\n            case 'root-left':\n                top = box.paddingTop;\n                left = box.paddingLeft;\n                right = rect.width * Private$5.GOLDEN_RATIO;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-right':\n                top = box.paddingTop;\n                left = rect.width * Private$5.GOLDEN_RATIO;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'root-bottom':\n                top = rect.height * Private$5.GOLDEN_RATIO;\n                left = box.paddingLeft;\n                right = box.paddingRight;\n                bottom = box.paddingBottom;\n                break;\n            case 'widget-all':\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-top':\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom + target.height / 2;\n                break;\n            case 'widget-left':\n                top = target.top;\n                left = target.left;\n                right = target.right + target.width / 2;\n                bottom = target.bottom;\n                break;\n            case 'widget-right':\n                top = target.top;\n                left = target.left + target.width / 2;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-bottom':\n                top = target.top + target.height / 2;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom;\n                break;\n            case 'widget-tab': {\n                const tabHeight = target.tabBar.node.getBoundingClientRect().height;\n                top = target.top;\n                left = target.left;\n                right = target.right;\n                bottom = target.bottom + target.height - tabHeight;\n                break;\n            }\n            default:\n                throw 'unreachable';\n        }\n        // Show the overlay with the computed geometry.\n        this.overlay.show({ top, left, right, bottom });\n        // Finally, return the computed drop zone.\n        return zone;\n    }\n    /**\n     * Create a new tab bar for use by the panel.\n     */\n    _createTabBar() {\n        // Create the tab bar.\n        let tabBar = this._renderer.createTabBar(this._document);\n        // Set the generated tab bar property for the tab bar.\n        Private$5.isGeneratedTabBarProperty.set(tabBar, true);\n        // Hide the tab bar when in single document mode.\n        if (this._mode === 'single-document') {\n            tabBar.hide();\n        }\n        // Enforce necessary tab bar behavior.\n        // TODO do we really want to enforce *all* of these?\n        tabBar.tabsMovable = this._tabsMovable;\n        tabBar.allowDeselect = false;\n        tabBar.addButtonEnabled = this._addButtonEnabled;\n        tabBar.removeBehavior = 'select-previous-tab';\n        tabBar.insertBehavior = 'select-tab-if-needed';\n        // Connect the signal handlers for the tab bar.\n        tabBar.tabMoved.connect(this._onTabMoved, this);\n        tabBar.currentChanged.connect(this._onCurrentChanged, this);\n        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);\n        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);\n        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);\n        tabBar.addRequested.connect(this._onTabAddRequested, this);\n        // Return the initialized tab bar.\n        return tabBar;\n    }\n    /**\n     * Create a new handle for use by the panel.\n     */\n    _createHandle() {\n        return this._renderer.createHandle();\n    }\n    /**\n     * Handle the `tabMoved` signal from a tab bar.\n     */\n    _onTabMoved() {\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Handle the `currentChanged` signal from a tab bar.\n     */\n    _onCurrentChanged(sender, args) {\n        // Extract the previous and current title from the args.\n        let { previousTitle, currentTitle } = args;\n        // Hide the previous widget.\n        if (previousTitle) {\n            previousTitle.owner.hide();\n        }\n        // Show the current widget.\n        if (currentTitle) {\n            currentTitle.owner.show();\n        }\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (Platform.IS_EDGE || Platform.IS_IE) {\n            MessageLoop.flush();\n        }\n        // Schedule an emit of the layout modified signal.\n        MessageLoop.postMessage(this, Private$5.LayoutModified);\n    }\n    /**\n     * Handle the `addRequested` signal from a tab bar.\n     */\n    _onTabAddRequested(sender) {\n        this._addRequested.emit(sender);\n    }\n    /**\n     * Handle the `tabActivateRequested` signal from a tab bar.\n     */\n    _onTabActivateRequested(sender, args) {\n        args.title.owner.activate();\n    }\n    /**\n     * Handle the `tabCloseRequested` signal from a tab bar.\n     */\n    _onTabCloseRequested(sender, args) {\n        args.title.owner.close();\n    }\n    /**\n     * Handle the `tabDetachRequested` signal from a tab bar.\n     */\n    _onTabDetachRequested(sender, args) {\n        // Do nothing if a drag is already in progress.\n        if (this._drag) {\n            return;\n        }\n        // Release the tab bar's hold on the mouse.\n        sender.releaseMouse();\n        // Extract the data from the args.\n        let { title, tab, clientX, clientY, offset } = args;\n        // Setup the mime data for the drag operation.\n        let mimeData = new MimeData();\n        let factory = () => title.owner;\n        mimeData.setData('application/vnd.lumino.widget-factory', factory);\n        // Create the drag image for the drag operation.\n        let dragImage = tab.cloneNode(true);\n        if (offset) {\n            dragImage.style.top = `-${offset.y}px`;\n            dragImage.style.left = `-${offset.x}px`;\n        }\n        // Create the drag object to manage the drag-drop operation.\n        this._drag = new Drag({\n            document: this._document,\n            mimeData,\n            dragImage,\n            proposedAction: 'move',\n            supportedActions: 'move',\n            source: this\n        });\n        // Hide the tab node in the original tab.\n        tab.classList.add('lm-mod-hidden');\n        let cleanup = () => {\n            this._drag = null;\n            tab.classList.remove('lm-mod-hidden');\n        };\n        // Start the drag operation and cleanup when done.\n        this._drag.start(clientX, clientY).then(cleanup);\n    }\n}\n/**\n * The namespace for the `DockPanel` class statics.\n */\n(function (DockPanel) {\n    /**\n     * A concrete implementation of `IOverlay`.\n     *\n     * This is the default overlay implementation for a dock panel.\n     */\n    class Overlay {\n        /**\n         * Construct a new overlay.\n         */\n        constructor() {\n            this._timer = -1;\n            this._hidden = true;\n            this.node = document.createElement('div');\n            this.node.classList.add('lm-DockPanel-overlay');\n            this.node.classList.add('lm-mod-hidden');\n            this.node.style.position = 'absolute';\n            this.node.style.contain = 'strict';\n        }\n        /**\n         * Show the overlay using the given overlay geometry.\n         *\n         * @param geo - The desired geometry for the overlay.\n         */\n        show(geo) {\n            // Update the position of the overlay.\n            let style = this.node.style;\n            style.top = `${geo.top}px`;\n            style.left = `${geo.left}px`;\n            style.right = `${geo.right}px`;\n            style.bottom = `${geo.bottom}px`;\n            // Clear any pending hide timer.\n            clearTimeout(this._timer);\n            this._timer = -1;\n            // If the overlay is already visible, we're done.\n            if (!this._hidden) {\n                return;\n            }\n            // Clear the hidden flag.\n            this._hidden = false;\n            // Finally, show the overlay.\n            this.node.classList.remove('lm-mod-hidden');\n        }\n        /**\n         * Hide the overlay node.\n         *\n         * @param delay - The delay (in ms) before hiding the overlay.\n         *   A delay value <= 0 will hide the overlay immediately.\n         */\n        hide(delay) {\n            // Do nothing if the overlay is already hidden.\n            if (this._hidden) {\n                return;\n            }\n            // Hide immediately if the delay is <= 0.\n            if (delay <= 0) {\n                clearTimeout(this._timer);\n                this._timer = -1;\n                this._hidden = true;\n                this.node.classList.add('lm-mod-hidden');\n                return;\n            }\n            // Do nothing if a hide is already pending.\n            if (this._timer !== -1) {\n                return;\n            }\n            // Otherwise setup the hide timer.\n            this._timer = window.setTimeout(() => {\n                this._timer = -1;\n                this._hidden = true;\n                this.node.classList.add('lm-mod-hidden');\n            }, delay);\n        }\n    }\n    DockPanel.Overlay = Overlay;\n    /**\n     * The default implementation of `IRenderer`.\n     */\n    class Renderer {\n        /**\n         * Create a new tab bar for use with a dock panel.\n         *\n         * @returns A new tab bar for a dock panel.\n         */\n        createTabBar(document) {\n            let bar = new TabBar({ document });\n            bar.addClass('lm-DockPanel-tabBar');\n            return bar;\n        }\n        /**\n         * Create a new handle node for use with a dock panel.\n         *\n         * @returns A new handle node for a dock panel.\n         */\n        createHandle() {\n            let handle = document.createElement('div');\n            handle.className = 'lm-DockPanel-handle';\n            return handle;\n        }\n    }\n    DockPanel.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    DockPanel.defaultRenderer = new Renderer();\n})(DockPanel || (DockPanel = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$5;\n(function (Private) {\n    /**\n     * A fraction used for sizing root panels; ~= `1 / golden_ratio`.\n     */\n    Private.GOLDEN_RATIO = 0.618;\n    /**\n     * The default sizes for the edge drop zones, in pixels.\n     */\n    Private.DEFAULT_EDGES = {\n        /**\n         * The size of the top edge dock zone for the root panel, in pixels.\n         * This is different from the others to distinguish between the top\n         * tab bar and the top root zone.\n         */\n        top: 12,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        right: 40,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        bottom: 40,\n        /**\n         * The size of the edge dock zone for the root panel, in pixels.\n         */\n        left: 40\n    };\n    /**\n     * A singleton `'layout-modified'` conflatable message.\n     */\n    Private.LayoutModified = new ConflatableMessage('layout-modified');\n    /**\n     * An attached property used to track generated tab bars.\n     */\n    Private.isGeneratedTabBarProperty = new AttachedProperty({\n        name: 'isGeneratedTabBar',\n        create: () => false\n    });\n    /**\n     * Create a single document config for the widgets in a dock panel.\n     */\n    function createSingleDocumentConfig(panel) {\n        // Return an empty config if the panel is empty.\n        if (panel.isEmpty) {\n            return { main: null };\n        }\n        // Get a flat array of the widgets in the panel.\n        let widgets = Array.from(panel.widgets());\n        // Get the first selected widget in the panel.\n        let selected = panel.selectedWidgets().next().value;\n        // Compute the current index for the new config.\n        let currentIndex = selected ? widgets.indexOf(selected) : -1;\n        // Return the single document config.\n        return { main: { type: 'tab-area', widgets, currentIndex } };\n    }\n    Private.createSingleDocumentConfig = createSingleDocumentConfig;\n    /**\n     * Find the drop target at the given client position.\n     */\n    function findDropTarget(panel, clientX, clientY, edges) {\n        // Bail if the mouse is not over the dock panel.\n        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {\n            return { zone: 'invalid', target: null };\n        }\n        // Look up the layout for the panel.\n        let layout = panel.layout;\n        // If the layout is empty, indicate the entire root drop zone.\n        if (layout.isEmpty) {\n            return { zone: 'root-all', target: null };\n        }\n        // Test the edge zones when in multiple document mode.\n        if (panel.mode === 'multiple-document') {\n            // Get the client rect for the dock panel.\n            let panelRect = panel.node.getBoundingClientRect();\n            // Compute the distance to each edge of the panel.\n            let pl = clientX - panelRect.left + 1;\n            let pt = clientY - panelRect.top + 1;\n            let pr = panelRect.right - clientX;\n            let pb = panelRect.bottom - clientY;\n            // Find the minimum distance to an edge.\n            let pd = Math.min(pt, pr, pb, pl);\n            // Return a root zone if the mouse is within an edge.\n            switch (pd) {\n                case pt:\n                    if (pt < edges.top) {\n                        return { zone: 'root-top', target: null };\n                    }\n                    break;\n                case pr:\n                    if (pr < edges.right) {\n                        return { zone: 'root-right', target: null };\n                    }\n                    break;\n                case pb:\n                    if (pb < edges.bottom) {\n                        return { zone: 'root-bottom', target: null };\n                    }\n                    break;\n                case pl:\n                    if (pl < edges.left) {\n                        return { zone: 'root-left', target: null };\n                    }\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n        }\n        // Hit test the dock layout at the given client position.\n        let target = layout.hitTestTabAreas(clientX, clientY);\n        // Bail if no target area was found.\n        if (!target) {\n            return { zone: 'invalid', target: null };\n        }\n        // Return the whole tab area when in single document mode.\n        if (panel.mode === 'single-document') {\n            return { zone: 'widget-all', target };\n        }\n        // Compute the distance to each edge of the tab area.\n        let al = target.x - target.left + 1;\n        let at = target.y - target.top + 1;\n        let ar = target.left + target.width - target.x;\n        let ab = target.top + target.height - target.y;\n        const tabHeight = target.tabBar.node.getBoundingClientRect().height;\n        if (at < tabHeight) {\n            return { zone: 'widget-tab', target };\n        }\n        // Get the X and Y edge sizes for the area.\n        let rx = Math.round(target.width / 3);\n        let ry = Math.round(target.height / 3);\n        // If the mouse is not within an edge, indicate the entire area.\n        if (al > rx && ar > rx && at > ry && ab > ry) {\n            return { zone: 'widget-all', target };\n        }\n        // Scale the distances by the slenderness ratio.\n        al /= rx;\n        at /= ry;\n        ar /= rx;\n        ab /= ry;\n        // Find the minimum distance to the area edge.\n        let ad = Math.min(al, at, ar, ab);\n        // Find the widget zone for the area edge.\n        let zone;\n        switch (ad) {\n            case al:\n                zone = 'widget-left';\n                break;\n            case at:\n                zone = 'widget-top';\n                break;\n            case ar:\n                zone = 'widget-right';\n                break;\n            case ab:\n                zone = 'widget-bottom';\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Return the final drop target.\n        return { zone, target };\n    }\n    Private.findDropTarget = findDropTarget;\n    /**\n     * Get the drop reference widget for a tab bar.\n     */\n    function getDropRef(tabBar) {\n        if (tabBar.titles.length === 0) {\n            return null;\n        }\n        if (tabBar.currentTitle) {\n            return tabBar.currentTitle.owner;\n        }\n        return tabBar.titles[tabBar.titles.length - 1].owner;\n    }\n    Private.getDropRef = getDropRef;\n})(Private$5 || (Private$5 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A class which tracks focus among a set of widgets.\n *\n * This class is useful when code needs to keep track of the most\n * recently focused widget(s) among a set of related widgets.\n */\nclass FocusTracker {\n    constructor() {\n        this._counter = 0;\n        this._widgets = [];\n        this._activeWidget = null;\n        this._currentWidget = null;\n        this._numbers = new Map();\n        this._nodes = new Map();\n        this._activeChanged = new Signal(this);\n        this._currentChanged = new Signal(this);\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        // Do nothing if the tracker is already disposed.\n        if (this._counter < 0) {\n            return;\n        }\n        // Mark the tracker as disposed.\n        this._counter = -1;\n        // Clear the connections for the tracker.\n        Signal.clearData(this);\n        // Remove all event listeners.\n        for (const widget of this._widgets) {\n            widget.node.removeEventListener('focus', this, true);\n            widget.node.removeEventListener('blur', this, true);\n        }\n        // Clear the internal data structures.\n        this._activeWidget = null;\n        this._currentWidget = null;\n        this._nodes.clear();\n        this._numbers.clear();\n        this._widgets.length = 0;\n    }\n    /**\n     * A signal emitted when the current widget has changed.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * A signal emitted when the active widget has changed.\n     */\n    get activeChanged() {\n        return this._activeChanged;\n    }\n    /**\n     * A flag indicating whether the tracker is disposed.\n     */\n    get isDisposed() {\n        return this._counter < 0;\n    }\n    /**\n     * The current widget in the tracker.\n     *\n     * #### Notes\n     * The current widget is the widget among the tracked widgets which\n     * has the *descendant node* which has most recently been focused.\n     *\n     * The current widget will not be updated if the node loses focus. It\n     * will only be updated when a different tracked widget gains focus.\n     *\n     * If the current widget is removed from the tracker, the previous\n     * current widget will be restored.\n     *\n     * This behavior is intended to follow a user's conceptual model of\n     * a semantically \"current\" widget, where the \"last thing of type X\"\n     * to be interacted with is the \"current instance of X\", regardless\n     * of whether that instance still has focus.\n     */\n    get currentWidget() {\n        return this._currentWidget;\n    }\n    /**\n     * The active widget in the tracker.\n     *\n     * #### Notes\n     * The active widget is the widget among the tracked widgets which\n     * has the *descendant node* which is currently focused.\n     */\n    get activeWidget() {\n        return this._activeWidget;\n    }\n    /**\n     * A read only array of the widgets being tracked.\n     */\n    get widgets() {\n        return this._widgets;\n    }\n    /**\n     * Get the focus number for a particular widget in the tracker.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The focus number for the given widget, or `-1` if the\n     *   widget has not had focus since being added to the tracker, or\n     *   is not contained by the tracker.\n     *\n     * #### Notes\n     * The focus number indicates the relative order in which the widgets\n     * have gained focus. A widget with a larger number has gained focus\n     * more recently than a widget with a smaller number.\n     *\n     * The `currentWidget` will always have the largest focus number.\n     *\n     * All widgets start with a focus number of `-1`, which indicates that\n     * the widget has not been focused since being added to the tracker.\n     */\n    focusNumber(widget) {\n        let n = this._numbers.get(widget);\n        return n === undefined ? -1 : n;\n    }\n    /**\n     * Test whether the focus tracker contains a given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns `true` if the widget is tracked, `false` otherwise.\n     */\n    has(widget) {\n        return this._numbers.has(widget);\n    }\n    /**\n     * Add a widget to the focus tracker.\n     *\n     * @param widget - The widget of interest.\n     *\n     * #### Notes\n     * A widget will be automatically removed from the tracker if it\n     * is disposed after being added.\n     *\n     * If the widget is already tracked, this is a no-op.\n     */\n    add(widget) {\n        // Do nothing if the widget is already tracked.\n        if (this._numbers.has(widget)) {\n            return;\n        }\n        // Test whether the widget has focus.\n        let focused = widget.node.contains(document.activeElement);\n        // Set up the initial focus number.\n        let n = focused ? this._counter++ : -1;\n        // Add the widget to the internal data structures.\n        this._widgets.push(widget);\n        this._numbers.set(widget, n);\n        this._nodes.set(widget.node, widget);\n        // Set up the event listeners. The capturing phase must be used\n        // since the 'focus' and 'blur' events don't bubble and Firefox\n        // doesn't support the 'focusin' or 'focusout' events.\n        widget.node.addEventListener('focus', this, true);\n        widget.node.addEventListener('blur', this, true);\n        // Connect the disposed signal handler.\n        widget.disposed.connect(this._onWidgetDisposed, this);\n        // Set the current and active widgets if needed.\n        if (focused) {\n            this._setWidgets(widget, widget);\n        }\n    }\n    /**\n     * Remove a widget from the focus tracker.\n     *\n     * #### Notes\n     * If the widget is the `currentWidget`, the previous current widget\n     * will become the new `currentWidget`.\n     *\n     * A widget will be automatically removed from the tracker if it\n     * is disposed after being added.\n     *\n     * If the widget is not tracked, this is a no-op.\n     */\n    remove(widget) {\n        // Bail early if the widget is not tracked.\n        if (!this._numbers.has(widget)) {\n            return;\n        }\n        // Disconnect the disposed signal handler.\n        widget.disposed.disconnect(this._onWidgetDisposed, this);\n        // Remove the event listeners.\n        widget.node.removeEventListener('focus', this, true);\n        widget.node.removeEventListener('blur', this, true);\n        // Remove the widget from the internal data structures.\n        ArrayExt.removeFirstOf(this._widgets, widget);\n        this._nodes.delete(widget.node);\n        this._numbers.delete(widget);\n        // Bail early if the widget is not the current widget.\n        if (this._currentWidget !== widget) {\n            return;\n        }\n        // Filter the widgets for those which have had focus.\n        let valid = this._widgets.filter(w => this._numbers.get(w) !== -1);\n        // Get the valid widget with the max focus number.\n        let previous = max(valid, (first, second) => {\n            let a = this._numbers.get(first);\n            let b = this._numbers.get(second);\n            return a - b;\n        }) || null;\n        // Set the current and active widgets.\n        this._setWidgets(previous, null);\n    }\n    /**\n     * Handle the DOM events for the focus tracker.\n     *\n     * @param event - The DOM event sent to the panel.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the tracked nodes. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'focus':\n                this._evtFocus(event);\n                break;\n            case 'blur':\n                this._evtBlur(event);\n                break;\n        }\n    }\n    /**\n     * Set the current and active widgets for the tracker.\n     */\n    _setWidgets(current, active) {\n        // Swap the current widget.\n        let oldCurrent = this._currentWidget;\n        this._currentWidget = current;\n        // Swap the active widget.\n        let oldActive = this._activeWidget;\n        this._activeWidget = active;\n        // Emit the `currentChanged` signal if needed.\n        if (oldCurrent !== current) {\n            this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });\n        }\n        // Emit the `activeChanged` signal if needed.\n        if (oldActive !== active) {\n            this._activeChanged.emit({ oldValue: oldActive, newValue: active });\n        }\n    }\n    /**\n     * Handle the `'focus'` event for a tracked widget.\n     */\n    _evtFocus(event) {\n        // Find the widget which gained focus, which is known to exist.\n        let widget = this._nodes.get(event.currentTarget);\n        // Update the focus number if necessary.\n        if (widget !== this._currentWidget) {\n            this._numbers.set(widget, this._counter++);\n        }\n        // Set the current and active widgets.\n        this._setWidgets(widget, widget);\n    }\n    /**\n     * Handle the `'blur'` event for a tracked widget.\n     */\n    _evtBlur(event) {\n        // Find the widget which lost focus, which is known to exist.\n        let widget = this._nodes.get(event.currentTarget);\n        // Get the node which being focused after this blur.\n        let focusTarget = event.relatedTarget;\n        // If no other node is being focused, clear the active widget.\n        if (!focusTarget) {\n            this._setWidgets(this._currentWidget, null);\n            return;\n        }\n        // Bail if the focus widget is not changing.\n        if (widget.node.contains(focusTarget)) {\n            return;\n        }\n        // If no tracked widget is being focused, clear the active widget.\n        if (!find(this._widgets, w => w.node.contains(focusTarget))) {\n            this._setWidgets(this._currentWidget, null);\n            return;\n        }\n    }\n    /**\n     * Handle the `disposed` signal for a tracked widget.\n     */\n    _onWidgetDisposed(sender) {\n        this.remove(sender);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A layout which arranges its widgets in a grid.\n */\nclass GridLayout extends Layout {\n    /**\n     * Construct a new grid layout.\n     *\n     * @param options - The options for initializing the layout.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._dirty = false;\n        this._rowSpacing = 4;\n        this._columnSpacing = 4;\n        this._items = [];\n        this._rowStarts = [];\n        this._columnStarts = [];\n        this._rowSizers = [new BoxSizer()];\n        this._columnSizers = [new BoxSizer()];\n        this._box = null;\n        if (options.rowCount !== undefined) {\n            Private$4.reallocSizers(this._rowSizers, options.rowCount);\n        }\n        if (options.columnCount !== undefined) {\n            Private$4.reallocSizers(this._columnSizers, options.columnCount);\n        }\n        if (options.rowSpacing !== undefined) {\n            this._rowSpacing = Private$4.clampValue(options.rowSpacing);\n        }\n        if (options.columnSpacing !== undefined) {\n            this._columnSpacing = Private$4.clampValue(options.columnSpacing);\n        }\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        // Dispose of the widgets and layout items.\n        for (const item of this._items) {\n            let widget = item.widget;\n            item.dispose();\n            widget.dispose();\n        }\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        this._rowStarts.length = 0;\n        this._rowSizers.length = 0;\n        this._columnStarts.length = 0;\n        this._columnSizers.length = 0;\n        // Dispose of the rest of the layout.\n        super.dispose();\n    }\n    /**\n     * Get the number of rows in the layout.\n     */\n    get rowCount() {\n        return this._rowSizers.length;\n    }\n    /**\n     * Set the number of rows in the layout.\n     *\n     * #### Notes\n     * The minimum row count is `1`.\n     */\n    set rowCount(value) {\n        // Do nothing if the row count does not change.\n        if (value === this.rowCount) {\n            return;\n        }\n        // Reallocate the row sizers.\n        Private$4.reallocSizers(this._rowSizers, value);\n        // Schedule a fit of the parent.\n        if (this.parent) {\n            this.parent.fit();\n        }\n    }\n    /**\n     * Get the number of columns in the layout.\n     */\n    get columnCount() {\n        return this._columnSizers.length;\n    }\n    /**\n     * Set the number of columns in the layout.\n     *\n     * #### Notes\n     * The minimum column count is `1`.\n     */\n    set columnCount(value) {\n        // Do nothing if the column count does not change.\n        if (value === this.columnCount) {\n            return;\n        }\n        // Reallocate the column sizers.\n        Private$4.reallocSizers(this._columnSizers, value);\n        // Schedule a fit of the parent.\n        if (this.parent) {\n            this.parent.fit();\n        }\n    }\n    /**\n     * Get the row spacing for the layout.\n     */\n    get rowSpacing() {\n        return this._rowSpacing;\n    }\n    /**\n     * Set the row spacing for the layout.\n     */\n    set rowSpacing(value) {\n        // Clamp the spacing to the allowed range.\n        value = Private$4.clampValue(value);\n        // Bail if the spacing does not change\n        if (this._rowSpacing === value) {\n            return;\n        }\n        // Update the internal spacing.\n        this._rowSpacing = value;\n        // Schedule a fit of the parent.\n        if (this.parent) {\n            this.parent.fit();\n        }\n    }\n    /**\n     * Get the column spacing for the layout.\n     */\n    get columnSpacing() {\n        return this._columnSpacing;\n    }\n    /**\n     * Set the col spacing for the layout.\n     */\n    set columnSpacing(value) {\n        // Clamp the spacing to the allowed range.\n        value = Private$4.clampValue(value);\n        // Bail if the spacing does not change\n        if (this._columnSpacing === value) {\n            return;\n        }\n        // Update the internal spacing.\n        this._columnSpacing = value;\n        // Schedule a fit of the parent.\n        if (this.parent) {\n            this.parent.fit();\n        }\n    }\n    /**\n     * Get the stretch factor for a specific row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @returns The stretch factor for the row.\n     *\n     * #### Notes\n     * This returns `-1` if the index is out of range.\n     */\n    rowStretch(index) {\n        let sizer = this._rowSizers[index];\n        return sizer ? sizer.stretch : -1;\n    }\n    /**\n     * Set the stretch factor for a specific row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @param value - The stretch factor for the row.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    setRowStretch(index, value) {\n        // Look up the row sizer.\n        let sizer = this._rowSizers[index];\n        // Bail if the index is out of range.\n        if (!sizer) {\n            return;\n        }\n        // Clamp the value to the allowed range.\n        value = Private$4.clampValue(value);\n        // Bail if the stretch does not change.\n        if (sizer.stretch === value) {\n            return;\n        }\n        // Update the sizer stretch.\n        sizer.stretch = value;\n        // Schedule an update of the parent.\n        if (this.parent) {\n            this.parent.update();\n        }\n    }\n    /**\n     * Get the stretch factor for a specific column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @returns The stretch factor for the column.\n     *\n     * #### Notes\n     * This returns `-1` if the index is out of range.\n     */\n    columnStretch(index) {\n        let sizer = this._columnSizers[index];\n        return sizer ? sizer.stretch : -1;\n    }\n    /**\n     * Set the stretch factor for a specific column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @param value - The stretch factor for the column.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    setColumnStretch(index, value) {\n        // Look up the column sizer.\n        let sizer = this._columnSizers[index];\n        // Bail if the index is out of range.\n        if (!sizer) {\n            return;\n        }\n        // Clamp the value to the allowed range.\n        value = Private$4.clampValue(value);\n        // Bail if the stretch does not change.\n        if (sizer.stretch === value) {\n            return;\n        }\n        // Update the sizer stretch.\n        sizer.stretch = value;\n        // Schedule an update of the parent.\n        if (this.parent) {\n            this.parent.update();\n        }\n    }\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    *[Symbol.iterator]() {\n        for (const item of this._items) {\n            yield item.widget;\n        }\n    }\n    /**\n     * Add a widget to the grid layout.\n     *\n     * @param widget - The widget to add to the layout.\n     *\n     * #### Notes\n     * If the widget is already contained in the layout, this is no-op.\n     */\n    addWidget(widget) {\n        // Look up the index for the widget.\n        let i = ArrayExt.findFirstIndex(this._items, it => it.widget === widget);\n        // Bail if the widget is already in the layout.\n        if (i !== -1) {\n            return;\n        }\n        // Add the widget to the layout.\n        this._items.push(new LayoutItem(widget));\n        // Attach the widget to the parent.\n        if (this.parent) {\n            this.attachWidget(widget);\n        }\n    }\n    /**\n     * Remove a widget from the grid layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        // Look up the index for the widget.\n        let i = ArrayExt.findFirstIndex(this._items, it => it.widget === widget);\n        // Bail if the widget is not in the layout.\n        if (i === -1) {\n            return;\n        }\n        // Remove the widget from the layout.\n        let item = ArrayExt.removeAt(this._items, i);\n        // Detach the widget from the parent.\n        if (this.parent) {\n            this.detachWidget(widget);\n        }\n        // Dispose the layout item.\n        item.dispose();\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        super.init();\n        for (const widget of this) {\n            this.attachWidget(widget);\n        }\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param widget - The widget to attach to the parent.\n     */\n    attachWidget(widget) {\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param widget - The widget to detach from the parent.\n     */\n    detachWidget(widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        super.onBeforeShow(msg);\n        this.parent.update();\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        super.onBeforeAttach(msg);\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    onChildShown(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    onChildHidden(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    onFitRequest(msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    }\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    _fit() {\n        // Reset the min sizes of the sizers.\n        for (let i = 0, n = this.rowCount; i < n; ++i) {\n            this._rowSizers[i].minSize = 0;\n        }\n        for (let i = 0, n = this.columnCount; i < n; ++i) {\n            this._columnSizers[i].minSize = 0;\n        }\n        // Filter for the visible layout items.\n        let items = this._items.filter(it => !it.isHidden);\n        // Fit the layout items.\n        for (let i = 0, n = items.length; i < n; ++i) {\n            items[i].fit();\n        }\n        // Get the max row and column index.\n        let maxRow = this.rowCount - 1;\n        let maxCol = this.columnCount - 1;\n        // Sort the items by row span.\n        items.sort(Private$4.rowSpanCmp);\n        // Update the min sizes of the row sizers.\n        for (let i = 0, n = items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = items[i];\n            // Get the row bounds for the item.\n            let config = GridLayout.getCellConfig(item.widget);\n            let r1 = Math.min(config.row, maxRow);\n            let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n            // Distribute the minimum height to the sizers as needed.\n            Private$4.distributeMin(this._rowSizers, r1, r2, item.minHeight);\n        }\n        // Sort the items by column span.\n        items.sort(Private$4.columnSpanCmp);\n        // Update the min sizes of the column sizers.\n        for (let i = 0, n = items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = items[i];\n            // Get the column bounds for the item.\n            let config = GridLayout.getCellConfig(item.widget);\n            let c1 = Math.min(config.column, maxCol);\n            let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n            // Distribute the minimum width to the sizers as needed.\n            Private$4.distributeMin(this._columnSizers, c1, c2, item.minWidth);\n        }\n        // If no size constraint is needed, just update the parent.\n        if (this.fitPolicy === 'set-no-constraint') {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n            return;\n        }\n        // Set up the computed min size.\n        let minH = maxRow * this._rowSpacing;\n        let minW = maxCol * this._columnSpacing;\n        // Add the sizer minimums to the computed min size.\n        for (let i = 0, n = this.rowCount; i < n; ++i) {\n            minH += this._rowSizers[i].minSize;\n        }\n        for (let i = 0, n = this.columnCount; i < n; ++i) {\n            minW += this._columnSizers[i].minSize;\n        }\n        // Update the box sizing and add it to the computed min size.\n        let box = (this._box = ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        let style = this.parent.node.style;\n        style.minWidth = `${minW}px`;\n        style.minHeight = `${minH}px`;\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    }\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    _update(offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the layout area adjusted for border and padding.\n        let top = this._box.paddingTop;\n        let left = this._box.paddingLeft;\n        let width = offsetWidth - this._box.horizontalSum;\n        let height = offsetHeight - this._box.verticalSum;\n        // Get the max row and column index.\n        let maxRow = this.rowCount - 1;\n        let maxCol = this.columnCount - 1;\n        // Compute the total fixed row and column space.\n        let fixedRowSpace = maxRow * this._rowSpacing;\n        let fixedColSpace = maxCol * this._columnSpacing;\n        // Distribute the available space to the box sizers.\n        BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));\n        BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));\n        // Update the row start positions.\n        for (let i = 0, pos = top, n = this.rowCount; i < n; ++i) {\n            this._rowStarts[i] = pos;\n            pos += this._rowSizers[i].size + this._rowSpacing;\n        }\n        // Update the column start positions.\n        for (let i = 0, pos = left, n = this.columnCount; i < n; ++i) {\n            this._columnStarts[i] = pos;\n            pos += this._columnSizers[i].size + this._columnSpacing;\n        }\n        // Update the geometry of the layout items.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Fetch the cell bounds for the widget.\n            let config = GridLayout.getCellConfig(item.widget);\n            let r1 = Math.min(config.row, maxRow);\n            let c1 = Math.min(config.column, maxCol);\n            let r2 = Math.min(config.row + config.rowSpan - 1, maxRow);\n            let c2 = Math.min(config.column + config.columnSpan - 1, maxCol);\n            // Compute the cell geometry.\n            let x = this._columnStarts[c1];\n            let y = this._rowStarts[r1];\n            let w = this._columnStarts[c2] + this._columnSizers[c2].size - x;\n            let h = this._rowStarts[r2] + this._rowSizers[r2].size - y;\n            // Update the geometry of the layout item.\n            item.update(x, y, w, h);\n        }\n    }\n}\n/**\n * The namespace for the `GridLayout` class statics.\n */\n(function (GridLayout) {\n    /**\n     * Get the cell config for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The cell config for the widget.\n     */\n    function getCellConfig(widget) {\n        return Private$4.cellConfigProperty.get(widget);\n    }\n    GridLayout.getCellConfig = getCellConfig;\n    /**\n     * Set the cell config for the given widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @param value - The value for the cell config.\n     */\n    function setCellConfig(widget, value) {\n        Private$4.cellConfigProperty.set(widget, Private$4.normalizeConfig(value));\n    }\n    GridLayout.setCellConfig = setCellConfig;\n})(GridLayout || (GridLayout = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$4;\n(function (Private) {\n    /**\n     * The property descriptor for the widget cell config.\n     */\n    Private.cellConfigProperty = new AttachedProperty({\n        name: 'cellConfig',\n        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),\n        changed: onChildCellConfigChanged\n    });\n    /**\n     * Normalize a partial cell config object.\n     */\n    function normalizeConfig(config) {\n        let row = Math.max(0, Math.floor(config.row || 0));\n        let column = Math.max(0, Math.floor(config.column || 0));\n        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));\n        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));\n        return { row, column, rowSpan, columnSpan };\n    }\n    Private.normalizeConfig = normalizeConfig;\n    /**\n     * Clamp a value to an integer >= 0.\n     */\n    function clampValue(value) {\n        return Math.max(0, Math.floor(value));\n    }\n    Private.clampValue = clampValue;\n    /**\n     * A sort comparison function for row spans.\n     */\n    function rowSpanCmp(a, b) {\n        let c1 = Private.cellConfigProperty.get(a.widget);\n        let c2 = Private.cellConfigProperty.get(b.widget);\n        return c1.rowSpan - c2.rowSpan;\n    }\n    Private.rowSpanCmp = rowSpanCmp;\n    /**\n     * A sort comparison function for column spans.\n     */\n    function columnSpanCmp(a, b) {\n        let c1 = Private.cellConfigProperty.get(a.widget);\n        let c2 = Private.cellConfigProperty.get(b.widget);\n        return c1.columnSpan - c2.columnSpan;\n    }\n    Private.columnSpanCmp = columnSpanCmp;\n    /**\n     * Reallocate the box sizers for the given grid dimensions.\n     */\n    function reallocSizers(sizers, count) {\n        // Coerce the count to the valid range.\n        count = Math.max(1, Math.floor(count));\n        // Add the missing sizers.\n        while (sizers.length < count) {\n            sizers.push(new BoxSizer());\n        }\n        // Remove the extra sizers.\n        if (sizers.length > count) {\n            sizers.length = count;\n        }\n    }\n    Private.reallocSizers = reallocSizers;\n    /**\n     * Distribute a min size constraint across a range of sizers.\n     */\n    function distributeMin(sizers, i1, i2, minSize) {\n        // Sanity check the indices.\n        if (i2 < i1) {\n            return;\n        }\n        // Handle the simple case of no cell span.\n        if (i1 === i2) {\n            let sizer = sizers[i1];\n            sizer.minSize = Math.max(sizer.minSize, minSize);\n            return;\n        }\n        // Compute the total current min size of the span.\n        let totalMin = 0;\n        for (let i = i1; i <= i2; ++i) {\n            totalMin += sizers[i].minSize;\n        }\n        // Do nothing if the total is greater than the required.\n        if (totalMin >= minSize) {\n            return;\n        }\n        // Compute the portion of the space to allocate to each sizer.\n        let portion = (minSize - totalMin) / (i2 - i1 + 1);\n        // Add the portion to each sizer.\n        for (let i = i1; i <= i2; ++i) {\n            sizers[i].minSize += portion;\n        }\n    }\n    Private.distributeMin = distributeMin;\n    /**\n     * The change handler for the child cell config property.\n     */\n    function onChildCellConfigChanged(child) {\n        if (child.parent && child.parent.layout instanceof GridLayout) {\n            child.parent.fit();\n        }\n    }\n})(Private$4 || (Private$4 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A widget which displays menus as a canonical menu bar.\n */\nclass MenuBar extends Widget {\n    /**\n     * Construct a new menu bar.\n     *\n     * @param options - The options for initializing the menu bar.\n     */\n    constructor(options = {}) {\n        super({ node: Private$3.createNode() });\n        // Track the index of the item that is currently focused or hovered. -1 means nothing focused or hovered.\n        this._activeIndex = -1;\n        // Track which item can be focused using the TAB key. Unlike _activeIndex will\n        // always point to a menuitem. Whenever you update this value, it's important\n        // to follow it with an \"update-request\" message so that the `tabindex`\n        // attribute on each menubar item gets properly updated.\n        this._tabFocusIndex = 0;\n        this._menus = [];\n        this._childMenu = null;\n        this._overflowMenu = null;\n        this._menuItemSizes = [];\n        this._overflowIndex = -1;\n        this.addClass('lm-MenuBar');\n        this.setFlag(Widget.Flag.DisallowLayout);\n        this.renderer = options.renderer || MenuBar.defaultRenderer;\n        this._forceItemsPosition = options.forceItemsPosition || {\n            forceX: true,\n            forceY: true\n        };\n        this._overflowMenuOptions = options.overflowMenuOptions || {\n            isVisible: true\n        };\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        this._closeChildMenu();\n        this._menus.length = 0;\n        super.dispose();\n    }\n    /**\n     * The child menu of the menu bar.\n     *\n     * #### Notes\n     * This will be `null` if the menu bar does not have an open menu.\n     */\n    get childMenu() {\n        return this._childMenu;\n    }\n    /**\n     * The overflow index of the menu bar.\n     */\n    get overflowIndex() {\n        return this._overflowIndex;\n    }\n    /**\n     * The overflow menu of the menu bar.\n     */\n    get overflowMenu() {\n        return this._overflowMenu;\n    }\n    /**\n     * Get the menu bar content node.\n     *\n     * #### Notes\n     * This is the node which holds the menu title nodes.\n     *\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get contentNode() {\n        return this.node.getElementsByClassName('lm-MenuBar-content')[0];\n    }\n    /**\n     * Get the currently active menu.\n     */\n    get activeMenu() {\n        return this._menus[this._activeIndex] || null;\n    }\n    /**\n     * Set the currently active menu.\n     *\n     * #### Notes\n     * If the menu does not exist, the menu will be set to `null`.\n     */\n    set activeMenu(value) {\n        this.activeIndex = value ? this._menus.indexOf(value) : -1;\n    }\n    /**\n     * Get the index of the currently active menu.\n     *\n     * #### Notes\n     * This will be `-1` if no menu is active.\n     */\n    get activeIndex() {\n        return this._activeIndex;\n    }\n    /**\n     * Set the index of the currently active menu.\n     *\n     * #### Notes\n     * If the menu cannot be activated, the index will be set to `-1`.\n     */\n    set activeIndex(value) {\n        // Adjust the value for an out of range index.\n        if (value < 0 || value >= this._menus.length) {\n            value = -1;\n        }\n        // An empty menu cannot be active\n        if (value > -1 && this._menus[value].items.length === 0) {\n            value = -1;\n        }\n        // Bail early if the index will not change.\n        if (this._activeIndex === value) {\n            return;\n        }\n        // Update the active index.\n        this._activeIndex = value;\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * A read-only array of the menus in the menu bar.\n     */\n    get menus() {\n        return this._menus;\n    }\n    /**\n     * Open the active menu and activate its first menu item.\n     *\n     * #### Notes\n     * If there is no active menu, this is a no-op.\n     */\n    openActiveMenu() {\n        // Bail early if there is no active item.\n        if (this._activeIndex === -1) {\n            return;\n        }\n        // Open the child menu.\n        this._openChildMenu();\n        // Activate the first item in the child menu.\n        if (this._childMenu) {\n            this._childMenu.activeIndex = -1;\n            this._childMenu.activateNextItem();\n        }\n    }\n    /**\n     * Add a menu to the end of the menu bar.\n     *\n     * @param menu - The menu to add to the menu bar.\n     *\n     * #### Notes\n     * If the menu is already added to the menu bar, it will be moved.\n     */\n    addMenu(menu, update = true) {\n        this.insertMenu(this._menus.length, menu, update);\n    }\n    /**\n     * Insert a menu into the menu bar at the specified index.\n     *\n     * @param index - The index at which to insert the menu.\n     *\n     * @param menu - The menu to insert into the menu bar.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the menus.\n     *\n     * If the menu is already added to the menu bar, it will be moved.\n     */\n    insertMenu(index, menu, update = true) {\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Look up the index of the menu.\n        let i = this._menus.indexOf(menu);\n        // Clamp the insert index to the array bounds.\n        let j = Math.max(0, Math.min(index, this._menus.length));\n        // If the menu is not in the array, insert it.\n        if (i === -1) {\n            // Insert the menu into the array.\n            ArrayExt.insert(this._menus, j, menu);\n            // Add the styling class to the menu.\n            menu.addClass('lm-MenuBar-menu');\n            // Connect to the menu signals.\n            menu.aboutToClose.connect(this._onMenuAboutToClose, this);\n            menu.menuRequested.connect(this._onMenuMenuRequested, this);\n            menu.title.changed.connect(this._onTitleChanged, this);\n            // Schedule an update of the items.\n            if (update) {\n                this.update();\n            }\n            // There is nothing more to do.\n            return;\n        }\n        // Otherwise, the menu exists in the array and should be moved.\n        // Adjust the index if the location is at the end of the array.\n        if (j === this._menus.length) {\n            j--;\n        }\n        // Bail if there is no effective move.\n        if (i === j) {\n            return;\n        }\n        // Move the menu to the new locations.\n        ArrayExt.move(this._menus, i, j);\n        // Schedule an update of the items.\n        if (update) {\n            this.update();\n        }\n    }\n    /**\n     * Remove a menu from the menu bar.\n     *\n     * @param menu - The menu to remove from the menu bar.\n     *\n     * #### Notes\n     * This is a no-op if the menu is not in the menu bar.\n     */\n    removeMenu(menu, update = true) {\n        this.removeMenuAt(this._menus.indexOf(menu), update);\n    }\n    /**\n     * Remove the menu at a given index from the menu bar.\n     *\n     * @param index - The index of the menu to remove.\n     *\n     * #### Notes\n     * This is a no-op if the index is out of range.\n     */\n    removeMenuAt(index, update = true) {\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Remove the menu from the array.\n        let menu = ArrayExt.removeAt(this._menus, index);\n        // Bail if the index is out of range.\n        if (!menu) {\n            return;\n        }\n        // Disconnect from the menu signals.\n        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n        menu.title.changed.disconnect(this._onTitleChanged, this);\n        // Remove the styling class from the menu.\n        menu.removeClass('lm-MenuBar-menu');\n        // Schedule an update of the items.\n        if (update) {\n            this.update();\n        }\n    }\n    /**\n     * Remove all menus from the menu bar.\n     */\n    clearMenus() {\n        // Bail if there is nothing to remove.\n        if (this._menus.length === 0) {\n            return;\n        }\n        // Close the child menu before making changes.\n        this._closeChildMenu();\n        // Disconnect from the menu signals and remove the styling class.\n        for (let menu of this._menus) {\n            menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);\n            menu.menuRequested.disconnect(this._onMenuMenuRequested, this);\n            menu.title.changed.disconnect(this._onTitleChanged, this);\n            menu.removeClass('lm-MenuBar-menu');\n        }\n        // Clear the menus array.\n        this._menus.length = 0;\n        // Schedule an update of the items.\n        this.update();\n    }\n    /**\n     * Handle the DOM events for the menu bar.\n     *\n     * @param event - The DOM event sent to the menu bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the menu bar's DOM nodes. It\n     * should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('keydown', this);\n        this.node.addEventListener('mousedown', this);\n        this.node.addEventListener('mousemove', this);\n        this.node.addEventListener('focusout', this);\n        this.node.addEventListener('contextmenu', this);\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('keydown', this);\n        this.node.removeEventListener('mousedown', this);\n        this.node.removeEventListener('mousemove', this);\n        this.node.removeEventListener('focusout', this);\n        this.node.removeEventListener('contextmenu', this);\n        this._closeChildMenu();\n    }\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    onActivateRequest(msg) {\n        if (this.isAttached) {\n            this._focusItemAt(0);\n        }\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        this.update();\n        super.onResize(msg);\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        var _a;\n        let menus = this._menus;\n        let renderer = this.renderer;\n        let activeIndex = this._activeIndex;\n        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length\n            ? this._tabFocusIndex\n            : 0;\n        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;\n        let totalMenuSize = 0;\n        let isVisible = false;\n        // Check that the overflow menu doesn't count\n        length = this._overflowMenu !== null ? length - 1 : length;\n        let content = new Array(length);\n        // Render visible menus\n        for (let i = 0; i < length; ++i) {\n            content[i] = renderer.renderItem({\n                title: menus[i].title,\n                active: i === activeIndex,\n                tabbable: i === tabFocusIndex,\n                disabled: menus[i].items.length === 0,\n                onfocus: () => {\n                    this._tabFocusIndex = i;\n                    this.activeIndex = i;\n                }\n            });\n            // Calculate size of current menu\n            totalMenuSize += this._menuItemSizes[i];\n            // Check if overflow menu is already rendered\n            if (menus[i].title.label === this._overflowMenuOptions.title) {\n                isVisible = true;\n                length--;\n            }\n        }\n        // Render overflow menu if needed and active\n        if (this._overflowMenuOptions.isVisible) {\n            if (this._overflowIndex > -1 && !isVisible) {\n                // Create overflow menu\n                if (this._overflowMenu === null) {\n                    const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : '...';\n                    this._overflowMenu = new Menu({ commands: new CommandRegistry() });\n                    this._overflowMenu.title.label = overflowMenuTitle;\n                    this._overflowMenu.title.mnemonic = 0;\n                    this.addMenu(this._overflowMenu, false);\n                }\n                // Move menus to overflow menu\n                for (let i = menus.length - 2; i >= length; i--) {\n                    const submenu = this.menus[i];\n                    submenu.title.mnemonic = 0;\n                    this._overflowMenu.insertItem(0, {\n                        type: 'submenu',\n                        submenu: submenu\n                    });\n                    this.removeMenu(submenu, false);\n                }\n                content[length] = renderer.renderItem({\n                    title: this._overflowMenu.title,\n                    active: length === activeIndex && menus[length].items.length !== 0,\n                    tabbable: length === tabFocusIndex,\n                    disabled: menus[length].items.length === 0,\n                    onfocus: () => {\n                        this._tabFocusIndex = length;\n                        this.activeIndex = length;\n                    }\n                });\n                length++;\n            }\n            else if (this._overflowMenu !== null) {\n                // Remove submenus from overflow menu\n                let overflowMenuItems = this._overflowMenu.items;\n                let screenSize = this.node.offsetWidth;\n                let n = this._overflowMenu.items.length;\n                for (let i = 0; i < n; ++i) {\n                    let index = menus.length - 1 - i;\n                    if (screenSize - totalMenuSize > this._menuItemSizes[index]) {\n                        let menu = overflowMenuItems[0].submenu;\n                        this._overflowMenu.removeItemAt(0);\n                        this.insertMenu(length, menu, false);\n                        content[length] = renderer.renderItem({\n                            title: menu.title,\n                            active: false,\n                            tabbable: length === tabFocusIndex,\n                            disabled: menus[length].items.length === 0,\n                            onfocus: () => {\n                                this._tabFocusIndex = length;\n                                this.activeIndex = length;\n                            }\n                        });\n                        length++;\n                    }\n                }\n                if (this._overflowMenu.items.length === 0) {\n                    this.removeMenu(this._overflowMenu, false);\n                    content.pop();\n                    this._overflowMenu = null;\n                    this._overflowIndex = -1;\n                }\n            }\n        }\n        VirtualDOM.render(content, this.contentNode);\n        this._updateOverflowIndex();\n    }\n    /**\n     * Calculate and update the current overflow index.\n     */\n    _updateOverflowIndex() {\n        if (!this._overflowMenuOptions.isVisible) {\n            return;\n        }\n        // Get elements visible in the main menu bar\n        const itemMenus = this.contentNode.childNodes;\n        let screenSize = this.node.offsetWidth;\n        let totalMenuSize = 0;\n        let index = -1;\n        let n = itemMenus.length;\n        if (this._menuItemSizes.length == 0) {\n            // Check if it is the first resize and get info about menu items sizes\n            for (let i = 0; i < n; i++) {\n                let item = itemMenus[i];\n                // Add sizes to array\n                totalMenuSize += item.offsetWidth;\n                this._menuItemSizes.push(item.offsetWidth);\n                if (totalMenuSize > screenSize && index === -1) {\n                    index = i;\n                }\n            }\n        }\n        else {\n            // Calculate current menu size\n            for (let i = 0; i < this._menuItemSizes.length; i++) {\n                totalMenuSize += this._menuItemSizes[i];\n                if (totalMenuSize > screenSize) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        this._overflowIndex = index;\n    }\n    /**\n     * Handle the `'keydown'` event for the menu bar.\n     *\n     * #### Notes\n     * All keys are trapped except the tab key that is ignored.\n     */\n    _evtKeyDown(event) {\n        // Fetch the key code for the event.\n        let kc = event.keyCode;\n        // Reset the active index on tab, but do not trap the tab key.\n        if (kc === 9) {\n            this.activeIndex = -1;\n            return;\n        }\n        // A menu bar handles all other keydown events.\n        event.preventDefault();\n        event.stopPropagation();\n        // Enter, Space, Up Arrow, Down Arrow\n        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {\n            // The active index may have changed (for example, user hovers over an\n            // item with the mouse), so be sure to use the focus index.\n            this.activeIndex = this._tabFocusIndex;\n            if (this.activeIndex !== this._tabFocusIndex) {\n                // Bail if the setter refused to set activeIndex to tabFocusIndex\n                // because it means that the item at tabFocusIndex cannot be opened (for\n                // example, it has an empty menu)\n                return;\n            }\n            this.openActiveMenu();\n            return;\n        }\n        // Escape\n        if (kc === 27) {\n            this._closeChildMenu();\n            this._focusItemAt(this.activeIndex);\n            return;\n        }\n        // Left or Right Arrow\n        if (kc === 37 || kc === 39) {\n            let direction = kc === 37 ? -1 : 1;\n            let start = this._tabFocusIndex + direction;\n            let n = this._menus.length;\n            for (let i = 0; i < n; i++) {\n                let index = (n + start + direction * i) % n;\n                if (this._menus[index].items.length) {\n                    this._focusItemAt(index);\n                    return;\n                }\n            }\n            return;\n        }\n        // Get the pressed key character.\n        let key = getKeyboardLayout().keyForKeydownEvent(event);\n        // Bail if the key is not valid.\n        if (!key) {\n            return;\n        }\n        // Search for the next best matching mnemonic item.\n        let start = this._activeIndex + 1;\n        let result = Private$3.findMnemonic(this._menus, key, start);\n        // Handle the requested mnemonic based on the search results.\n        // If exactly one mnemonic is matched, that menu is opened.\n        // Otherwise, the next mnemonic is activated if available,\n        // followed by the auto mnemonic if available.\n        if (result.index !== -1 && !result.multiple) {\n            this.activeIndex = result.index;\n            this.openActiveMenu();\n        }\n        else if (result.index !== -1) {\n            this.activeIndex = result.index;\n            this._focusItemAt(this.activeIndex);\n        }\n        else if (result.auto !== -1) {\n            this.activeIndex = result.auto;\n            this._focusItemAt(this.activeIndex);\n        }\n    }\n    /**\n     * Handle the `'mousedown'` event for the menu bar.\n     */\n    _evtMouseDown(event) {\n        // Bail if the mouse press was not on the menu bar. This can occur\n        // when the document listener is installed for an active menu bar.\n        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {\n            return;\n        }\n        // Stop the propagation of the event. Immediate propagation is\n        // also stopped so that an open menu does not handle the event.\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n        // Check if the mouse is over one of the menu items.\n        let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n            return ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // If the press was not on an item, close the child menu.\n        if (index === -1) {\n            this._closeChildMenu();\n            return;\n        }\n        // If the press was not the left mouse button, do nothing further.\n        if (event.button !== 0) {\n            return;\n        }\n        // Otherwise, toggle the open state of the child menu.\n        if (this._childMenu) {\n            this._closeChildMenu();\n            this.activeIndex = index;\n        }\n        else {\n            // If we don't call preventDefault() here, then the item in the menu\n            // bar will take focus over the menu that is being opened.\n            event.preventDefault();\n            const position = this._positionForMenu(index);\n            Menu.saveWindowData();\n            // Begin DOM modifications.\n            this.activeIndex = index;\n            this._openChildMenu(position);\n        }\n    }\n    /**\n     * Handle the `'mousemove'` event for the menu bar.\n     */\n    _evtMouseMove(event) {\n        // Check if the mouse is over one of the menu items.\n        let index = ArrayExt.findFirstIndex(this.contentNode.children, node => {\n            return ElementExt.hitTest(node, event.clientX, event.clientY);\n        });\n        // Bail early if the active index will not change.\n        if (index === this._activeIndex) {\n            return;\n        }\n        // Bail early if a child menu is open and the mouse is not over\n        // an item. This allows the child menu to be kept open when the\n        // mouse is over the empty part of the menu bar.\n        if (index === -1 && this._childMenu) {\n            return;\n        }\n        // Get position for the new menu >before< updating active index.\n        const position = index >= 0 && this._childMenu ? this._positionForMenu(index) : null;\n        // Before any modification, update window data.\n        Menu.saveWindowData();\n        // Begin DOM modifications.\n        // Update the active index to the hovered item.\n        this.activeIndex = index;\n        // Open the new menu if a menu is already open.\n        if (position) {\n            this._openChildMenu(position);\n        }\n    }\n    /**\n     * Find initial position for the menu based on menubar item position.\n     *\n     * NOTE: this should be called before updating active index to avoid\n     * an additional layout and style invalidation as changing active\n     * index modifies DOM.\n     */\n    _positionForMenu(index) {\n        let itemNode = this.contentNode.children[index];\n        let { left, bottom } = itemNode.getBoundingClientRect();\n        return {\n            top: bottom,\n            left\n        };\n    }\n    /**\n     * Handle the `'focusout'` event for the menu bar.\n     */\n    _evtFocusOut(event) {\n        // Reset the active index if there is no open menu and the menubar is losing focus.\n        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {\n            this.activeIndex = -1;\n        }\n    }\n    /**\n     * Focus an item in the menu bar.\n     *\n     * #### Notes\n     * Does not open the associated menu.\n     */\n    _focusItemAt(index) {\n        const itemNode = this.contentNode.childNodes[index];\n        if (itemNode) {\n            itemNode.focus();\n        }\n    }\n    /**\n     * Open the child menu at the active index immediately.\n     *\n     * If a different child menu is already open, it will be closed,\n     * even if there is no active menu.\n     */\n    _openChildMenu(options = {}) {\n        // If there is no active menu, close the current menu.\n        let newMenu = this.activeMenu;\n        if (!newMenu) {\n            this._closeChildMenu();\n            return;\n        }\n        // Bail if there is no effective menu change.\n        let oldMenu = this._childMenu;\n        if (oldMenu === newMenu) {\n            return;\n        }\n        // Swap the internal menu reference.\n        this._childMenu = newMenu;\n        // Close the current menu, or setup for the new menu.\n        if (oldMenu) {\n            oldMenu.close();\n        }\n        else {\n            document.addEventListener('mousedown', this, true);\n        }\n        // Update the tab focus index and ensure the menu bar is updated.\n        this._tabFocusIndex = this.activeIndex;\n        MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);\n        // Get the positioning data for the new menu.\n        let { left, top } = options;\n        if (typeof left === 'undefined' || typeof top === 'undefined') {\n            ({ left, top } = this._positionForMenu(this._activeIndex));\n        }\n        // Begin DOM modifications\n        if (!oldMenu) {\n            // Continue setup for new menu\n            this.addClass('lm-mod-active');\n        }\n        // Open the new menu at the computed location.\n        if (newMenu.items.length > 0) {\n            newMenu.open(left, top, this._forceItemsPosition);\n        }\n    }\n    /**\n     * Close the child menu immediately.\n     *\n     * This is a no-op if a child menu is not open.\n     */\n    _closeChildMenu() {\n        // Bail if no child menu is open.\n        if (!this._childMenu) {\n            return;\n        }\n        // Remove the active class from the menu bar.\n        this.removeClass('lm-mod-active');\n        // Remove the document listeners.\n        document.removeEventListener('mousedown', this, true);\n        // Clear the internal menu reference.\n        let menu = this._childMenu;\n        this._childMenu = null;\n        // Close the menu.\n        menu.close();\n        // Reset the active index.\n        this.activeIndex = -1;\n    }\n    /**\n     * Handle the `aboutToClose` signal of a menu.\n     */\n    _onMenuAboutToClose(sender) {\n        // Bail if the sender is not the child menu.\n        if (sender !== this._childMenu) {\n            return;\n        }\n        // Remove the active class from the menu bar.\n        this.removeClass('lm-mod-active');\n        // Remove the document listeners.\n        document.removeEventListener('mousedown', this, true);\n        // Clear the internal menu reference.\n        this._childMenu = null;\n        // Reset the active index.\n        this.activeIndex = -1;\n    }\n    /**\n     * Handle the `menuRequested` signal of a child menu.\n     */\n    _onMenuMenuRequested(sender, args) {\n        // Bail if the sender is not the child menu.\n        if (sender !== this._childMenu) {\n            return;\n        }\n        // Look up the active index and menu count.\n        let i = this._activeIndex;\n        let n = this._menus.length;\n        // Active the next requested index.\n        switch (args) {\n            case 'next':\n                this.activeIndex = i === n - 1 ? 0 : i + 1;\n                break;\n            case 'previous':\n                this.activeIndex = i === 0 ? n - 1 : i - 1;\n                break;\n        }\n        // Open the active menu.\n        this.openActiveMenu();\n    }\n    /**\n     * Handle the `changed` signal of a title object.\n     */\n    _onTitleChanged() {\n        this.update();\n    }\n}\n/**\n * The namespace for the `MenuBar` class statics.\n */\n(function (MenuBar) {\n    /**\n     * The default implementation of `IRenderer`.\n     *\n     * #### Notes\n     * Subclasses are free to reimplement rendering methods as needed.\n     */\n    class Renderer {\n        /**\n         * Render the virtual element for a menu bar item.\n         *\n         * @param data - The data to use for rendering the item.\n         *\n         * @returns A virtual element representing the item.\n         */\n        renderItem(data) {\n            let className = this.createItemClass(data);\n            let dataset = this.createItemDataset(data);\n            let aria = this.createItemARIA(data);\n            return h.li({\n                className,\n                dataset,\n                ...(data.disabled ? {} : { tabindex: data.tabbable ? '0' : '-1' }),\n                onfocus: data.onfocus,\n                ...aria\n            }, this.renderIcon(data), this.renderLabel(data));\n        }\n        /**\n         * Render the icon element for a menu bar item.\n         *\n         * @param data - The data to use for rendering the icon.\n         *\n         * @returns A virtual element representing the item icon.\n         */\n        renderIcon(data) {\n            let className = this.createIconClass(data);\n            // If data.title.icon is undefined, it will be ignored.\n            return h.div({ className }, data.title.icon, data.title.iconLabel);\n        }\n        /**\n         * Render the label element for a menu item.\n         *\n         * @param data - The data to use for rendering the label.\n         *\n         * @returns A virtual element representing the item label.\n         */\n        renderLabel(data) {\n            let content = this.formatLabel(data);\n            return h.div({ className: 'lm-MenuBar-itemLabel' }, content);\n        }\n        /**\n         * Create the class name for the menu bar item.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the menu item.\n         */\n        createItemClass(data) {\n            let name = 'lm-MenuBar-item';\n            if (data.title.className) {\n                name += ` ${data.title.className}`;\n            }\n            if (data.active && !data.disabled) {\n                name += ' lm-mod-active';\n            }\n            return name;\n        }\n        /**\n         * Create the dataset for a menu bar item.\n         *\n         * @param data - The data to use for the item.\n         *\n         * @returns The dataset for the menu bar item.\n         */\n        createItemDataset(data) {\n            return data.title.dataset;\n        }\n        /**\n         * Create the aria attributes for menu bar item.\n         *\n         * @param data - The data to use for the aria attributes.\n         *\n         * @returns The aria attributes object for the item.\n         */\n        createItemARIA(data) {\n            return {\n                role: 'menuitem',\n                'aria-haspopup': 'true',\n                'aria-disabled': data.disabled ? 'true' : 'false'\n            };\n        }\n        /**\n         * Create the class name for the menu bar item icon.\n         *\n         * @param data - The data to use for the class name.\n         *\n         * @returns The full class name for the item icon.\n         */\n        createIconClass(data) {\n            let name = 'lm-MenuBar-itemIcon';\n            let extra = data.title.iconClass;\n            return extra ? `${name} ${extra}` : name;\n        }\n        /**\n         * Create the render content for the label node.\n         *\n         * @param data - The data to use for the label content.\n         *\n         * @returns The content to add to the label node.\n         */\n        formatLabel(data) {\n            // Fetch the label text and mnemonic index.\n            let { label, mnemonic } = data.title;\n            // If the index is out of range, do not modify the label.\n            if (mnemonic < 0 || mnemonic >= label.length) {\n                return label;\n            }\n            // Split the label into parts.\n            let prefix = label.slice(0, mnemonic);\n            let suffix = label.slice(mnemonic + 1);\n            let char = label[mnemonic];\n            // Wrap the mnemonic character in a span.\n            let span = h.span({ className: 'lm-MenuBar-itemMnemonic' }, char);\n            // Return the content parts.\n            return [prefix, span, suffix];\n        }\n    }\n    MenuBar.Renderer = Renderer;\n    /**\n     * The default `Renderer` instance.\n     */\n    MenuBar.defaultRenderer = new Renderer();\n})(MenuBar || (MenuBar = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$3;\n(function (Private) {\n    /**\n     * Create the DOM node for a menu bar.\n     */\n    function createNode() {\n        let node = document.createElement('div');\n        let content = document.createElement('ul');\n        content.className = 'lm-MenuBar-content';\n        node.appendChild(content);\n        content.setAttribute('role', 'menubar');\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Find the best matching mnemonic item.\n     *\n     * The search starts at the given index and wraps around.\n     */\n    function findMnemonic(menus, key, start) {\n        // Setup the result variables.\n        let index = -1;\n        let auto = -1;\n        let multiple = false;\n        // Normalize the key to upper case.\n        let upperKey = key.toUpperCase();\n        // Search the items from the given start index.\n        for (let i = 0, n = menus.length; i < n; ++i) {\n            // Compute the wrapped index.\n            let k = (i + start) % n;\n            // Look up the menu title.\n            let title = menus[k].title;\n            // Ignore titles with an empty label.\n            if (title.label.length === 0) {\n                continue;\n            }\n            // Look up the mnemonic index for the label.\n            let mn = title.mnemonic;\n            // Handle a valid mnemonic index.\n            if (mn >= 0 && mn < title.label.length) {\n                if (title.label[mn].toUpperCase() === upperKey) {\n                    if (index === -1) {\n                        index = k;\n                    }\n                    else {\n                        multiple = true;\n                    }\n                }\n                continue;\n            }\n            // Finally, handle the auto index if possible.\n            if (auto === -1 && title.label[0].toUpperCase() === upperKey) {\n                auto = k;\n            }\n        }\n        // Return the search results.\n        return { index, multiple, auto };\n    }\n    Private.findMnemonic = findMnemonic;\n})(Private$3 || (Private$3 = {}));\n\n/**\n * A widget which implements a canonical scroll bar.\n */\nclass ScrollBar extends Widget {\n    /**\n     * Construct a new scroll bar.\n     *\n     * @param options - The options for initializing the scroll bar.\n     */\n    constructor(options = {}) {\n        super({ node: Private$2.createNode() });\n        /**\n         * A timeout callback for repeating the mouse press.\n         */\n        this._onRepeat = () => {\n            // Clear the repeat timer id.\n            this._repeatTimer = -1;\n            // Bail if the mouse has been released.\n            if (!this._pressData) {\n                return;\n            }\n            // Look up the part that was pressed.\n            let part = this._pressData.part;\n            // Bail if the thumb was pressed.\n            if (part === 'thumb') {\n                return;\n            }\n            // Schedule the timer for another repeat.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 20);\n            // Get the current mouse position.\n            let mouseX = this._pressData.mouseX;\n            let mouseY = this._pressData.mouseY;\n            // Handle a decrement button repeat.\n            if (part === 'decrement') {\n                // Bail if the mouse is not over the button.\n                if (!ElementExt.hitTest(this.decrementNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Emit the step requested signal.\n                this._stepRequested.emit('decrement');\n                // Finished.\n                return;\n            }\n            // Handle an increment button repeat.\n            if (part === 'increment') {\n                // Bail if the mouse is not over the button.\n                if (!ElementExt.hitTest(this.incrementNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Emit the step requested signal.\n                this._stepRequested.emit('increment');\n                // Finished.\n                return;\n            }\n            // Handle a track repeat.\n            if (part === 'track') {\n                // Bail if the mouse is not over the track.\n                if (!ElementExt.hitTest(this.trackNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Fetch the thumb node.\n                let thumbNode = this.thumbNode;\n                // Bail if the mouse is over the thumb.\n                if (ElementExt.hitTest(thumbNode, mouseX, mouseY)) {\n                    return;\n                }\n                // Fetch the client rect for the thumb.\n                let thumbRect = thumbNode.getBoundingClientRect();\n                // Determine the direction for the page request.\n                let dir;\n                if (this._orientation === 'horizontal') {\n                    dir = mouseX < thumbRect.left ? 'decrement' : 'increment';\n                }\n                else {\n                    dir = mouseY < thumbRect.top ? 'decrement' : 'increment';\n                }\n                // Emit the page requested signal.\n                this._pageRequested.emit(dir);\n                // Finished.\n                return;\n            }\n        };\n        this._value = 0;\n        this._page = 10;\n        this._maximum = 100;\n        this._repeatTimer = -1;\n        this._pressData = null;\n        this._thumbMoved = new Signal(this);\n        this._stepRequested = new Signal(this);\n        this._pageRequested = new Signal(this);\n        this.addClass('lm-ScrollBar');\n        this.setFlag(Widget.Flag.DisallowLayout);\n        // Set the orientation.\n        this._orientation = options.orientation || 'vertical';\n        this.dataset['orientation'] = this._orientation;\n        // Parse the rest of the options.\n        if (options.maximum !== undefined) {\n            this._maximum = Math.max(0, options.maximum);\n        }\n        if (options.page !== undefined) {\n            this._page = Math.max(0, options.page);\n        }\n        if (options.value !== undefined) {\n            this._value = Math.max(0, Math.min(options.value, this._maximum));\n        }\n    }\n    /**\n     * A signal emitted when the user moves the scroll thumb.\n     *\n     * #### Notes\n     * The payload is the current value of the scroll bar.\n     */\n    get thumbMoved() {\n        return this._thumbMoved;\n    }\n    /**\n     * A signal emitted when the user clicks a step button.\n     *\n     * #### Notes\n     * The payload is whether a decrease or increase is requested.\n     */\n    get stepRequested() {\n        return this._stepRequested;\n    }\n    /**\n     * A signal emitted when the user clicks the scroll track.\n     *\n     * #### Notes\n     * The payload is whether a decrease or increase is requested.\n     */\n    get pageRequested() {\n        return this._pageRequested;\n    }\n    /**\n     * Get the orientation of the scroll bar.\n     */\n    get orientation() {\n        return this._orientation;\n    }\n    /**\n     * Set the orientation of the scroll bar.\n     */\n    set orientation(value) {\n        // Do nothing if the orientation does not change.\n        if (this._orientation === value) {\n            return;\n        }\n        // Release the mouse before making changes.\n        this._releaseMouse();\n        // Update the internal orientation.\n        this._orientation = value;\n        this.dataset['orientation'] = value;\n        // Schedule an update the scroll bar.\n        this.update();\n    }\n    /**\n     * Get the current value of the scroll bar.\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * Set the current value of the scroll bar.\n     *\n     * #### Notes\n     * The value will be clamped to the range `[0, maximum]`.\n     */\n    set value(value) {\n        // Clamp the value to the allowable range.\n        value = Math.max(0, Math.min(value, this._maximum));\n        // Do nothing if the value does not change.\n        if (this._value === value) {\n            return;\n        }\n        // Update the internal value.\n        this._value = value;\n        // Schedule an update the scroll bar.\n        this.update();\n    }\n    /**\n     * Get the page size of the scroll bar.\n     *\n     * #### Notes\n     * The page size is the amount of visible content in the scrolled\n     * region, expressed in data units. It determines the size of the\n     * scroll bar thumb.\n     */\n    get page() {\n        return this._page;\n    }\n    /**\n     * Set the page size of the scroll bar.\n     *\n     * #### Notes\n     * The page size will be clamped to the range `[0, Infinity]`.\n     */\n    set page(value) {\n        // Clamp the page size to the allowable range.\n        value = Math.max(0, value);\n        // Do nothing if the value does not change.\n        if (this._page === value) {\n            return;\n        }\n        // Update the internal page size.\n        this._page = value;\n        // Schedule an update the scroll bar.\n        this.update();\n    }\n    /**\n     * Get the maximum value of the scroll bar.\n     */\n    get maximum() {\n        return this._maximum;\n    }\n    /**\n     * Set the maximum value of the scroll bar.\n     *\n     * #### Notes\n     * The max size will be clamped to the range `[0, Infinity]`.\n     */\n    set maximum(value) {\n        // Clamp the value to the allowable range.\n        value = Math.max(0, value);\n        // Do nothing if the value does not change.\n        if (this._maximum === value) {\n            return;\n        }\n        // Update the internal values.\n        this._maximum = value;\n        // Clamp the current value to the new range.\n        this._value = Math.min(this._value, value);\n        // Schedule an update the scroll bar.\n        this.update();\n    }\n    /**\n     * The scroll bar decrement button node.\n     *\n     * #### Notes\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get decrementNode() {\n        return this.node.getElementsByClassName('lm-ScrollBar-button')[0];\n    }\n    /**\n     * The scroll bar increment button node.\n     *\n     * #### Notes\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get incrementNode() {\n        return this.node.getElementsByClassName('lm-ScrollBar-button')[1];\n    }\n    /**\n     * The scroll bar track node.\n     *\n     * #### Notes\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get trackNode() {\n        return this.node.getElementsByClassName('lm-ScrollBar-track')[0];\n    }\n    /**\n     * The scroll bar thumb node.\n     *\n     * #### Notes\n     * Modifying this node directly can lead to undefined behavior.\n     */\n    get thumbNode() {\n        return this.node.getElementsByClassName('lm-ScrollBar-thumb')[0];\n    }\n    /**\n     * Handle the DOM events for the scroll bar.\n     *\n     * @param event - The DOM event sent to the scroll bar.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the scroll bar's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'contextmenu':\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * A method invoked on a 'before-attach' message.\n     */\n    onBeforeAttach(msg) {\n        this.node.addEventListener('mousedown', this);\n        this.update();\n    }\n    /**\n     * A method invoked on an 'after-detach' message.\n     */\n    onAfterDetach(msg) {\n        this.node.removeEventListener('mousedown', this);\n        this._releaseMouse();\n    }\n    /**\n     * A method invoked on an 'update-request' message.\n     */\n    onUpdateRequest(msg) {\n        // Convert the value and page into percentages.\n        let value = (this._value * 100) / this._maximum;\n        let page = (this._page * 100) / (this._page + this._maximum);\n        // Clamp the value and page to the relevant range.\n        value = Math.max(0, Math.min(value, 100));\n        page = Math.max(0, Math.min(page, 100));\n        // Fetch the thumb style.\n        let thumbStyle = this.thumbNode.style;\n        // Update the thumb style for the current orientation.\n        if (this._orientation === 'horizontal') {\n            thumbStyle.top = '';\n            thumbStyle.height = '';\n            thumbStyle.left = `${value}%`;\n            thumbStyle.width = `${page}%`;\n            thumbStyle.transform = `translate(${-value}%, 0%)`;\n        }\n        else {\n            thumbStyle.left = '';\n            thumbStyle.width = '';\n            thumbStyle.top = `${value}%`;\n            thumbStyle.height = `${page}%`;\n            thumbStyle.transform = `translate(0%, ${-value}%)`;\n        }\n    }\n    /**\n     * Handle the `'keydown'` event for the scroll bar.\n     */\n    _evtKeyDown(event) {\n        // Stop all input events during drag.\n        event.preventDefault();\n        event.stopPropagation();\n        // Ignore anything except the `Escape` key.\n        if (event.keyCode !== 27) {\n            return;\n        }\n        // Fetch the previous scroll value.\n        let value = this._pressData ? this._pressData.value : -1;\n        // Release the mouse.\n        this._releaseMouse();\n        // Restore the old scroll value if possible.\n        if (value !== -1) {\n            this._moveThumb(value);\n        }\n    }\n    /**\n     * Handle the `'mousedown'` event for the scroll bar.\n     */\n    _evtMouseDown(event) {\n        // Do nothing if it's not a left mouse press.\n        if (event.button !== 0) {\n            return;\n        }\n        // Send an activate request to the scroll bar. This can be\n        // used by message hooks to activate something relevant.\n        this.activate();\n        // Do nothing if the mouse is already captured.\n        if (this._pressData) {\n            return;\n        }\n        // Find the pressed scroll bar part.\n        let part = Private$2.findPart(this, event.target);\n        // Do nothing if the part is not of interest.\n        if (!part) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Override the mouse cursor.\n        let override = Drag.overrideCursor('default');\n        // Set up the press data.\n        this._pressData = {\n            part,\n            override,\n            delta: -1,\n            value: -1,\n            mouseX: event.clientX,\n            mouseY: event.clientY\n        };\n        // Add the extra event listeners.\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Handle a thumb press.\n        if (part === 'thumb') {\n            // Fetch the thumb node.\n            let thumbNode = this.thumbNode;\n            // Fetch the client rect for the thumb.\n            let thumbRect = thumbNode.getBoundingClientRect();\n            // Update the press data delta for the current orientation.\n            if (this._orientation === 'horizontal') {\n                this._pressData.delta = event.clientX - thumbRect.left;\n            }\n            else {\n                this._pressData.delta = event.clientY - thumbRect.top;\n            }\n            // Add the active class to the thumb node.\n            thumbNode.classList.add('lm-mod-active');\n            // Store the current value in the press data.\n            this._pressData.value = this._value;\n            // Finished.\n            return;\n        }\n        // Handle a track press.\n        if (part === 'track') {\n            // Fetch the client rect for the thumb.\n            let thumbRect = this.thumbNode.getBoundingClientRect();\n            // Determine the direction for the page request.\n            let dir;\n            if (this._orientation === 'horizontal') {\n                dir = event.clientX < thumbRect.left ? 'decrement' : 'increment';\n            }\n            else {\n                dir = event.clientY < thumbRect.top ? 'decrement' : 'increment';\n            }\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the page requested signal.\n            this._pageRequested.emit(dir);\n            // Finished.\n            return;\n        }\n        // Handle a decrement button press.\n        if (part === 'decrement') {\n            // Add the active class to the decrement node.\n            this.decrementNode.classList.add('lm-mod-active');\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the step requested signal.\n            this._stepRequested.emit('decrement');\n            // Finished.\n            return;\n        }\n        // Handle an increment button press.\n        if (part === 'increment') {\n            // Add the active class to the increment node.\n            this.incrementNode.classList.add('lm-mod-active');\n            // Start the repeat timer.\n            this._repeatTimer = window.setTimeout(this._onRepeat, 350);\n            // Emit the step requested signal.\n            this._stepRequested.emit('increment');\n            // Finished.\n            return;\n        }\n    }\n    /**\n     * Handle the `'mousemove'` event for the scroll bar.\n     */\n    _evtMouseMove(event) {\n        // Do nothing if no drag is in progress.\n        if (!this._pressData) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Update the mouse position.\n        this._pressData.mouseX = event.clientX;\n        this._pressData.mouseY = event.clientY;\n        // Bail if the thumb is not being dragged.\n        if (this._pressData.part !== 'thumb') {\n            return;\n        }\n        // Get the client rect for the thumb and track.\n        let thumbRect = this.thumbNode.getBoundingClientRect();\n        let trackRect = this.trackNode.getBoundingClientRect();\n        // Fetch the scroll geometry based on the orientation.\n        let trackPos;\n        let trackSpan;\n        if (this._orientation === 'horizontal') {\n            trackPos = event.clientX - trackRect.left - this._pressData.delta;\n            trackSpan = trackRect.width - thumbRect.width;\n        }\n        else {\n            trackPos = event.clientY - trackRect.top - this._pressData.delta;\n            trackSpan = trackRect.height - thumbRect.height;\n        }\n        // Compute the desired value from the scroll geometry.\n        let value = trackSpan === 0 ? 0 : (trackPos * this._maximum) / trackSpan;\n        // Move the thumb to the computed value.\n        this._moveThumb(value);\n    }\n    /**\n     * Handle the `'mouseup'` event for the scroll bar.\n     */\n    _evtMouseUp(event) {\n        // Do nothing if it's not a left mouse release.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Release the mouse.\n        this._releaseMouse();\n    }\n    /**\n     * Release the mouse and restore the node states.\n     */\n    _releaseMouse() {\n        // Bail if there is no press data.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the repeat timer.\n        clearTimeout(this._repeatTimer);\n        this._repeatTimer = -1;\n        // Clear the press data.\n        this._pressData.override.dispose();\n        this._pressData = null;\n        // Remove the extra event listeners.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('contextmenu', this, true);\n        // Remove the active classes from the nodes.\n        this.thumbNode.classList.remove('lm-mod-active');\n        this.decrementNode.classList.remove('lm-mod-active');\n        this.incrementNode.classList.remove('lm-mod-active');\n    }\n    /**\n     * Move the thumb to the specified position.\n     */\n    _moveThumb(value) {\n        // Clamp the value to the allowed range.\n        value = Math.max(0, Math.min(value, this._maximum));\n        // Bail if the value does not change.\n        if (this._value === value) {\n            return;\n        }\n        // Update the internal value.\n        this._value = value;\n        // Schedule an update of the scroll bar.\n        this.update();\n        // Emit the thumb moved signal.\n        this._thumbMoved.emit(value);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$2;\n(function (Private) {\n    /**\n     * Create the DOM node for a scroll bar.\n     */\n    function createNode() {\n        let node = document.createElement('div');\n        let decrement = document.createElement('div');\n        let increment = document.createElement('div');\n        let track = document.createElement('div');\n        let thumb = document.createElement('div');\n        decrement.className = 'lm-ScrollBar-button';\n        increment.className = 'lm-ScrollBar-button';\n        decrement.dataset['action'] = 'decrement';\n        increment.dataset['action'] = 'increment';\n        track.className = 'lm-ScrollBar-track';\n        thumb.className = 'lm-ScrollBar-thumb';\n        track.appendChild(thumb);\n        node.appendChild(decrement);\n        node.appendChild(track);\n        node.appendChild(increment);\n        return node;\n    }\n    Private.createNode = createNode;\n    /**\n     * Find the scroll bar part which contains the given target.\n     */\n    function findPart(scrollBar, target) {\n        // Test the thumb.\n        if (scrollBar.thumbNode.contains(target)) {\n            return 'thumb';\n        }\n        // Test the track.\n        if (scrollBar.trackNode.contains(target)) {\n            return 'track';\n        }\n        // Test the decrement button.\n        if (scrollBar.decrementNode.contains(target)) {\n            return 'decrement';\n        }\n        // Test the increment button.\n        if (scrollBar.incrementNode.contains(target)) {\n            return 'increment';\n        }\n        // Indicate no match.\n        return null;\n    }\n    Private.findPart = findPart;\n})(Private$2 || (Private$2 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A concrete layout implementation which holds a single widget.\n *\n * #### Notes\n * This class is useful for creating simple container widgets which\n * hold a single child. The child should be positioned with CSS.\n */\nclass SingletonLayout extends Layout {\n    constructor() {\n        super(...arguments);\n        this._widget = null;\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        if (this._widget) {\n            let widget = this._widget;\n            this._widget = null;\n            widget.dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * Get the child widget for the layout.\n     */\n    get widget() {\n        return this._widget;\n    }\n    /**\n     * Set the child widget for the layout.\n     *\n     * #### Notes\n     * Setting the child widget will cause the old child widget to be\n     * automatically disposed. If that is not desired, set the parent\n     * of the old child to `null` before assigning a new child.\n     */\n    set widget(widget) {\n        // Remove the widget from its current parent. This is a no-op\n        // if the widget's parent is already the layout parent widget.\n        if (widget) {\n            widget.parent = this.parent;\n        }\n        // Bail early if the widget does not change.\n        if (this._widget === widget) {\n            return;\n        }\n        // Dispose of the old child widget.\n        if (this._widget) {\n            this._widget.dispose();\n        }\n        // Update the internal widget.\n        this._widget = widget;\n        // Attach the new child widget if needed.\n        if (this.parent && widget) {\n            this.attachWidget(widget);\n        }\n    }\n    /**\n     * Create an iterator over the widgets in the layout.\n     *\n     * @returns A new iterator over the widgets in the layout.\n     */\n    *[Symbol.iterator]() {\n        if (this._widget) {\n            yield this._widget;\n        }\n    }\n    /**\n     * Remove a widget from the layout.\n     *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        // Bail early if the widget does not exist in the layout.\n        if (this._widget !== widget) {\n            return;\n        }\n        // Clear the internal widget.\n        this._widget = null;\n        // If the layout is parented, detach the widget from the DOM.\n        if (this.parent) {\n            this.detachWidget(widget);\n        }\n    }\n    /**\n     * Perform layout initialization which requires the parent widget.\n     */\n    init() {\n        super.init();\n        for (const widget of this) {\n            this.attachWidget(widget);\n        }\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the single layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    attachWidget(widget) {\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the single layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    detachWidget(widget) {\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A layout where visible widgets are stacked atop one another.\n *\n * #### Notes\n * The Z-order of the visible widgets follows their layout order.\n */\nclass StackedLayout extends PanelLayout {\n    constructor(options = {}) {\n        super(options);\n        this._dirty = false;\n        this._items = [];\n        this._box = null;\n        this._hiddenMode =\n            options.hiddenMode !== undefined\n                ? options.hiddenMode\n                : Widget.HiddenMode.Display;\n    }\n    /**\n     * The method for hiding widgets.\n     *\n     * #### Notes\n     * If there is only one child widget, `Display` hiding mode will be used\n     * regardless of this setting.\n     */\n    get hiddenMode() {\n        return this._hiddenMode;\n    }\n    /**\n     * Set the method for hiding widgets.\n     *\n     * #### Notes\n     * If there is only one child widget, `Display` hiding mode will be used\n     * regardless of this setting.\n     */\n    set hiddenMode(v) {\n        if (this._hiddenMode === v) {\n            return;\n        }\n        this._hiddenMode = v;\n        if (this.widgets.length > 1) {\n            this.widgets.forEach(w => {\n                w.hiddenMode = this._hiddenMode;\n            });\n        }\n    }\n    /**\n     * Dispose of the resources held by the layout.\n     */\n    dispose() {\n        // Dispose of the layout items.\n        for (const item of this._items) {\n            item.dispose();\n        }\n        // Clear the layout state.\n        this._box = null;\n        this._items.length = 0;\n        // Dispose of the rest of the layout.\n        super.dispose();\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    attachWidget(index, widget) {\n        // Using transform create an additional layer in the pixel pipeline\n        // to limit the number of layer, it is set only if there is more than one widget.\n        if (this._hiddenMode === Widget.HiddenMode.Scale &&\n            this._items.length > 0) {\n            if (this._items.length === 1) {\n                this.widgets[0].hiddenMode = Widget.HiddenMode.Scale;\n            }\n            widget.hiddenMode = Widget.HiddenMode.Scale;\n        }\n        else {\n            widget.hiddenMode = Widget.HiddenMode.Display;\n        }\n        // Create and add a new layout item for the widget.\n        ArrayExt.insert(this._items, index, new LayoutItem(widget));\n        // Send a `'before-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        // Add the widget's node to the parent.\n        this.parent.node.appendChild(widget.node);\n        // Send an `'after-attach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n        }\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Move the layout item for the widget.\n        ArrayExt.move(this._items, fromIndex, toIndex);\n        // Post an update request for the parent widget.\n        this.parent.update();\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This is a reimplementation of the superclass method.\n     */\n    detachWidget(index, widget) {\n        // Remove the layout item for the widget.\n        let item = ArrayExt.removeAt(this._items, index);\n        // Send a `'before-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n        }\n        // Remove the widget's node from the parent.\n        this.parent.node.removeChild(widget.node);\n        // Send an `'after-detach'` message if the parent is attached.\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n        // Reset the z-index for the widget.\n        item.widget.node.style.zIndex = '';\n        // Reset the hidden mode for the widget.\n        if (this._hiddenMode === Widget.HiddenMode.Scale) {\n            widget.hiddenMode = Widget.HiddenMode.Display;\n            // Reset the hidden mode for the first widget if necessary.\n            if (this._items.length === 1) {\n                this._items[0].widget.hiddenMode = Widget.HiddenMode.Display;\n            }\n        }\n        // Dispose of the layout item.\n        item.dispose();\n        // Post a fit request for the parent widget.\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        super.onBeforeShow(msg);\n        this.parent.update();\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        super.onBeforeAttach(msg);\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-shown'` message.\n     */\n    onChildShown(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'child-hidden'` message.\n     */\n    onChildHidden(msg) {\n        this.parent.fit();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this.parent.isVisible) {\n            this._update(msg.width, msg.height);\n        }\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     */\n    onUpdateRequest(msg) {\n        if (this.parent.isVisible) {\n            this._update(-1, -1);\n        }\n    }\n    /**\n     * A message handler invoked on a `'fit-request'` message.\n     */\n    onFitRequest(msg) {\n        if (this.parent.isAttached) {\n            this._fit();\n        }\n    }\n    /**\n     * Fit the layout to the total size required by the widgets.\n     */\n    _fit() {\n        // Set up the computed minimum size.\n        let minW = 0;\n        let minH = 0;\n        // Update the computed minimum size.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Update the size limits for the item.\n            item.fit();\n            // Update the computed minimum size.\n            minW = Math.max(minW, item.minWidth);\n            minH = Math.max(minH, item.minHeight);\n        }\n        // Update the box sizing and add it to the computed min size.\n        let box = (this._box = ElementExt.boxSizing(this.parent.node));\n        minW += box.horizontalSum;\n        minH += box.verticalSum;\n        // Update the parent's min size constraints.\n        let style = this.parent.node.style;\n        style.minWidth = `${minW}px`;\n        style.minHeight = `${minH}px`;\n        // Set the dirty flag to ensure only a single update occurs.\n        this._dirty = true;\n        // Notify the ancestor that it should fit immediately. This may\n        // cause a resize of the parent, fulfilling the required update.\n        if (this.parent.parent) {\n            MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);\n        }\n        // If the dirty flag is still set, the parent was not resized.\n        // Trigger the required update on the parent widget immediately.\n        if (this._dirty) {\n            MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);\n        }\n    }\n    /**\n     * Update the layout position and size of the widgets.\n     *\n     * The parent offset dimensions should be `-1` if unknown.\n     */\n    _update(offsetWidth, offsetHeight) {\n        // Clear the dirty flag to indicate the update occurred.\n        this._dirty = false;\n        // Compute the visible item count.\n        let nVisible = 0;\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            nVisible += +!this._items[i].isHidden;\n        }\n        // Bail early if there are no visible items to layout.\n        if (nVisible === 0) {\n            return;\n        }\n        // Measure the parent if the offset dimensions are unknown.\n        if (offsetWidth < 0) {\n            offsetWidth = this.parent.node.offsetWidth;\n        }\n        if (offsetHeight < 0) {\n            offsetHeight = this.parent.node.offsetHeight;\n        }\n        // Ensure the parent box sizing data is computed.\n        if (!this._box) {\n            this._box = ElementExt.boxSizing(this.parent.node);\n        }\n        // Compute the actual layout bounds adjusted for border and padding.\n        let top = this._box.paddingTop;\n        let left = this._box.paddingLeft;\n        let width = offsetWidth - this._box.horizontalSum;\n        let height = offsetHeight - this._box.verticalSum;\n        // Update the widget stacking order and layout geometry.\n        for (let i = 0, n = this._items.length; i < n; ++i) {\n            // Fetch the item.\n            let item = this._items[i];\n            // Ignore hidden items.\n            if (item.isHidden) {\n                continue;\n            }\n            // Set the z-index for the widget.\n            item.widget.node.style.zIndex = `${i}`;\n            // Update the item geometry.\n            item.update(left, top, width, height);\n        }\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A panel where visible widgets are stacked atop one another.\n *\n * #### Notes\n * This class provides a convenience wrapper around a {@link StackedLayout}.\n */\nclass StackedPanel extends Panel {\n    /**\n     * Construct a new stacked panel.\n     *\n     * @param options - The options for initializing the panel.\n     */\n    constructor(options = {}) {\n        super({ layout: Private$1.createLayout(options) });\n        this._widgetRemoved = new Signal(this);\n        this.addClass('lm-StackedPanel');\n    }\n    /**\n     * The method for hiding widgets.\n     *\n     * #### Notes\n     * If there is only one child widget, `Display` hiding mode will be used\n     * regardless of this setting.\n     */\n    get hiddenMode() {\n        return this.layout.hiddenMode;\n    }\n    /**\n     * Set the method for hiding widgets.\n     *\n     * #### Notes\n     * If there is only one child widget, `Display` hiding mode will be used\n     * regardless of this setting.\n     */\n    set hiddenMode(v) {\n        this.layout.hiddenMode = v;\n    }\n    /**\n     * A signal emitted when a widget is removed from a stacked panel.\n     */\n    get widgetRemoved() {\n        return this._widgetRemoved;\n    }\n    /**\n     * A message handler invoked on a `'child-added'` message.\n     */\n    onChildAdded(msg) {\n        msg.child.addClass('lm-StackedPanel-child');\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     */\n    onChildRemoved(msg) {\n        msg.child.removeClass('lm-StackedPanel-child');\n        this._widgetRemoved.emit(msg.child);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * Create a stacked layout for the given panel options.\n     */\n    function createLayout(options) {\n        return options.layout || new StackedLayout();\n    }\n    Private.createLayout = createLayout;\n})(Private$1 || (Private$1 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A widget which combines a `TabBar` and a `StackedPanel`.\n *\n * #### Notes\n * This is a simple panel which handles the common case of a tab bar\n * placed next to a content area. The selected tab controls the widget\n * which is shown in the content area.\n *\n * For use cases which require more control than is provided by this\n * panel, the `TabBar` widget may be used independently.\n */\nclass TabPanel extends Widget {\n    /**\n     * Construct a new tab panel.\n     *\n     * @param options - The options for initializing the tab panel.\n     */\n    constructor(options = {}) {\n        super();\n        this._currentChanged = new Signal(this);\n        this._addRequested = new Signal(this);\n        this.addClass('lm-TabPanel');\n        // Create the tab bar and stacked panel.\n        this.tabBar = new TabBar(options);\n        this.tabBar.addClass('lm-TabPanel-tabBar');\n        this.stackedPanel = new StackedPanel();\n        this.stackedPanel.addClass('lm-TabPanel-stackedPanel');\n        // Connect the tab bar signal handlers.\n        this.tabBar.tabMoved.connect(this._onTabMoved, this);\n        this.tabBar.currentChanged.connect(this._onCurrentChanged, this);\n        this.tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);\n        this.tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);\n        this.tabBar.addRequested.connect(this._onTabAddRequested, this);\n        // Connect the stacked panel signal handlers.\n        this.stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);\n        // Get the data related to the placement.\n        this._tabPlacement = options.tabPlacement || 'top';\n        let direction = Private.directionFromPlacement(this._tabPlacement);\n        let orientation = Private.orientationFromPlacement(this._tabPlacement);\n        // Configure the tab bar for the placement.\n        this.tabBar.orientation = orientation;\n        this.tabBar.dataset['placement'] = this._tabPlacement;\n        // Create the box layout.\n        let layout = new BoxLayout({ direction, spacing: 0 });\n        // Set the stretch factors for the child widgets.\n        BoxLayout.setStretch(this.tabBar, 0);\n        BoxLayout.setStretch(this.stackedPanel, 1);\n        // Add the child widgets to the layout.\n        layout.addWidget(this.tabBar);\n        layout.addWidget(this.stackedPanel);\n        // Install the layout on the tab panel.\n        this.layout = layout;\n    }\n    /**\n     * A signal emitted when the current tab is changed.\n     *\n     * #### Notes\n     * This signal is emitted when the currently selected tab is changed\n     * either through user or programmatic interaction.\n     *\n     * Notably, this signal is not emitted when the index of the current\n     * tab changes due to tabs being inserted, removed, or moved. It is\n     * only emitted when the actual current tab node is changed.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * Get the index of the currently selected tab.\n     *\n     * #### Notes\n     * This will be `-1` if no tab is selected.\n     */\n    get currentIndex() {\n        return this.tabBar.currentIndex;\n    }\n    /**\n     * Set the index of the currently selected tab.\n     *\n     * #### Notes\n     * If the index is out of range, it will be set to `-1`.\n     */\n    set currentIndex(value) {\n        this.tabBar.currentIndex = value;\n    }\n    /**\n     * Get the currently selected widget.\n     *\n     * #### Notes\n     * This will be `null` if there is no selected tab.\n     */\n    get currentWidget() {\n        let title = this.tabBar.currentTitle;\n        return title ? title.owner : null;\n    }\n    /**\n     * Set the currently selected widget.\n     *\n     * #### Notes\n     * If the widget is not in the panel, it will be set to `null`.\n     */\n    set currentWidget(value) {\n        this.tabBar.currentTitle = value ? value.title : null;\n    }\n    /**\n     * Get the whether the tabs are movable by the user.\n     *\n     * #### Notes\n     * Tabs can always be moved programmatically.\n     */\n    get tabsMovable() {\n        return this.tabBar.tabsMovable;\n    }\n    /**\n     * Set the whether the tabs are movable by the user.\n     *\n     * #### Notes\n     * Tabs can always be moved programmatically.\n     */\n    set tabsMovable(value) {\n        this.tabBar.tabsMovable = value;\n    }\n    /**\n     * Get the whether the add button is enabled.\n     *\n     */\n    get addButtonEnabled() {\n        return this.tabBar.addButtonEnabled;\n    }\n    /**\n     * Set the whether the add button is enabled.\n     *\n     */\n    set addButtonEnabled(value) {\n        this.tabBar.addButtonEnabled = value;\n    }\n    /**\n     * Get the tab placement for the tab panel.\n     *\n     * #### Notes\n     * This controls the position of the tab bar relative to the content.\n     */\n    get tabPlacement() {\n        return this._tabPlacement;\n    }\n    /**\n     * Set the tab placement for the tab panel.\n     *\n     * #### Notes\n     * This controls the position of the tab bar relative to the content.\n     */\n    set tabPlacement(value) {\n        // Bail if the placement does not change.\n        if (this._tabPlacement === value) {\n            return;\n        }\n        // Update the internal value.\n        this._tabPlacement = value;\n        // Get the values related to the placement.\n        let direction = Private.directionFromPlacement(value);\n        let orientation = Private.orientationFromPlacement(value);\n        // Configure the tab bar for the placement.\n        this.tabBar.orientation = orientation;\n        this.tabBar.dataset['placement'] = value;\n        // Update the layout direction.\n        this.layout.direction = direction;\n    }\n    /**\n     * A signal emitted when the add button on a tab bar is clicked.\n     *\n     */\n    get addRequested() {\n        return this._addRequested;\n    }\n    /**\n     * A read-only array of the widgets in the panel.\n     */\n    get widgets() {\n        return this.stackedPanel.widgets;\n    }\n    /**\n     * Add a widget to the end of the tab panel.\n     *\n     * @param widget - The widget to add to the tab panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     *\n     * The widget's `title` is used to populate the tab.\n     */\n    addWidget(widget) {\n        this.insertWidget(this.widgets.length, widget);\n    }\n    /**\n     * Insert a widget into the tab panel at a specified index.\n     *\n     * @param index - The index at which to insert the widget.\n     *\n     * @param widget - The widget to insert into to the tab panel.\n     *\n     * #### Notes\n     * If the widget is already contained in the panel, it will be moved.\n     *\n     * The widget's `title` is used to populate the tab.\n     */\n    insertWidget(index, widget) {\n        if (widget !== this.currentWidget) {\n            widget.hide();\n        }\n        this.stackedPanel.insertWidget(index, widget);\n        this.tabBar.insertTab(index, widget.title);\n        widget.node.setAttribute('role', 'tabpanel');\n        let renderer = this.tabBar.renderer;\n        if (renderer instanceof TabBar.Renderer) {\n            let tabId = renderer.createTabKey({\n                title: widget.title,\n                current: false,\n                zIndex: 0\n            });\n            widget.node.setAttribute('aria-labelledby', tabId);\n        }\n    }\n    /**\n     * Handle the `currentChanged` signal from the tab bar.\n     */\n    _onCurrentChanged(sender, args) {\n        // Extract the previous and current title from the args.\n        let { previousIndex, previousTitle, currentIndex, currentTitle } = args;\n        // Extract the widgets from the titles.\n        let previousWidget = previousTitle ? previousTitle.owner : null;\n        let currentWidget = currentTitle ? currentTitle.owner : null;\n        // Hide the previous widget.\n        if (previousWidget) {\n            previousWidget.hide();\n        }\n        // Show the current widget.\n        if (currentWidget) {\n            currentWidget.show();\n        }\n        // Emit the `currentChanged` signal for the tab panel.\n        this._currentChanged.emit({\n            previousIndex,\n            previousWidget,\n            currentIndex,\n            currentWidget\n        });\n        // Flush the message loop on IE and Edge to prevent flicker.\n        if (Platform.IS_EDGE || Platform.IS_IE) {\n            MessageLoop.flush();\n        }\n    }\n    /**\n     * Handle the `tabAddRequested` signal from the tab bar.\n     */\n    _onTabAddRequested(sender, args) {\n        this._addRequested.emit(sender);\n    }\n    /**\n     * Handle the `tabActivateRequested` signal from the tab bar.\n     */\n    _onTabActivateRequested(sender, args) {\n        args.title.owner.activate();\n    }\n    /**\n     * Handle the `tabCloseRequested` signal from the tab bar.\n     */\n    _onTabCloseRequested(sender, args) {\n        args.title.owner.close();\n    }\n    /**\n     * Handle the `tabMoved` signal from the tab bar.\n     */\n    _onTabMoved(sender, args) {\n        this.stackedPanel.insertWidget(args.toIndex, args.title.owner);\n    }\n    /**\n     * Handle the `widgetRemoved` signal from the stacked panel.\n     */\n    _onWidgetRemoved(sender, widget) {\n        widget.node.removeAttribute('role');\n        widget.node.removeAttribute('aria-labelledby');\n        this.tabBar.removeTab(widget.title);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Convert a tab placement to tab bar orientation.\n     */\n    function orientationFromPlacement(plc) {\n        return placementToOrientationMap[plc];\n    }\n    Private.orientationFromPlacement = orientationFromPlacement;\n    /**\n     * Convert a tab placement to a box layout direction.\n     */\n    function directionFromPlacement(plc) {\n        return placementToDirectionMap[plc];\n    }\n    Private.directionFromPlacement = directionFromPlacement;\n    /**\n     * A mapping of tab placement to tab bar orientation.\n     */\n    const placementToOrientationMap = {\n        top: 'horizontal',\n        left: 'vertical',\n        right: 'vertical',\n        bottom: 'horizontal'\n    };\n    /**\n     * A mapping of tab placement to box layout direction.\n     */\n    const placementToDirectionMap = {\n        top: 'top-to-bottom',\n        left: 'left-to-right',\n        right: 'right-to-left',\n        bottom: 'bottom-to-top'\n    };\n})(Private || (Private = {}));\n\nexport { AccordionLayout, AccordionPanel, BoxEngine, BoxLayout, BoxPanel, BoxSizer, CommandPalette, ContextMenu, DockLayout, DockPanel, FocusTracker, GridLayout, Layout, LayoutItem, Menu, MenuBar, Panel, PanelLayout, ScrollBar, SingletonLayout, SplitLayout, SplitPanel, StackedLayout, StackedPanel, TabBar, TabPanel, Title, Widget };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["BoxEngine","Private$j","Private$i","Utils","BoxSizer","constructor","this","sizeHint","minSize","maxSize","Infinity","stretch","size","done","calc","sizers","space","count","length","totalMin","totalMax","totalSize","totalStretch","stretchCount","i","sizer","min","max","hint","Math","nearZero","notDoneCount","freeSpace","distSpace","distStretch","amt","adjust","index","delta","growLimit","shrinkLimit","n","grow","limit","shrink","growSizer","shrinkSizer","Title","options","_label","_caption","_mnemonic","_icon","undefined","_iconClass","_iconLabel","_className","_closable","_changed","Signal","_isDisposed","owner","label","mnemonic","icon","iconClass","iconLabel","caption","className","closable","_dataset","dataset","changed","value","emit","isDisposed","dispose","clearData","Widget","_flags","_layout","_parent","_disposed","_hiddenMode","HiddenMode","Display","node","createNode","addClass","setFlag","Flag","IsDisposed","parent","isAttached","detach","title","MessageLoop","AttachedProperty","disposed","testFlag","IsAttached","isHidden","IsHidden","isVisible","IsVisible","titleProperty","get","id","hiddenMode","_toggleHidden","Scale","style","willChange","contains","Error","msg","ChildMessage","sendMessage","Msg","ParentChanged","layout","DisallowLayout","children","widget","hasClass","name","classList","add","removeClass","remove","toggleClass","force","toggle","update","postMessage","UpdateRequest","fit","FitRequest","activate","ActivateRequest","close","CloseRequest","show","BeforeShow","clearFlag","AfterShow","hide","BeforeHide","AfterHide","setHidden","hidden","flag","processMessage","type","notifyLayout","onResize","onUpdateRequest","onFitRequest","onBeforeShow","onAfterShow","onBeforeHide","onAfterHide","onBeforeAttach","onAfterAttach","onBeforeDetach","onAfterDetach","onActivateRequest","onCloseRequest","onChildAdded","onChildRemoved","processParentMessage","transform","setAttribute","ContentVisibility","contentVisibility","zIndex","removeAttribute","Message","BeforeAttach","AfterAttach","BeforeDetach","AfterDetach","ConflatableMessage","child","super","ResizeMessage","width","height","UnknownSize","attach","host","ref","isConnected","insertBefore","parentNode","removeChild","Private","create","document","createElement","tag","Layout","_fitPolicy","fitPolicy","init","minWidth","minHeight","maxWidth","maxHeight","onChildShown","onChildHidden","removeWidget","getHorizontalAlignment","horizontalAlignmentProperty","setHorizontalAlignment","set","getVerticalAlignment","verticalAlignmentProperty","setVerticalAlignment","LayoutItem","_top","NaN","_left","_width","_height","_minWidth","_minHeight","_maxWidth","_maxHeight","position","contain","top","left","limits","ElementExt","sizeLimits","clampW","clampH","resized","onAlignmentChanged","PanelLayout","arguments","_widgets","pop","widgets","Symbol","iterator","addWidget","insertWidget","indexOf","j","ArrayExt","insert","attachWidget","move","moveWidget","removeWidgetAt","removeAt","detachWidget","fromIndex","toIndex","clampDimension","floor","Private$h","Private$g","Private$f","Private$e","Private$d","Private$c","Private$b","Private$a","Private$9","Private$8","Utils$1","SplitLayout","widgetOffset","_fixed","_spacing","_dirty","_hasNormedSizes","_sizers","_items","_handles","_box","_alignment","_orientation","renderer","orientation","alignment","spacing","item","handles","absoluteSizes","map","relativeSizes","normalize","setRelativeSizes","sizes","temp","slice","push","normed","moveHandle","handle","offsetLeft","offsetTop","createHandle","average","averageSize","createSizer","appendChild","_update","_fit","updateItemPosition","isHorizontal","handleStyle","nVisible","lastHandleIndex","horz","minW","minH","getStretch","box","boxSizing","horizontalSum","verticalSum","offsetWidth","offsetHeight","paddingTop","paddingLeft","extra","offset","fullOffset","stretchProperty","setStretch","coerce","reduce","v","s","values","sum","a","b","abs","AccordionLayout","_titles","titleSpace","titles","updateTitle","oldTitle","expanded","newTitle","createTitle","replaceChild","UUID","uuid4","titleStyle","data","createSectionTitle","Panel","createLayout","SplitPanel","_handleMoved","_pressData","_releaseMouse","handleMoved","handleEvent","event","_evtPointerDown","_evtPointerMove","_evtPointerUp","_evtKeyDown","preventDefault","stopPropagation","addEventListener","removeEventListener","keyCode","button","findFirstIndex","target","rect","getBoundingClientRect","clientX","clientY","window","getComputedStyle","override","Drag","overrideCursor","cursor","pos","Renderer","defaultRenderer","AccordionPanel","_widgetSizesCache","WeakMap","_expansionToggled","expansionToggled","connect","_onTitleChanged","collapse","_toggleExpansion","expand","_evtClick","_eventKeyDown","sender","_computeWidgetSize","widgetSizes","prev","curr","newSize","previousSize","widgetToCollapse","sz","lastIndexOf","forEach","_","idx","currentSize","defaultPrevented","handled","toString","key","match","click","direction","newIndex","focus","titleClassName","_titleID","_titleKeys","_uuid","_nInstance","createCollapseIcon","createTitleKey","aData","textContent","BoxLayout","_direction","getSizeBasis","sizeBasisProperty","setSizeBasis","onChildSizingChanged","dir","clampSpacing","BoxPanel","CommandPalette","_activeIndex","_results","commands","commandChanged","_onGenericChange","keyBindingChanged","searchNode","getElementsByClassName","inputNode","contentNode","items","addItem","createItem","refresh","addItems","newItems","removeItem","removeItemAt","clearItems","display","_toggleFocused","input","select","query","results","search","canActivate","VirtualDOM","render","content","renderEmptyMessage","activeIndex","Array","result","indices","category","renderHeader","active","renderItem","scrollTop","element","scrollIntoViewIfNeeded","_execute","altKey","ctrlKey","metaKey","shiftKey","_activatePreviousItem","_activateNextItem","ai","start","stop","findLastIndex","part","toLowerCase","isEnabled","execute","command","args","focused","activeElement","formatHeader","h","li","createItemClass","createItemDataset","isToggleable","role","isToggled","renderItemIcon","renderItemContent","renderItemShortcut","formatEmptyMessage","createIconClass","div","renderItemLabel","renderItemCaption","formatItemLabel","formatItemCaption","formatItemShortcut","StringExt","highlight","mark","kb","keyBinding","CommandRegistry","formatKeystroke","keys","fuzzySearch","source","score","rgx","rgxMatch","exec","matchSumOfDeltas","pivot","lowerBound","categoryIndices","labelIndices","matchType","scoreCmp","m1","d1","i1","i2","d2","localeCompare","r1","rank","r2","wrapper","clear","spellcheck","CommandItem","scores","replace","matchItems","sort","createResults","_commands","trim","JSONExt","emptyObject","findLastValue","keyBindings","deepEqual","Menu","_childIndex","_openTimerID","_closeTimerID","_childMenu","_parentMenu","_aboutToClose","_menuRequested","aboutToClose","menuRequested","parentMenu","childMenu","rootMenu","menu","leafMenu","activeItem","childNodes","activateNextItem","activatePreviousItem","triggerActiveItem","_cancelOpenTimer","_cancelCloseTimer","_openChildMenu","console","log","insertItem","open","x","y","_a","_b","forceX","forceY","openRootMenu","_evtMouseUp","_evtMouseMove","_evtMouseEnter","_evtMouseLeave","_evtMouseDown","collapsedFlags","computeCollapsed","collapsed","onfocus","kc","getKeyboardLayout","keyForKeydownEvent","findMnemonic","multiple","auto","hitTest","_startCloseTimer","submenu","_startOpenTimer","hitTestMenus","activateFirst","_closeChildMenu","saveWindowData","itemNode","openSubmenu","setTimeout","TIMER_DELAY","clearTimeout","aria","createItemARIA","tabindex","renderIcon","renderLabel","renderShortcut","renderSubmenu","formatLabel","formatShortcut","prefix","suffix","char","span","SUBMENU_OVERLAP","transientWindowDataCache","transientCacheCounter","getWindowData","_getWindowData","pageXOffset","pageYOffset","clientWidth","documentElement","clientHeight","tabIndex","MenuItem","fill","k1","k2","windowData","px","py","cw","ch","opacity","body","itemRect","right","borderTop","bottom","borderBottom","paddingBottom","upperKey","toUpperCase","k","mn","ContextMenu","_groupByTarget","_idTick","_sortBySelector","groupByTarget","sortBySelector","others","DisposableDelegate","removeFirstOf","itemCmpRank","itemCmp","s1","Selector","calculateSpecificity","selector","s2","isValid","validateSelector","currentTarget","elementFromPoint","availableItems","matches","parentElement","ARROW_KEYS","TabBar","Private$7","_currentIndex","_titlesEditable","_previousTitle","_dragData","_addButtonEnabled","_tabMoved","_currentChanged","_addRequested","_tabCloseRequested","_tabDetachRequested","_tabActivateRequested","_document","tabsMovable","titlesEditable","allowDeselect","addButtonEnabled","insertBehavior","removeBehavior","currentChanged","tabMoved","tabActivateRequested","addRequested","tabCloseRequested","tabDetachRequested","currentTitle","currentIndex","pi","pt","ci","ct","previousIndex","previousTitle","_name","addButtonNode","addTab","insertTab","asTitle","_adjustCurrentForInsert","_adjustCurrentForMove","removeTab","removeTabAt","disconnect","_adjustCurrentForRemove","clearTabs","releaseMouse","_evtDblClick","eventPhase","Event","CAPTURING_PHASE","_evtKeyDownCapturing","tabHandlingTabindex","_getCurrentTabindex","current","renderTab","elemTabindex","querySelector","getAttribute","tabs","tab","oldValue","innerHTML","onblur","_c","focusedElement","includes","focusable","nextFocused","focusedIndex","addButtonClicked","pressX","pressY","tabPos","tabSize","tabPressPos","targetIndex","tabLayout","contentRect","dragActive","dragAborted","detachRequested","closeIconSelector","dragExceeded","tabRect","tabPressOffset","snapTabLayout","detachExceeded","layoutTabs","finalizeTabPosition","duration","parseTransitionDuration","resetTabPositions","bh","Private$6","Private$5","Private$4","Private$3","Private$2","Private$1","_tabID","_tabKeys","createTabKey","createTabStyle","createTabClass","createTabDataset","createTabARIA","renderCloseIcon","addButtonSelector","DRAG_THRESHOLD","DETACH_THRESHOLD","parseFloat","transitionDuration","margin","marginLeft","marginTop","dx","dy","pressPos","localPos","clientPos","clientSize","targetPos","targetEnd","pxPos","threshold","ideal","tgt","final","DockLayout","_root","Map","bar","tabBars","isEmpty","iterAllWidgets","empty","iterUserWidgets","selectedWidgets","iterSelectedWidgets","iterTabBars","iterHandles","offsetX","offsetY","findSplitNode","holdSizes","saveLayout","holdAllSizes","main","createConfig","restoreLayout","config","mainConfig","widgetSet","Set","normalizeAreaConfig","oldWidgets","oldTabBars","oldHandles","has","tabBar","realizeAreaConfig","createTabBar","_createTabBar","_createHandle","mode","refNode","findTabNode","_insertTab","_insertSplit","_removeWidget","hitTestTabAreas","borderLeft","tabNode","hitTestTabNodes","borderWidth","borderRight","borderHeight","delete","removeAria","splitNode","syncHandles","maybeParent","childNode","childHandle","TabLayoutNode","splitHandle","gChild","gHandle","gSizer","_createTabNode","addAria","after","findFirstTabNode","merge","root","_splitRoot","normalizeSizes","GOLDEN_RATIO","sibling","SplitLayoutNode","normalized","oldRoot","newRoot","normalizeTabAreaConfig","normalizeSplitAreaConfig","realizeTabAreaConfig","realizeSplitAreaConfig","tabSizer","widgetSizer","tabBarItem","widgetItem","tabBarSizer","createNormalizedSizes","horizontal","fixed","tabId","DockPanel","_drag","_tabsMovable","_tabsConstrained","_layoutModified","_mode","_renderer","_edges","edges","DEFAULT_EDGES","tabsConstrained","overlay","Overlay","layoutModified","createSingleDocumentConfig","LayoutModified","selectWidget","find","activateWidget","Platform","IS_EDGE","IS_IE","flush","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","isGeneratedTabBarProperty","mimeData","hasData","_showOverlay","dropAction","proposedAction","zone","findDropTarget","factory","getData","getDropRef","deltaX","deltaY","xPos","yPos","paddingRight","tabHeight","_onTabMoved","_onCurrentChanged","_onTabCloseRequested","_onTabDetachRequested","_onTabActivateRequested","_onTabAddRequested","MimeData","setData","dragImage","cloneNode","supportedActions","then","_timer","_hidden","geo","delay","panel","from","selected","next","panelRect","pl","pr","pb","al","at","ar","ab","rx","round","ry","FocusTracker","_counter","_activeWidget","_currentWidget","_numbers","_nodes","_activeChanged","activeChanged","currentWidget","activeWidget","focusNumber","_onWidgetDisposed","_setWidgets","valid","filter","w","previous","first","second","_evtFocus","_evtBlur","oldCurrent","oldActive","newValue","focusTarget","relatedTarget","GridLayout","_rowSpacing","_columnSpacing","_rowStarts","_columnStarts","_rowSizers","_columnSizers","rowCount","reallocSizers","columnCount","rowSpacing","clampValue","columnSpacing","rowStretch","setRowStretch","columnStretch","setColumnStretch","it","maxRow","maxCol","rowSpanCmp","getCellConfig","row","rowSpan","distributeMin","columnSpanCmp","c1","column","c2","columnSpan","fixedRowSpace","fixedColSpace","cellConfigProperty","setCellConfig","normalizeConfig","portion","MenuBar","_tabFocusIndex","_menus","_overflowMenu","_menuItemSizes","_overflowIndex","_forceItemsPosition","forceItemsPosition","_overflowMenuOptions","overflowMenuOptions","overflowIndex","overflowMenu","activeMenu","menus","openActiveMenu","addMenu","insertMenu","_onMenuAboutToClose","_onMenuMenuRequested","removeMenu","removeMenuAt","clearMenus","_evtFocusOut","_focusItemAt","tabFocusIndex","totalMenuSize","tabbable","disabled","overflowMenuTitle","overflowMenuItems","screenSize","_updateOverflowIndex","itemMenus","stopImmediatePropagation","_positionForMenu","newMenu","oldMenu","ScrollBar","_onRepeat","_repeatTimer","mouseX","mouseY","trackNode","thumbNode","thumbRect","_pageRequested","incrementNode","_stepRequested","decrementNode","_value","_page","_maximum","_thumbMoved","maximum","page","thumbMoved","stepRequested","pageRequested","thumbStyle","_moveThumb","findPart","trackPos","trackSpan","trackRect","decrement","increment","track","thumb","scrollBar","SingletonLayout","_widget","StackedLayout","StackedPanel","_widgetRemoved","widgetRemoved","TabPanel","stackedPanel","_onWidgetRemoved","_tabPlacement","tabPlacement","directionFromPlacement","orientationFromPlacement","previousWidget","plc","placementToOrientationMap","placementToDirectionMap"],"sourceRoot":""}