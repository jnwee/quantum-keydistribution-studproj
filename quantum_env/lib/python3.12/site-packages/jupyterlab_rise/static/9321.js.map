{"version":3,"file":"9321.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/dialogs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savehandler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/widgetmanager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/manager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/pathstatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/savingstatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager/lib/recents.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog, showErrorMessage } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to file dialogs.\n */\nconst FILE_DIALOG_CLASS = 'jp-FileDialog';\n/**\n * The class name added for the new name label in the rename dialog\n */\nconst RENAME_NEW_NAME_TITLE_CLASS = 'jp-new-name-title';\n/**\n * Rename a file with a dialog.\n */\nexport function renameDialog(manager, context, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const localPath = context.localPath.split('/');\n    const fileName = localPath.pop() || context.localPath;\n    return showDialog({\n        title: trans.__('Rename File'),\n        body: new RenameHandler(fileName),\n        focusNodeSelector: 'input',\n        buttons: [\n            Dialog.cancelButton(),\n            Dialog.okButton({\n                label: trans.__('Rename'),\n                ariaLabel: trans.__('Rename File')\n            })\n        ]\n    }).then(result => {\n        if (!result.value) {\n            return null;\n        }\n        if (!isValidFileName(result.value)) {\n            void showErrorMessage(trans.__('Rename Error'), Error(trans.__('\"%1\" is not a valid name for a file. Names must have nonzero length, and cannot include \"/\", \"\\\\\", or \":\"', result.value)));\n            return null;\n        }\n        return context.rename(result.value);\n    });\n}\n/**\n * Rename a file, asking for confirmation if it is overwriting another.\n */\nexport function renameFile(manager, oldPath, newPath) {\n    return manager.rename(oldPath, newPath).catch(error => {\n        if (error.response.status !== 409) {\n            // if it's not caused by an already existing file, rethrow\n            throw error;\n        }\n        // otherwise, ask for confirmation\n        return shouldOverwrite(newPath).then((value) => {\n            if (value) {\n                return manager.overwrite(oldPath, newPath);\n            }\n            return Promise.reject('File not renamed');\n        });\n    });\n}\n/**\n * Ask the user whether to overwrite a file.\n */\nexport function shouldOverwrite(path, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    const options = {\n        title: trans.__('Overwrite file?'),\n        body: trans.__('\"%1\" already exists, overwrite?', path),\n        buttons: [\n            Dialog.cancelButton(),\n            Dialog.warnButton({\n                label: trans.__('Overwrite'),\n                ariaLabel: trans.__('Overwrite Existing File')\n            })\n        ]\n    };\n    return showDialog(options).then(result => {\n        return Promise.resolve(result.button.accept);\n    });\n}\n/**\n * Test whether a name is a valid file name\n *\n * Disallows \"/\", \"\\\", and \":\" in file names, as well as names with zero length.\n */\nexport function isValidFileName(name) {\n    const validNameExp = /[\\/\\\\:]/;\n    return name.length > 0 && !validNameExp.test(name);\n}\n/**\n * A widget used to rename a file.\n */\nclass RenameHandler extends Widget {\n    /**\n     * Construct a new \"rename\" dialog.\n     */\n    constructor(oldPath) {\n        super({ node: Private.createRenameNode(oldPath) });\n        this.addClass(FILE_DIALOG_CLASS);\n        const ext = PathExt.extname(oldPath);\n        const value = (this.inputNode.value = PathExt.basename(oldPath));\n        this.inputNode.setSelectionRange(0, value.length - ext.length);\n    }\n    /**\n     * Get the input text node.\n     */\n    get inputNode() {\n        return this.node.getElementsByTagName('input')[0];\n    }\n    /**\n     * Get the value of the widget.\n     */\n    getValue() {\n        return this.inputNode.value;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create the node for a rename handler.\n     */\n    function createRenameNode(oldPath, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const body = document.createElement('div');\n        const existingLabel = document.createElement('label');\n        existingLabel.textContent = trans.__('File Path');\n        const existingPath = document.createElement('span');\n        existingPath.textContent = oldPath;\n        const nameTitle = document.createElement('label');\n        nameTitle.textContent = trans.__('New Name');\n        nameTitle.className = RENAME_NEW_NAME_TITLE_CLASS;\n        const name = document.createElement('input');\n        body.appendChild(existingLabel);\n        body.appendChild(existingPath);\n        body.appendChild(nameTitle);\n        body.appendChild(name);\n        return body;\n    }\n    Private.createRenameNode = createRenameNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=dialogs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\n/**\n * A class that manages the auto saving of a document.\n *\n * #### Notes\n * Implements https://github.com/ipython/ipython/wiki/IPEP-15:-Autosaving-the-IPython-Notebook.\n */\nexport class SaveHandler {\n    /**\n     * Construct a new save handler.\n     */\n    constructor(options) {\n        this._autosaveTimer = -1;\n        this._minInterval = -1;\n        this._interval = -1;\n        this._isActive = false;\n        this._inDialog = false;\n        this._isDisposed = false;\n        this._multiplier = 10;\n        this._context = options.context;\n        this._isConnectedCallback = options.isConnectedCallback || (() => true);\n        const interval = options.saveInterval || 120;\n        this._minInterval = interval * 1000;\n        this._interval = this._minInterval;\n        // Restart the timer when the contents model is updated.\n        this._context.fileChanged.connect(this._setTimer, this);\n        this._context.disposed.connect(this.dispose, this);\n    }\n    /**\n     * The save interval used by the timer (in seconds).\n     */\n    get saveInterval() {\n        return this._interval / 1000;\n    }\n    set saveInterval(value) {\n        this._minInterval = this._interval = value * 1000;\n        if (this._isActive) {\n            this._setTimer();\n        }\n    }\n    /**\n     * Get whether the handler is active.\n     */\n    get isActive() {\n        return this._isActive;\n    }\n    /**\n     * Get whether the save handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the save handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        clearTimeout(this._autosaveTimer);\n        Signal.clearData(this);\n    }\n    /**\n     * Start the autosaver.\n     */\n    start() {\n        this._isActive = true;\n        this._setTimer();\n    }\n    /**\n     * Stop the autosaver.\n     */\n    stop() {\n        this._isActive = false;\n        clearTimeout(this._autosaveTimer);\n    }\n    /**\n     * Set the timer.\n     */\n    _setTimer() {\n        clearTimeout(this._autosaveTimer);\n        if (!this._isActive) {\n            return;\n        }\n        this._autosaveTimer = window.setTimeout(() => {\n            if (this._isConnectedCallback()) {\n                this._save();\n            }\n            else {\n                this._setTimer();\n            }\n        }, this._interval);\n    }\n    /**\n     * Handle an autosave timeout.\n     */\n    _save() {\n        const context = this._context;\n        // Trigger the next update.\n        this._setTimer();\n        if (!context) {\n            return;\n        }\n        // Bail if the model is not dirty or the file is not writable, or the dialog\n        // is already showing.\n        const writable = context.contentsModel && context.contentsModel.writable;\n        if (!writable || !context.model.dirty || this._inDialog) {\n            return;\n        }\n        const start = new Date().getTime();\n        context\n            .save()\n            .then(() => {\n            if (this.isDisposed) {\n                return;\n            }\n            const duration = new Date().getTime() - start;\n            // New save interval: higher of 10x save duration or min interval.\n            this._interval = Math.max(this._multiplier * duration, this._minInterval);\n            // Restart the update to pick up the new interval.\n            this._setTimer();\n        })\n            .catch(err => {\n            // If the user canceled the save, do nothing.\n            const { name } = err;\n            if (name === 'ModalCancelError' || name === 'ModalDuplicateError') {\n                return;\n            }\n            // Otherwise, log the error.\n            console.error('Error in Auto-Save', err.message);\n        });\n    }\n}\n//# sourceMappingURL=savehandler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { Time } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, find } from '@lumino/algorithm';\nimport { DisposableSet } from '@lumino/disposable';\nimport { MessageLoop } from '@lumino/messaging';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\n/**\n * The class name added to document widgets.\n */\nconst DOCUMENT_CLASS = 'jp-Document';\n/**\n * A class that maintains the lifecycle of file-backed widgets.\n */\nexport class DocumentWidgetManager {\n    /**\n     * Construct a new document widget manager.\n     */\n    constructor(options) {\n        this._activateRequested = new Signal(this);\n        this._confirmClosingTab = false;\n        this._isDisposed = false;\n        this._stateChanged = new Signal(this);\n        this._registry = options.registry;\n        this.translator = options.translator || nullTranslator;\n        this._recentsManager = options.recentsManager || null;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Whether to ask confirmation to close a tab or not.\n     */\n    get confirmClosingDocument() {\n        return this._confirmClosingTab;\n    }\n    set confirmClosingDocument(v) {\n        if (this._confirmClosingTab !== v) {\n            const oldValue = this._confirmClosingTab;\n            this._confirmClosingTab = v;\n            this._stateChanged.emit({\n                name: 'confirmClosingDocument',\n                oldValue,\n                newValue: v\n            });\n        }\n    }\n    /**\n     * Signal triggered when an attribute changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Test whether the document widget manager is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources used by the widget manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.disconnectReceiver(this);\n    }\n    /**\n     * Create a widget for a document and handle its lifecycle.\n     *\n     * @param factory - The widget factory.\n     *\n     * @param context - The document context object.\n     *\n     * @returns A widget created by the factory.\n     *\n     * @throws If the factory is not registered.\n     */\n    createWidget(factory, context) {\n        const widget = factory.createNew(context);\n        this._initializeWidget(widget, factory, context);\n        return widget;\n    }\n    /**\n     * When a new widget is created, we need to hook it up\n     * with some signals, update the widget extensions (for\n     * this kind of widget) in the docregistry, among\n     * other things.\n     */\n    _initializeWidget(widget, factory, context) {\n        Private.factoryProperty.set(widget, factory);\n        // Handle widget extensions.\n        const disposables = new DisposableSet();\n        for (const extender of this._registry.widgetExtensions(factory.name)) {\n            const disposable = extender.createNew(widget, context);\n            if (disposable) {\n                disposables.add(disposable);\n            }\n        }\n        Private.disposablesProperty.set(widget, disposables);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n        this.adoptWidget(context, widget);\n        context.fileChanged.connect(this._onFileChanged, this);\n        context.pathChanged.connect(this._onPathChanged, this);\n        void context.ready.then(() => {\n            void this.setCaption(widget);\n        });\n    }\n    /**\n     * Install the message hook for the widget and add to list\n     * of known widgets.\n     *\n     * @param context - The document context object.\n     *\n     * @param widget - The widget to adopt.\n     */\n    adoptWidget(context, widget) {\n        const widgets = Private.widgetsProperty.get(context);\n        widgets.push(widget);\n        MessageLoop.installMessageHook(widget, this);\n        widget.addClass(DOCUMENT_CLASS);\n        widget.title.closable = true;\n        widget.disposed.connect(this._widgetDisposed, this);\n        Private.contextProperty.set(widget, context);\n    }\n    /**\n     * See if a widget already exists for the given context and widget name.\n     *\n     * @param context - The document context object.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to use an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(context, widgetName) {\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return undefined;\n        }\n        return find(widgets, widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.name === widgetName;\n        });\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined`.\n     */\n    contextForWidget(widget) {\n        return Private.contextProperty.get(widget);\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or throws\n     *  if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return undefined;\n        }\n        const factory = Private.factoryProperty.get(widget);\n        if (!factory) {\n            return undefined;\n        }\n        const newWidget = factory.createNew(context, widget);\n        this._initializeWidget(newWidget, factory, context);\n        return newWidget;\n    }\n    /**\n     * Close the widgets associated with a given context.\n     *\n     * @param context - The document context object.\n     */\n    closeWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(widgets.map(widget => this.onClose(widget))).then(() => undefined);\n    }\n    /**\n     * Dispose of the widgets associated with a given context\n     * regardless of the widget's dirty state.\n     *\n     * @param context - The document context object.\n     */\n    deleteWidgets(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        return Promise.all(widgets.map(widget => this.onDelete(widget))).then(() => undefined);\n    }\n    /**\n     * Filter a message sent to a message handler.\n     *\n     * @param handler - The target handler of the message.\n     *\n     * @param msg - The message dispatched to the handler.\n     *\n     * @returns `false` if the message should be filtered, of `true`\n     *   if the message should be dispatched to the handler as normal.\n     */\n    messageHook(handler, msg) {\n        switch (msg.type) {\n            case 'close-request':\n                void this.onClose(handler);\n                return false;\n            case 'activate-request': {\n                const widget = handler;\n                const context = this.contextForWidget(widget);\n                if (context) {\n                    context.ready\n                        .then(() => {\n                        // contentsModel is null until the context is ready\n                        this._recordAsRecentlyOpened(widget, context.contentsModel);\n                    })\n                        .catch(() => {\n                        console.warn('Could not record the recents status for', context);\n                    });\n                    this._activateRequested.emit(context.path);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return true;\n    }\n    /**\n     * Set the caption for widget title.\n     *\n     * @param widget - The target widget.\n     */\n    async setCaption(widget) {\n        const trans = this.translator.load('jupyterlab');\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const model = context.contentsModel;\n        if (!model) {\n            widget.title.caption = '';\n            return;\n        }\n        return context\n            .listCheckpoints()\n            .then((checkpoints) => {\n            if (widget.isDisposed) {\n                return;\n            }\n            const last = checkpoints[checkpoints.length - 1];\n            const checkpoint = last ? Time.format(last.last_modified) : 'None';\n            let caption = trans.__('Name: %1\\nPath: %2\\n', model.name, model.path);\n            if (context.model.readOnly) {\n                caption += trans.__('Read-only');\n            }\n            else {\n                caption +=\n                    trans.__('Last Saved: %1\\n', Time.format(model.last_modified)) +\n                        trans.__('Last Checkpoint: %1', checkpoint);\n            }\n            widget.title.caption = caption;\n        });\n    }\n    /**\n     * Handle `'close-request'` messages.\n     *\n     * @param widget - The target widget.\n     *\n     * @returns A promise that resolves with whether the widget was closed.\n     */\n    async onClose(widget) {\n        var _a;\n        // Handle dirty state.\n        const [shouldClose, ignoreSave] = await this._maybeClose(widget, this.translator);\n        if (widget.isDisposed) {\n            return true;\n        }\n        if (shouldClose) {\n            const context = Private.contextProperty.get(widget);\n            if (!ignoreSave) {\n                if (!context) {\n                    return true;\n                }\n                if ((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) {\n                    await context.save();\n                }\n                else {\n                    await context.saveAs();\n                }\n            }\n            if (context) {\n                const result = await Promise.race([\n                    context.ready,\n                    new Promise(resolve => setTimeout(resolve, 3000, 'timeout'))\n                ]);\n                if (result === 'timeout') {\n                    console.warn('Could not record the widget as recently closed because the context did not become ready in 3 seconds');\n                }\n                else {\n                    // Note: `contentsModel` is null until the the context is ready;\n                    // we have to handle it after `await` rather than in a `then`\n                    // to ensure we record it as recent before the widget gets disposed.\n                    this._recordAsRecentlyClosed(widget, context.contentsModel);\n                }\n            }\n            if (widget.isDisposed) {\n                return true;\n            }\n            widget.dispose();\n        }\n        return shouldClose;\n    }\n    /**\n     * Dispose of widget regardless of widget's dirty state.\n     *\n     * @param widget - The target widget.\n     */\n    onDelete(widget) {\n        widget.dispose();\n        return Promise.resolve(void 0);\n    }\n    /**\n     * Record the activated file, and its parent directory, as recently opened.\n     */\n    _recordAsRecentlyOpened(widget, model) {\n        var _a;\n        const recents = this._recentsManager;\n        if (!recents) {\n            // no-op\n            return;\n        }\n        const path = model.path;\n        const fileType = this._registry.getFileTypeForModel(model);\n        const contentType = fileType.contentType;\n        const factory = (_a = Private.factoryProperty.get(widget)) === null || _a === void 0 ? void 0 : _a.name;\n        recents.addRecent({ path, contentType, factory }, 'opened');\n        // Add the containing directory, too\n        if (contentType !== 'directory') {\n            const parent = path.lastIndexOf('/') > 0 ? path.slice(0, path.lastIndexOf('/')) : '';\n            recents.addRecent({ path: parent, contentType: 'directory' }, 'opened');\n        }\n    }\n    /**\n     * Record the activated file, and its parent directory, as recently opened.\n     */\n    _recordAsRecentlyClosed(widget, model) {\n        var _a;\n        const recents = this._recentsManager;\n        if (!recents) {\n            // no-op\n            return;\n        }\n        const path = model.path;\n        const fileType = this._registry.getFileTypeForModel(model);\n        const contentType = fileType.contentType;\n        const factory = (_a = Private.factoryProperty.get(widget)) === null || _a === void 0 ? void 0 : _a.name;\n        recents.addRecent({ path, contentType, factory }, 'closed');\n    }\n    /**\n     * Ask the user whether to close an unsaved file.\n     */\n    async _maybeClose(widget, translator) {\n        var _a, _b;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        // Bail if the model is not dirty or other widgets are using the model.)\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return Promise.resolve([true, true]);\n        }\n        let widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return Promise.resolve([true, true]);\n        }\n        // Filter by whether the factories are read only.\n        widgets = widgets.filter(widget => {\n            const factory = Private.factoryProperty.get(widget);\n            if (!factory) {\n                return false;\n            }\n            return factory.readOnly === false;\n        });\n        const fileName = widget.title.label;\n        const factory = Private.factoryProperty.get(widget);\n        const isDirty = context.model.dirty &&\n            widgets.length <= 1 &&\n            !((_a = factory === null || factory === void 0 ? void 0 : factory.readOnly) !== null && _a !== void 0 ? _a : true);\n        // Ask confirmation\n        if (this.confirmClosingDocument) {\n            const buttons = [\n                Dialog.cancelButton(),\n                Dialog.okButton({\n                    label: isDirty ? trans.__('Close and save') : trans.__('Close'),\n                    ariaLabel: isDirty\n                        ? trans.__('Close and save Document')\n                        : trans.__('Close Document')\n                })\n            ];\n            if (isDirty) {\n                buttons.splice(1, 0, Dialog.warnButton({\n                    label: trans.__('Close without saving'),\n                    ariaLabel: trans.__('Close Document without saving')\n                }));\n            }\n            const confirm = await showDialog({\n                title: trans.__('Confirmation'),\n                body: trans.__('Please confirm you want to close \"%1\".', fileName),\n                checkbox: isDirty\n                    ? null\n                    : {\n                        label: trans.__('Do not ask me again.'),\n                        caption: trans.__('If checked, no confirmation to close a document will be asked in the future.')\n                    },\n                buttons\n            });\n            if (confirm.isChecked) {\n                this.confirmClosingDocument = false;\n            }\n            return Promise.resolve([\n                confirm.button.accept,\n                isDirty ? confirm.button.displayType === 'warn' : true\n            ]);\n        }\n        else {\n            if (!isDirty) {\n                return Promise.resolve([true, true]);\n            }\n            const saveLabel = ((_b = context.contentsModel) === null || _b === void 0 ? void 0 : _b.writable)\n                ? trans.__('Save')\n                : trans.__('Save as');\n            const result = await showDialog({\n                title: trans.__('Save your work'),\n                body: trans.__('Save changes in \"%1\" before closing?', fileName),\n                buttons: [\n                    Dialog.cancelButton(),\n                    Dialog.warnButton({\n                        label: trans.__('Discard'),\n                        ariaLabel: trans.__('Discard changes to file')\n                    }),\n                    Dialog.okButton({ label: saveLabel })\n                ]\n            });\n            return [result.button.accept, result.button.displayType === 'warn'];\n        }\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _widgetDisposed(widget) {\n        const context = Private.contextProperty.get(widget);\n        if (!context) {\n            return;\n        }\n        const widgets = Private.widgetsProperty.get(context);\n        if (!widgets) {\n            return;\n        }\n        // Remove the widget.\n        ArrayExt.removeFirstOf(widgets, widget);\n        // Dispose of the context if this is the last widget using it.\n        if (!widgets.length) {\n            context.dispose();\n        }\n    }\n    /**\n     * Handle the disposal of a widget.\n     */\n    _onWidgetDisposed(widget) {\n        const disposables = Private.disposablesProperty.get(widget);\n        disposables.dispose();\n    }\n    /**\n     * Handle a file changed signal for a context.\n     */\n    _onFileChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        for (const widget of widgets) {\n            void this.setCaption(widget);\n        }\n    }\n    /**\n     * Handle a path changed signal for a context.\n     */\n    _onPathChanged(context) {\n        const widgets = Private.widgetsProperty.get(context);\n        for (const widget of widgets) {\n            void this.setCaption(widget);\n        }\n    }\n}\n/**\n * A private namespace for DocumentManager data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A private attached property for a widget context.\n     */\n    Private.contextProperty = new AttachedProperty({\n        name: 'context',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for a widget factory.\n     */\n    Private.factoryProperty = new AttachedProperty({\n        name: 'factory',\n        create: () => undefined\n    });\n    /**\n     * A private attached property for the widgets associated with a context.\n     */\n    Private.widgetsProperty = new AttachedProperty({\n        name: 'widgets',\n        create: () => []\n    });\n    /**\n     * A private attached property for a widget's disposables.\n     */\n    Private.disposablesProperty = new AttachedProperty({\n        name: 'disposables',\n        create: () => new DisposableSet()\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=widgetmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { SessionContextDialogs } from '@jupyterlab/apputils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { Context } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, find } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { SaveHandler } from './savehandler';\nimport { DocumentWidgetManager } from './widgetmanager';\n/**\n * The document manager.\n *\n * #### Notes\n * The document manager is used to register model and widget creators,\n * and the file browser uses the document manager to create widgets. The\n * document manager maintains a context for each path and model type that is\n * open, and a list of widgets for each context. The document manager is in\n * control of the proper closing and disposal of the widgets and contexts.\n */\nexport class DocumentManager {\n    /**\n     * Construct a new document manager.\n     */\n    constructor(options) {\n        var _a;\n        this._activateRequested = new Signal(this);\n        this._contexts = [];\n        this._isDisposed = false;\n        this._autosave = true;\n        this._autosaveInterval = 120;\n        this._lastModifiedCheckMargin = 500;\n        this._renameUntitledFileOnSave = true;\n        this._stateChanged = new Signal(this);\n        this.translator = options.translator || nullTranslator;\n        this.registry = options.registry;\n        this.services = options.manager;\n        this._dialogs =\n            (_a = options.sessionDialogs) !== null && _a !== void 0 ? _a : new SessionContextDialogs({ translator: options.translator });\n        this._isConnectedCallback = options.isConnectedCallback || (() => true);\n        this._opener = options.opener;\n        this._when = options.when || options.manager.ready;\n        const widgetManager = new DocumentWidgetManager({\n            registry: this.registry,\n            translator: this.translator,\n            recentsManager: options.recentsManager\n        });\n        widgetManager.activateRequested.connect(this._onActivateRequested, this);\n        widgetManager.stateChanged.connect(this._onWidgetStateChanged, this);\n        this._widgetManager = widgetManager;\n        this._setBusy = options.setBusy;\n    }\n    /**\n     * A signal emitted when one of the documents is activated.\n     */\n    get activateRequested() {\n        return this._activateRequested;\n    }\n    /**\n     * Whether to autosave documents.\n     */\n    get autosave() {\n        return this._autosave;\n    }\n    set autosave(value) {\n        if (this._autosave !== value) {\n            const oldValue = this._autosave;\n            this._autosave = value;\n            // For each existing context, start/stop the autosave handler as needed.\n            this._contexts.forEach(context => {\n                const handler = Private.saveHandlerProperty.get(context);\n                if (!handler) {\n                    return;\n                }\n                if (value === true && !handler.isActive) {\n                    handler.start();\n                }\n                else if (value === false && handler.isActive) {\n                    handler.stop();\n                }\n            });\n            this._stateChanged.emit({\n                name: 'autosave',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Determines the time interval for autosave in seconds.\n     */\n    get autosaveInterval() {\n        return this._autosaveInterval;\n    }\n    set autosaveInterval(value) {\n        if (this._autosaveInterval !== value) {\n            const oldValue = this._autosaveInterval;\n            this._autosaveInterval = value;\n            // For each existing context, set the save interval as needed.\n            this._contexts.forEach(context => {\n                const handler = Private.saveHandlerProperty.get(context);\n                if (!handler) {\n                    return;\n                }\n                handler.saveInterval = value || 120;\n            });\n            this._stateChanged.emit({\n                name: 'autosaveInterval',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Whether to ask confirmation to close a tab or not.\n     */\n    get confirmClosingDocument() {\n        return this._widgetManager.confirmClosingDocument;\n    }\n    set confirmClosingDocument(value) {\n        if (this._widgetManager.confirmClosingDocument !== value) {\n            const oldValue = this._widgetManager.confirmClosingDocument;\n            this._widgetManager.confirmClosingDocument = value;\n            this._stateChanged.emit({\n                name: 'confirmClosingDocument',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Defines max acceptable difference, in milliseconds, between last modified timestamps on disk and client\n     */\n    get lastModifiedCheckMargin() {\n        return this._lastModifiedCheckMargin;\n    }\n    set lastModifiedCheckMargin(value) {\n        if (this._lastModifiedCheckMargin !== value) {\n            const oldValue = this._lastModifiedCheckMargin;\n            this._lastModifiedCheckMargin = value;\n            // For each existing context, update the margin value.\n            this._contexts.forEach(context => {\n                context.lastModifiedCheckMargin = value;\n            });\n            this._stateChanged.emit({\n                name: 'lastModifiedCheckMargin',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Whether to ask the user to rename untitled file on first manual save.\n     */\n    get renameUntitledFileOnSave() {\n        return this._renameUntitledFileOnSave;\n    }\n    set renameUntitledFileOnSave(value) {\n        if (this._renameUntitledFileOnSave !== value) {\n            const oldValue = this._renameUntitledFileOnSave;\n            this._renameUntitledFileOnSave = value;\n            this._stateChanged.emit({\n                name: 'renameUntitledFileOnSave',\n                oldValue,\n                newValue: value\n            });\n        }\n    }\n    /**\n     * Signal triggered when an attribute changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Get whether the document manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the document manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // Clear any listeners for our signals.\n        Signal.clearData(this);\n        // Close all the widgets for our contexts and dispose the widget manager.\n        this._contexts.forEach(context => {\n            return this._widgetManager.closeWidgets(context);\n        });\n        this._widgetManager.dispose();\n        // Clear the context list.\n        this._contexts.length = 0;\n    }\n    /**\n     * Clone a widget.\n     *\n     * @param widget - The source widget.\n     *\n     * @returns A new widget or `undefined`.\n     *\n     * #### Notes\n     *  Uses the same widget factory and context as the source, or returns\n     *  `undefined` if the source widget is not managed by this manager.\n     */\n    cloneWidget(widget) {\n        return this._widgetManager.cloneWidget(widget);\n    }\n    /**\n     * Close all of the open documents.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeAll() {\n        return Promise.all(this._contexts.map(context => this._widgetManager.closeWidgets(context))).then(() => undefined);\n    }\n    /**\n     * Close the widgets associated with a given path.\n     *\n     * @param path - The target path.\n     *\n     * @returns A promise resolving when the widgets are closed.\n     */\n    closeFile(path) {\n        const close = this._contextsForPath(path).map(c => this._widgetManager.closeWidgets(c));\n        return Promise.all(close).then(x => undefined);\n    }\n    /**\n     * Get the document context for a widget.\n     *\n     * @param widget - The widget of interest.\n     *\n     * @returns The context associated with the widget, or `undefined` if no such\n     * context exists.\n     */\n    contextForWidget(widget) {\n        return this._widgetManager.contextForWidget(widget);\n    }\n    /**\n     * Copy a file.\n     *\n     * @param fromFile - The full path of the original file.\n     *\n     * @param toDir - The full path to the target directory.\n     *\n     * @returns A promise which resolves to the contents of the file.\n     */\n    copy(fromFile, toDir) {\n        return this.services.contents.copy(fromFile, toDir);\n    }\n    /**\n     * Create a new file and return the widget used to view it.\n     *\n     * @param path - The file path to create.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    createNew(path, widgetName = 'default', kernel) {\n        return this._createOrOpenDocument('create', path, widgetName, kernel);\n    }\n    /**\n     * Delete a file.\n     *\n     * @param path - The full path to the file to be deleted.\n     *\n     * @returns A promise which resolves when the file is deleted.\n     *\n     * #### Notes\n     * If there is a running session associated with the file and no other\n     * sessions are using the kernel, the session will be shut down.\n     */\n    deleteFile(path) {\n        return this.services.sessions\n            .stopIfNeeded(path)\n            .then(() => {\n            return this.services.contents.delete(path);\n        })\n            .then(() => {\n            this._contextsForPath(path).forEach(context => this._widgetManager.deleteWidgets(context));\n            return Promise.resolve(void 0);\n        });\n    }\n    /**\n     * Duplicate a file.\n     *\n     * @param path - The full path to the file to be duplicated.\n     *\n     * @returns A promise which resolves when the file is duplicated.\n     */\n    duplicate(path) {\n        const basePath = PathExt.dirname(path);\n        return this.services.contents.copy(path, basePath);\n    }\n    /**\n     * See if a widget already exists for the given path and widget name.\n     *\n     * @param path - The file path to use.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @returns The found widget, or `undefined`.\n     *\n     * #### Notes\n     * This can be used to find an existing widget instead of opening\n     * a new widget.\n     */\n    findWidget(path, widgetName = 'default') {\n        const newPath = PathExt.normalize(path);\n        let widgetNames = [widgetName];\n        if (widgetName === 'default') {\n            const factory = this.registry.defaultWidgetFactory(newPath);\n            if (!factory) {\n                return undefined;\n            }\n            widgetNames = [factory.name];\n        }\n        else if (widgetName === null) {\n            widgetNames = this.registry\n                .preferredWidgetFactories(newPath)\n                .map(f => f.name);\n        }\n        for (const context of this._contextsForPath(newPath)) {\n            for (const widgetName of widgetNames) {\n                if (widgetName !== null) {\n                    const widget = this._widgetManager.findWidget(context, widgetName);\n                    if (widget) {\n                        return widget;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a new untitled file.\n     *\n     * @param options - The file content creation options.\n     */\n    newUntitled(options) {\n        if (options.type === 'file') {\n            options.ext = options.ext || '.txt';\n        }\n        return this.services.contents.newUntitled(options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    open(path, widgetName = 'default', kernel, options) {\n        return this._createOrOpenDocument('open', path, widgetName, kernel, options);\n    }\n    /**\n     * Open a file and return the widget used to view it.\n     * Reveals an already existing editor.\n     *\n     * @param path - The file path to open.\n     *\n     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.\n     *\n     * @param kernel - An optional kernel name/id to override the default.\n     *\n     * @returns The created widget, or `undefined`.\n     *\n     * #### Notes\n     * This function will return `undefined` if a valid widget factory\n     * cannot be found.\n     */\n    openOrReveal(path, widgetName = 'default', kernel, options) {\n        const widget = this.findWidget(path, widgetName);\n        if (widget) {\n            this._opener.open(widget, {\n                type: widgetName,\n                ...options\n            });\n            return widget;\n        }\n        return this.open(path, widgetName, kernel, options !== null && options !== void 0 ? options : {});\n    }\n    /**\n     * Overwrite a file.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.\n     */\n    overwrite(oldPath, newPath) {\n        // Cleanly overwrite the file by moving it, making sure the original does\n        // not exist, and then renaming to the new path.\n        const tempPath = `${newPath}.${UUID.uuid4()}`;\n        const cb = () => this.rename(tempPath, newPath);\n        return this.rename(oldPath, tempPath)\n            .then(() => {\n            return this.deleteFile(newPath);\n        })\n            .then(cb, cb);\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldPath - The full path to the original file.\n     *\n     * @param newPath - The full path to the new file.\n     *\n     * @returns A promise containing the new file contents model.  The promise\n     * will reject if the newPath already exists.  Use [[overwrite]] to overwrite\n     * a file.\n     */\n    rename(oldPath, newPath) {\n        return this.services.contents.rename(oldPath, newPath);\n    }\n    /**\n     * Find a context for a given path and factory name.\n     */\n    _findContext(path, factoryName) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return find(this._contexts, context => {\n            return (context.path === normalizedPath && context.factoryName === factoryName);\n        });\n    }\n    /**\n     * Get the contexts for a given path.\n     *\n     * #### Notes\n     * There may be more than one context for a given path if the path is open\n     * with multiple model factories (for example, a notebook can be open with a\n     * notebook model factory and a text model factory).\n     */\n    _contextsForPath(path) {\n        const normalizedPath = this.services.contents.normalize(path);\n        return this._contexts.filter(context => context.path === normalizedPath);\n    }\n    /**\n     * Create a context from a path and a model factory.\n     */\n    _createContext(path, factory, kernelPreference) {\n        // TODO: Make it impossible to open two different contexts for the same\n        // path. Or at least prompt the closing of all widgets associated with the\n        // old context before opening the new context. This will make things much\n        // more consistent for the users, at the cost of some confusion about what\n        // models are and why sometimes they cannot open the same file in different\n        // widgets that have different models.\n        // Allow options to be passed when adding a sibling.\n        const adopter = (widget, options) => {\n            this._widgetManager.adoptWidget(context, widget);\n            // TODO should we pass the type for layout customization\n            this._opener.open(widget, options);\n        };\n        const context = new Context({\n            opener: adopter,\n            manager: this.services,\n            factory,\n            path,\n            kernelPreference,\n            setBusy: this._setBusy,\n            sessionDialogs: this._dialogs,\n            lastModifiedCheckMargin: this._lastModifiedCheckMargin,\n            translator: this.translator\n        });\n        const handler = new SaveHandler({\n            context,\n            isConnectedCallback: this._isConnectedCallback,\n            saveInterval: this.autosaveInterval\n        });\n        Private.saveHandlerProperty.set(context, handler);\n        void context.ready.then(() => {\n            if (this.autosave) {\n                handler.start();\n            }\n        });\n        context.disposed.connect(this._onContextDisposed, this);\n        this._contexts.push(context);\n        return context;\n    }\n    /**\n     * Handle a context disposal.\n     */\n    _onContextDisposed(context) {\n        ArrayExt.removeFirstOf(this._contexts, context);\n    }\n    /**\n     * Get the widget factory for a given widget name.\n     */\n    _widgetFactoryFor(path, widgetName) {\n        const { registry } = this;\n        if (widgetName === 'default') {\n            const factory = registry.defaultWidgetFactory(path);\n            if (!factory) {\n                return undefined;\n            }\n            widgetName = factory.name;\n        }\n        return registry.getWidgetFactory(widgetName);\n    }\n    /**\n     * Creates a new document, or loads one from disk, depending on the `which` argument.\n     * If `which==='create'`, then it creates a new document. If `which==='open'`,\n     * then it loads the document from disk.\n     *\n     * The two cases differ in how the document context is handled, but the creation\n     * of the widget and launching of the kernel are identical.\n     */\n    _createOrOpenDocument(which, path, widgetName = 'default', kernel, options) {\n        const widgetFactory = this._widgetFactoryFor(path, widgetName);\n        if (!widgetFactory) {\n            return undefined;\n        }\n        const modelName = widgetFactory.modelName || 'text';\n        const factory = this.registry.getModelFactory(modelName);\n        if (!factory) {\n            return undefined;\n        }\n        // Handle the kernel preference.\n        const preference = this.registry.getKernelPreference(path, widgetFactory.name, kernel);\n        let context;\n        let ready = Promise.resolve(undefined);\n        // Handle the load-from-disk case\n        if (which === 'open') {\n            // Use an existing context if available.\n            context = this._findContext(path, factory.name) || null;\n            if (!context) {\n                context = this._createContext(path, factory, preference);\n                // Populate the model, either from disk or a\n                // model backend.\n                ready = this._when.then(() => context.initialize(false));\n            }\n        }\n        else if (which === 'create') {\n            context = this._createContext(path, factory, preference);\n            // Immediately save the contents to disk.\n            ready = this._when.then(() => context.initialize(true));\n        }\n        else {\n            throw new Error(`Invalid argument 'which': ${which}`);\n        }\n        const widget = this._widgetManager.createWidget(widgetFactory, context);\n        this._opener.open(widget, { type: widgetFactory.name, ...options });\n        // If the initial opening of the context fails, dispose of the widget.\n        ready.catch(err => {\n            console.error(`Failed to initialize the context with '${factory.name}' for ${path}`, err);\n            widget.close();\n        });\n        return widget;\n    }\n    /**\n     * Handle an activateRequested signal from the widget manager.\n     */\n    _onActivateRequested(sender, args) {\n        this._activateRequested.emit(args);\n    }\n    _onWidgetStateChanged(sender, args) {\n        if (args.name === 'confirmClosingDocument') {\n            this._stateChanged.emit(args);\n        }\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a context save handler.\n     */\n    Private.saveHandlerProperty = new AttachedProperty({\n        name: 'saveHandler',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=manager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport React from 'react';\n/**\n * A pure component for rendering a file path (or activity name).\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for a file path.\n */\nfunction PathStatusComponent(props) {\n    return React.createElement(TextItem, { source: props.name, title: props.fullPath });\n}\n/**\n * A status bar item for the current file path (or activity name).\n */\nexport class PathStatus extends VDomRenderer {\n    /**\n     * Construct a new PathStatus status item.\n     */\n    constructor(opts) {\n        super(new PathStatus.Model(opts.docManager));\n        this.node.title = this.model.path;\n    }\n    /**\n     * Render the status item.\n     */\n    render() {\n        return (React.createElement(PathStatusComponent, { fullPath: this.model.path, name: this.model.name }));\n    }\n}\n/**\n * A namespace for PathStatus statics.\n */\n(function (PathStatus) {\n    /**\n     * A VDomModel for rendering the PathStatus status item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Construct a new model.\n         *\n         * @param docManager the application document manager. Used to check\n         *   whether the current widget is a document.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a title change for the current widget.\n             */\n            this._onTitleChange = (title) => {\n                const oldState = this._getAllState();\n                this._name = title.label;\n                this._triggerChange(oldState, this._getAllState());\n            };\n            /**\n             * React to a path change for the current document.\n             */\n            this._onPathChange = (_documentModel, newPath) => {\n                const oldState = this._getAllState();\n                this._path = newPath;\n                this._name = PathExt.basename(newPath);\n                this._triggerChange(oldState, this._getAllState());\n            };\n            this._path = '';\n            this._name = '';\n            this._widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current path for the application.\n         */\n        get path() {\n            return this._path;\n        }\n        /**\n         * The name of the current activity.\n         */\n        get name() {\n            return this._name;\n        }\n        /**\n         * The current widget for the application.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.pathChanged.disconnect(this._onPathChange);\n                }\n                else {\n                    oldWidget.title.changed.disconnect(this._onTitleChange);\n                }\n            }\n            const oldState = this._getAllState();\n            this._widget = widget;\n            if (this._widget === null) {\n                this._path = '';\n                this._name = '';\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    this._path = widgetContext.path;\n                    this._name = PathExt.basename(widgetContext.path);\n                    widgetContext.pathChanged.connect(this._onPathChange);\n                }\n                else {\n                    this._path = '';\n                    this._name = this._widget.title.label;\n                    this._widget.title.changed.connect(this._onTitleChange);\n                }\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._path, this._name];\n        }\n        /**\n         * Trigger a state change to rerender.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] || oldState[1] !== newState[1]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    PathStatus.Model = Model;\n})(PathStatus || (PathStatus = {}));\n//# sourceMappingURL=pathstatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport React from 'react';\n/**\n * A pure functional component for a Saving status item.\n *\n * @param props - the props for the component.\n *\n * @returns a tsx component for rendering the saving state.\n */\nfunction SavingStatusComponent(props) {\n    return React.createElement(TextItem, { source: props.fileStatus });\n}\n/**\n * The amount of time (in ms) to retain the saving completed message\n * before hiding the status item.\n */\nconst SAVING_COMPLETE_MESSAGE_MILLIS = 2000;\n/**\n * A VDomRenderer for a saving status item.\n */\nexport class SavingStatus extends VDomRenderer {\n    /**\n     * Create a new SavingStatus item.\n     */\n    constructor(opts) {\n        super(new SavingStatus.Model(opts.docManager));\n        const translator = opts.translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        this._statusMap = {\n            completed: trans.__('Saving completed'),\n            started: trans.__('Saving started'),\n            failed: trans.__('Saving failed')\n        };\n    }\n    /**\n     * Render the SavingStatus item.\n     */\n    render() {\n        if (this.model === null || this.model.status === null) {\n            return null;\n        }\n        else {\n            return (React.createElement(SavingStatusComponent, { fileStatus: this._statusMap[this.model.status] }));\n        }\n    }\n}\n/**\n * A namespace for SavingStatus statics.\n */\n(function (SavingStatus) {\n    /**\n     * A VDomModel for the SavingStatus item.\n     */\n    class Model extends VDomModel {\n        /**\n         * Create a new SavingStatus model.\n         */\n        constructor(docManager) {\n            super();\n            /**\n             * React to a saving status change from the current document widget.\n             */\n            this._onStatusChange = (_, newStatus) => {\n                this._status = newStatus;\n                if (this._status === 'completed') {\n                    setTimeout(() => {\n                        this._status = null;\n                        this.stateChanged.emit(void 0);\n                    }, SAVING_COMPLETE_MESSAGE_MILLIS);\n                    this.stateChanged.emit(void 0);\n                }\n                else {\n                    this.stateChanged.emit(void 0);\n                }\n            };\n            this._status = null;\n            this._widget = null;\n            this._status = null;\n            this.widget = null;\n            this._docManager = docManager;\n        }\n        /**\n         * The current status of the model.\n         */\n        get status() {\n            return this._status;\n        }\n        /**\n         * The current widget for the model. Any widget can be assigned,\n         * but it only has any effect if the widget is an IDocument widget\n         * known to the application document manager.\n         */\n        get widget() {\n            return this._widget;\n        }\n        set widget(widget) {\n            var _a, _b;\n            const oldWidget = this._widget;\n            if (oldWidget !== null) {\n                const oldContext = this._docManager.contextForWidget(oldWidget);\n                if (oldContext) {\n                    oldContext.saveState.disconnect(this._onStatusChange);\n                }\n                else if ((_a = this._widget.content) === null || _a === void 0 ? void 0 : _a.saveStateChanged) {\n                    this._widget.content.saveStateChanged.disconnect(this._onStatusChange);\n                }\n            }\n            this._widget = widget;\n            if (this._widget === null) {\n                this._status = null;\n            }\n            else {\n                const widgetContext = this._docManager.contextForWidget(this._widget);\n                if (widgetContext) {\n                    widgetContext.saveState.connect(this._onStatusChange);\n                }\n                else if ((_b = this._widget.content) === null || _b === void 0 ? void 0 : _b.saveStateChanged) {\n                    this._widget.content.saveStateChanged.connect(this._onStatusChange);\n                }\n            }\n        }\n    }\n    SavingStatus.Model = Model;\n})(SavingStatus || (SavingStatus = {}));\n//# sourceMappingURL=savingstatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The document registry token.\n */\nexport const IDocumentManager = new Token('@jupyterlab/docmanager:IDocumentManager', `A service for the manager for all\n  documents used by the application. Use this if you want to open and close documents,\n  create and delete files, and otherwise interact with the file system.`);\n/**\n * The document widget opener token.\n */\nexport const IDocumentWidgetOpener = new Token('@jupyterlab/docmanager:IDocumentWidgetOpener', `A service to open a widget.`);\n/**\n * The recent documents database token.\n */\nexport const IRecentsManager = new Token('@jupyterlab/docmanager:IRecentsManager', `A service providing information about recently opened and closed documents`);\n//# sourceMappingURL=tokens.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { Debouncer } from '@lumino/polling';\nimport { Signal } from '@lumino/signaling';\n/**\n * Manager for recently opened and closed documents.\n */\nexport class RecentsManager {\n    constructor(options) {\n        this._recentsChanged = new Signal(this);\n        this._recents = {\n            opened: [],\n            closed: []\n        };\n        this._isDisposed = false;\n        this._maxRecentsLength = 10;\n        this._saveDebouncer = new Debouncer(this._save.bind(this), 500);\n        this._stateDB = options.stateDB;\n        this._contentsManager = options.contents;\n        this.updateRootDir();\n        this._loadRecents().catch(r => {\n            console.error(`Failed to load recent list from state:\\n${r}`);\n        });\n    }\n    /**\n     * Whether the manager is disposed or not.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * List of recently opened items\n     */\n    get recentlyOpened() {\n        const recents = this._recents.opened || [];\n        return recents.filter(r => r.root === this._serverRoot);\n    }\n    /**\n     * List of recently opened items\n     */\n    get recentlyClosed() {\n        const recents = this._recents.closed || [];\n        return recents.filter(r => r.root === this._serverRoot);\n    }\n    /**\n     * Signal emitted when the recent list changes.\n     */\n    get changed() {\n        return this._recentsChanged;\n    }\n    /**\n     * Maximal number of recent items to list.\n     */\n    get maximalRecentsLength() {\n        return this._maxRecentsLength;\n    }\n    set maximalRecentsLength(value) {\n        this._maxRecentsLength = Math.round(Math.max(1, value));\n        let changed = false;\n        for (const type of ['opened', 'closed']) {\n            if (this._recents[type].length > this._maxRecentsLength) {\n                this._recents[type].length = this._maxRecentsLength;\n                changed = true;\n            }\n        }\n        if (changed) {\n            this._recentsChanged.emit(undefined);\n        }\n    }\n    /**\n     * Dispose recent manager resources\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n        this._saveDebouncer.dispose();\n    }\n    /**\n     * Add a new path to the recent list.\n     */\n    addRecent(document, event) {\n        const recent = {\n            ...document,\n            root: this._serverRoot\n        };\n        const recents = this._recents[event];\n        // Check if it's already present; if so remove it\n        const existingIndex = recents.findIndex(r => r.path === document.path);\n        if (existingIndex >= 0) {\n            recents.splice(existingIndex, 1);\n        }\n        // Add to the front of the list\n        recents.unshift(recent);\n        this._setRecents(recents, event);\n        this._recentsChanged.emit(undefined);\n    }\n    /**\n     * Clear the recents list\n     */\n    clearRecents() {\n        this._setRecents([], 'opened');\n        this._setRecents([], 'closed');\n        this._recentsChanged.emit(undefined);\n    }\n    /**\n     * Remove the document from recents list.\n     */\n    removeRecent(document, event) {\n        this._removeRecent(document.path, [event]);\n    }\n    /**\n     * Check if the recent item is valid, remove if it from both lists if it is not.\n     */\n    async validate(recent) {\n        const valid = await this._isValid(recent);\n        if (!valid) {\n            this._removeRecent(recent.path);\n        }\n        return valid;\n    }\n    /**\n     * Set server root dir.\n     *\n     * Note: protected to allow unit-testing.\n     */\n    updateRootDir() {\n        this._serverRoot = PageConfig.getOption('serverRoot');\n    }\n    /**\n     * Remove a path from both lists (opened and closed).\n     */\n    _removeRecent(path, lists = ['opened', 'closed']) {\n        let changed = false;\n        for (const type of lists) {\n            const recents = this._recents[type];\n            const newRecents = recents.filter(r => path !== r.path);\n            if (recents.length !== newRecents.length) {\n                this._setRecents(newRecents, type);\n                changed = true;\n            }\n        }\n        if (changed) {\n            this._recentsChanged.emit(undefined);\n        }\n    }\n    /**\n     * Check if the path of a given recent document exists.\n     */\n    async _isValid(recent) {\n        var _a;\n        try {\n            await this._contentsManager.get(recent.path, { content: false });\n        }\n        catch (e) {\n            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Set the recent list\n     * @param recents The new recent list\n     */\n    _setRecents(recents, type) {\n        this._recents[type] = recents\n            .slice(0, this.maximalRecentsLength)\n            .sort((a, b) => {\n            if (a.root === b.root) {\n                return 0;\n            }\n            else {\n                return a.root !== this._serverRoot ? 1 : -1;\n            }\n        });\n        this._saveDebouncer.invoke().catch(console.warn);\n    }\n    /**\n     * Load the recent items from the state.\n     */\n    async _loadRecents() {\n        const recents = (await this._stateDB.fetch(Private.stateDBKey)) || {\n            opened: [],\n            closed: []\n        };\n        const allRecents = [...recents.opened, ...recents.closed];\n        const invalidPaths = new Set(await this._getInvalidPaths(allRecents));\n        for (const type of ['opened', 'closed']) {\n            this._setRecents(recents[type].filter(r => !invalidPaths.has(r.path)), type);\n        }\n        this._recentsChanged.emit(undefined);\n    }\n    /**\n     * Get the list of invalid path in recents.\n     */\n    async _getInvalidPaths(recents) {\n        const invalidPathsOrNulls = await Promise.all(recents.map(async (r) => {\n            if (await this._isValid(r)) {\n                return null;\n            }\n            else {\n                return r.path;\n            }\n        }));\n        return invalidPathsOrNulls.filter(x => typeof x === 'string');\n    }\n    /**\n     * Save the recent items to the state.\n     */\n    async _save() {\n        try {\n            await this._stateDB.save(Private.stateDBKey, this._recents);\n        }\n        catch (e) {\n            console.log('Saving recents failed', e);\n        }\n    }\n}\nvar Private;\n(function (Private) {\n    /**\n     * Key reserved in the state database.\n     */\n    Private.stateDBKey = 'docmanager:recents';\n})(Private || (Private = {}));\n//# sourceMappingURL=recents.js.map"],"names":["Private","renameDialog","manager","context","translator","trans","nullTranslator","load","fileName","localPath","split","pop","showDialog","title","__","body","RenameHandler","focusNodeSelector","buttons","Dialog","cancelButton","okButton","label","ariaLabel","then","result","value","isValidFileName","rename","showErrorMessage","Error","renameFile","oldPath","newPath","catch","error","response","status","shouldOverwrite","overwrite","Promise","reject","path","options","warnButton","resolve","button","accept","name","length","test","Widget","constructor","super","node","createRenameNode","this","addClass","ext","PathExt","extname","inputNode","basename","setSelectionRange","getElementsByTagName","getValue","document","createElement","existingLabel","textContent","existingPath","nameTitle","className","appendChild","SaveHandler","_autosaveTimer","_minInterval","_interval","_isActive","_inDialog","_isDisposed","_multiplier","_context","_isConnectedCallback","isConnectedCallback","interval","saveInterval","fileChanged","connect","_setTimer","disposed","dispose","isActive","isDisposed","clearTimeout","Signal","clearData","start","stop","window","setTimeout","_save","contentsModel","writable","model","dirty","Date","getTime","save","duration","Math","max","err","console","message","DocumentWidgetManager","_activateRequested","_confirmClosingTab","_stateChanged","_registry","registry","_recentsManager","recentsManager","activateRequested","confirmClosingDocument","v","oldValue","emit","newValue","stateChanged","disconnectReceiver","createWidget","factory","widget","createNew","_initializeWidget","factoryProperty","set","disposables","DisposableSet","extender","widgetExtensions","disposable","add","disposablesProperty","_onWidgetDisposed","adoptWidget","_onFileChanged","pathChanged","_onPathChanged","ready","setCaption","widgetsProperty","get","push","MessageLoop","installMessageHook","closable","_widgetDisposed","contextProperty","findWidget","widgetName","widgets","find","contextForWidget","cloneWidget","newWidget","closeWidgets","all","map","onClose","deleteWidgets","onDelete","messageHook","handler","msg","type","_recordAsRecentlyOpened","warn","listCheckpoints","checkpoints","last","checkpoint","Time","format","last_modified","caption","readOnly","_a","shouldClose","ignoreSave","_maybeClose","saveAs","race","_recordAsRecentlyClosed","recents","contentType","getFileTypeForModel","addRecent","parent","lastIndexOf","slice","_b","filter","isDirty","splice","confirm","checkbox","isChecked","displayType","saveLabel","ArrayExt","removeFirstOf","AttachedProperty","create","DocumentManager","_contexts","_autosave","_autosaveInterval","_lastModifiedCheckMargin","_renameUntitledFileOnSave","services","_dialogs","sessionDialogs","SessionContextDialogs","_opener","opener","_when","when","widgetManager","_onActivateRequested","_onWidgetStateChanged","_widgetManager","_setBusy","setBusy","autosave","forEach","saveHandlerProperty","autosaveInterval","lastModifiedCheckMargin","renameUntitledFileOnSave","closeAll","closeFile","close","_contextsForPath","c","x","copy","fromFile","toDir","contents","kernel","_createOrOpenDocument","deleteFile","sessions","stopIfNeeded","delete","duplicate","basePath","dirname","normalize","widgetNames","defaultWidgetFactory","preferredWidgetFactories","f","newUntitled","open","openOrReveal","tempPath","UUID","uuid4","cb","_findContext","factoryName","normalizedPath","_createContext","kernelPreference","Context","_onContextDisposed","_widgetFactoryFor","getWidgetFactory","which","widgetFactory","modelName","getModelFactory","preference","getKernelPreference","undefined","initialize","sender","args","PathStatusComponent","props","TextItem","source","fullPath","PathStatus","VDomRenderer","opts","Model","docManager","render","SavingStatusComponent","fileStatus","VDomModel","_onTitleChange","oldState","_getAllState","_name","_triggerChange","_onPathChange","_documentModel","_path","_widget","_docManager","oldWidget","oldContext","disconnect","changed","widgetContext","newState","SavingStatus","_statusMap","completed","started","failed","_onStatusChange","_","newStatus","_status","saveState","content","saveStateChanged","IDocumentManager","Token","IDocumentWidgetOpener","IRecentsManager","RecentsManager","_recentsChanged","_recents","opened","closed","_maxRecentsLength","_saveDebouncer","Debouncer","bind","_stateDB","stateDB","_contentsManager","updateRootDir","_loadRecents","r","recentlyOpened","root","_serverRoot","recentlyClosed","maximalRecentsLength","round","event","recent","existingIndex","findIndex","unshift","_setRecents","clearRecents","removeRecent","_removeRecent","validate","valid","_isValid","PageConfig","getOption","lists","newRecents","e","sort","a","b","invoke","fetch","stateDBKey","allRecents","invalidPaths","Set","_getInvalidPaths","has","async","log"],"sourceRoot":""}