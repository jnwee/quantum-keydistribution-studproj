{"version":3,"file":"9530.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/cellexecutor.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/actions.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/celllist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/default-toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/executionindicator.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/history.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modelfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooklspadapter.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooktools.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/constants.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/windowing.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebookfooter.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/toc.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/searchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tracker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/truststatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widgetfactory.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell } from '@jupyterlab/cells';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { findIndex } from '@lumino/algorithm';\nimport { KernelError } from './actions';\n/**\n * Run a single notebook cell.\n *\n * @param options Cell execution options\n * @returns Execution status\n */\nexport async function runCell({ cell, notebook, notebookConfig, onCellExecuted, onCellExecutionScheduled, sessionContext, sessionDialogs, translator }) {\n    var _a;\n    translator = translator !== null && translator !== void 0 ? translator : nullTranslator;\n    const trans = translator.load('jupyterlab');\n    switch (cell.model.type) {\n        case 'markdown':\n            cell.rendered = true;\n            cell.inputHidden = false;\n            onCellExecuted({ cell, success: true });\n            break;\n        case 'code':\n            if (sessionContext) {\n                if (sessionContext.isTerminating) {\n                    await showDialog({\n                        title: trans.__('Kernel Terminating'),\n                        body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                        buttons: [Dialog.okButton()]\n                    });\n                    break;\n                }\n                if (sessionContext.pendingInput) {\n                    await showDialog({\n                        title: trans.__('Cell not executed due to pending input'),\n                        body: trans.__('The cell has not been executed to avoid kernel deadlock as there is another pending input! Type your input in the input box, press Enter and try again.'),\n                        buttons: [Dialog.okButton()]\n                    });\n                    return false;\n                }\n                if (sessionContext.hasNoKernel) {\n                    const shouldSelect = await sessionContext.startKernel();\n                    if (shouldSelect && sessionDialogs) {\n                        await sessionDialogs.selectKernel(sessionContext);\n                    }\n                }\n                if (sessionContext.hasNoKernel) {\n                    cell.model.sharedModel.transact(() => {\n                        cell.model.clearExecution();\n                    });\n                    return true;\n                }\n                const deletedCells = notebook.deletedCells;\n                onCellExecutionScheduled({ cell });\n                let ran = false;\n                try {\n                    const reply = await CodeCell.execute(cell, sessionContext, {\n                        deletedCells,\n                        recordTiming: notebookConfig.recordTiming\n                    });\n                    deletedCells.splice(0, deletedCells.length);\n                    ran = (() => {\n                        if (cell.isDisposed) {\n                            return false;\n                        }\n                        if (!reply) {\n                            return true;\n                        }\n                        if (reply.content.status === 'ok') {\n                            const content = reply.content;\n                            if (content.payload && content.payload.length) {\n                                handlePayload(content, notebook, cell);\n                            }\n                            return true;\n                        }\n                        else {\n                            throw new KernelError(reply.content);\n                        }\n                    })();\n                }\n                catch (reason) {\n                    if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                        ran = false;\n                    }\n                    else {\n                        onCellExecuted({\n                            cell,\n                            success: false,\n                            error: reason\n                        });\n                        throw reason;\n                    }\n                }\n                if (ran) {\n                    onCellExecuted({ cell, success: true });\n                }\n                return ran;\n            }\n            cell.model.sharedModel.transact(() => {\n                cell.model.clearExecution();\n            }, false);\n            break;\n        default:\n            break;\n    }\n    return Promise.resolve(true);\n}\n/**\n * Handle payloads from an execute reply.\n *\n * #### Notes\n * Payloads are deprecated and there are no official interfaces for them in\n * the kernel type definitions.\n * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n */\nfunction handlePayload(content, notebook, cell) {\n    var _a;\n    const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n        return i.source === 'set_next_input';\n    })[0];\n    if (!setNextInput) {\n        return;\n    }\n    const text = setNextInput.text;\n    const replace = setNextInput.replace;\n    if (replace) {\n        cell.model.sharedModel.setSource(text);\n        return;\n    }\n    // Create a new code cell and add as the next cell.\n    const notebookModel = notebook.sharedModel;\n    const cells = notebook.cells;\n    const index = findIndex(cells, model => model === cell.model);\n    // While this cell has no outputs and could be trusted following the letter\n    // of Jupyter trust model, its content comes from kernel and hence is not\n    // necessarily controlled by the user; if we set it as trusted, a user\n    // executing cells in succession could end up with unwanted trusted output.\n    if (index === -1) {\n        notebookModel.insertCell(notebookModel.cells.length, {\n            cell_type: 'code',\n            source: text,\n            metadata: {\n                trusted: false\n            }\n        });\n    }\n    else {\n        notebookModel.insertCell(index + 1, {\n            cell_type: 'code',\n            source: text,\n            metadata: {\n                trusted: false\n            }\n        });\n    }\n}\n//# sourceMappingURL=cellexecutor.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Clipboard, Dialog, showDialog } from '@jupyterlab/apputils';\nimport { isMarkdownCellModel, isRawCellModel, MarkdownCell } from '@jupyterlab/cells';\nimport { Notification } from '@jupyterlab/apputils';\nimport { signalToPromise } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { every, findIndex } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\nimport { runCell as defaultRunCell } from './cellexecutor';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\nexport class KernelError extends Error {\n    /**\n     * Construct the kernel error.\n     */\n    constructor(content) {\n        const errorContent = content;\n        const errorName = errorContent.ename;\n        const errorValue = errorContent.evalue;\n        super(`KernelReplyNotOK: ${errorName} ${errorValue}`);\n        this.errorName = errorName;\n        this.errorValue = errorValue;\n        this.traceback = errorContent.traceback;\n        Object.setPrototypeOf(this, KernelError.prototype);\n    }\n}\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class NotebookActions {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get executionScheduled() {\n        return Private.executionScheduled;\n    }\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    static get selectionExecuted() {\n        return Private.selectionExecuted;\n    }\n    /**\n     * A signal that emits when a cell's output is cleared.\n     */\n    static get outputCleared() {\n        return Private.outputCleared;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (NotebookActions) {\n    /**\n     * Split the active cell into two or more cells.\n     *\n     * @param notebook The target notebook widget.\n     *\n     * #### Notes\n     * It will preserve the existing mode.\n     * The last cell will be activated if no selection is found.\n     * If text was selected, the cell containing the selection will\n     * be activated.\n     * The existing selection will be cleared.\n     * The activated cell will have focus and the cursor will\n     * remain in the initial position.\n     * The leading whitespace in the second cell will be removed.\n     * If there is no content, two empty cells will be created.\n     * Both cells will have the same type as the original cell.\n     * This action can be undone.\n     */\n    function splitCell(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        // We force the notebook back in edit mode as splitting a cell\n        // requires using the cursor position within a cell (aka it was recently in edit mode)\n        // However the focus may be stolen if the action is triggered\n        // from the menu entry; switching the notebook in command mode.\n        notebook.mode = 'edit';\n        notebook.deselectAll();\n        const nbModel = notebook.model;\n        const index = notebook.activeCellIndex;\n        const child = notebook.widgets[index];\n        const editor = child.editor;\n        if (!editor) {\n            // TODO\n            return;\n        }\n        const selections = editor.getSelections();\n        const orig = child.model.sharedModel.getSource();\n        const offsets = [0];\n        let start = -1;\n        let end = -1;\n        for (let i = 0; i < selections.length; i++) {\n            // append start and end to handle selections\n            // cursors will have same start and end\n            start = editor.getOffsetAt(selections[i].start);\n            end = editor.getOffsetAt(selections[i].end);\n            if (start < end) {\n                offsets.push(start);\n                offsets.push(end);\n            }\n            else if (end < start) {\n                offsets.push(end);\n                offsets.push(start);\n            }\n            else {\n                offsets.push(start);\n            }\n        }\n        offsets.push(orig.length);\n        const cellCountAfterSplit = offsets.length - 1;\n        const clones = offsets.slice(0, -1).map((offset, offsetIdx) => {\n            const { cell_type, metadata, outputs } = child.model.sharedModel.toJSON();\n            return {\n                cell_type,\n                metadata,\n                source: orig\n                    .slice(offset, offsets[offsetIdx + 1])\n                    .replace(/^\\n+/, '')\n                    .replace(/\\n+$/, ''),\n                outputs: offsetIdx === cellCountAfterSplit - 1 && cell_type === 'code'\n                    ? outputs\n                    : undefined\n            };\n        });\n        nbModel.sharedModel.transact(() => {\n            nbModel.sharedModel.deleteCell(index);\n            nbModel.sharedModel.insertCells(index, clones);\n        });\n        // If there is a selection the selected cell will be activated\n        const activeCellDelta = start !== end ? 2 : 1;\n        notebook.activeCellIndex = index + clones.length - activeCellDelta;\n        notebook\n            .scrollToItem(notebook.activeCellIndex)\n            .then(() => {\n            var _a;\n            (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor.focus();\n        })\n            .catch(reason => {\n            // no-op\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.splitCell = splitCell;\n    /**\n     * Merge the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mergeAbove - If only one cell is selected, indicates whether to merge it\n     *    with the cell above (true) or below (false, default).\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * If only one cell is selected and `mergeAbove` is true, the above cell will be selected.\n     * If only one cell is selected and `mergeAbove` is false, the below cell will be selected.\n     * If the active cell is a code cell, its outputs will be cleared.\n     * This action can be undone.\n     * The final cell will have the same type as the active cell.\n     * If the active cell is a markdown cell, it will be unrendered.\n     */\n    function mergeCells(notebook, mergeAbove = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const toMerge = [];\n        const toDelete = [];\n        const model = notebook.model;\n        const cells = model.cells;\n        const primary = notebook.activeCell;\n        const active = notebook.activeCellIndex;\n        const attachments = {};\n        // Get the cells to merge.\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                toMerge.push(child.model.sharedModel.getSource());\n                if (index !== active) {\n                    toDelete.push(index);\n                }\n                // Collect attachments if the cell is a markdown cell or a raw cell\n                const model = child.model;\n                if (isRawCellModel(model) || isMarkdownCellModel(model)) {\n                    for (const key of model.attachments.keys) {\n                        attachments[key] = model.attachments.get(key).toJSON();\n                    }\n                }\n            }\n        });\n        // Check for only a single cell selected.\n        if (toMerge.length === 1) {\n            // Merge with the cell above when mergeAbove is true\n            if (mergeAbove === true) {\n                // Bail if it is the first cell.\n                if (active === 0) {\n                    return;\n                }\n                // Otherwise merge with the previous cell.\n                const cellModel = cells.get(active - 1);\n                toMerge.unshift(cellModel.sharedModel.getSource());\n                toDelete.push(active - 1);\n            }\n            else if (mergeAbove === false) {\n                // Bail if it is the last cell.\n                if (active === cells.length - 1) {\n                    return;\n                }\n                // Otherwise merge with the next cell.\n                const cellModel = cells.get(active + 1);\n                toMerge.push(cellModel.sharedModel.getSource());\n                toDelete.push(active + 1);\n            }\n        }\n        notebook.deselectAll();\n        const primaryModel = primary.model.sharedModel;\n        const { cell_type, metadata } = primaryModel.toJSON();\n        if (primaryModel.cell_type === 'code') {\n            // We can trust this cell because the outputs will be removed.\n            metadata.trusted = true;\n        }\n        const newModel = {\n            cell_type,\n            metadata,\n            source: toMerge.join('\\n\\n'),\n            attachments: primaryModel.cell_type === 'markdown' ||\n                primaryModel.cell_type === 'raw'\n                ? attachments\n                : undefined\n        };\n        // Make the changes while preserving history.\n        model.sharedModel.transact(() => {\n            model.sharedModel.deleteCell(active);\n            model.sharedModel.insertCell(active, newModel);\n            toDelete\n                .sort((a, b) => b - a)\n                .forEach(index => {\n                model.sharedModel.deleteCell(index);\n            });\n        });\n        // If the original cell is a markdown cell, make sure\n        // the new cell is unrendered.\n        if (primary instanceof MarkdownCell) {\n            notebook.activeCell.rendered = false;\n        }\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.mergeCells = mergeCells;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.deleteCells(notebook);\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.deleteCells = deleteCells;\n    /**\n     * Insert a new code cell above the active cell or in index 0 if the notebook is empty.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will the active cell.\n     */\n    function insertAbove(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const newIndex = notebook.activeCell ? notebook.activeCellIndex : 0;\n        model.sharedModel.insertCell(newIndex, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = newIndex;\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertAbove = insertAbove;\n    /**\n     * Insert a new code cell below the active cell or in index 0 if the notebook is empty.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will be the active cell.\n     */\n    function insertBelow(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const newIndex = notebook.activeCell ? notebook.activeCellIndex + 1 : 0;\n        model.sharedModel.insertCell(newIndex, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = newIndex;\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertBelow = insertBelow;\n    function move(notebook, shift) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const firstIndex = notebook.widgets.findIndex(w => notebook.isSelectedOrActive(w));\n        let lastIndex = notebook.widgets\n            .slice(firstIndex + 1)\n            .findIndex(w => !notebook.isSelectedOrActive(w));\n        if (lastIndex >= 0) {\n            lastIndex += firstIndex + 1;\n        }\n        else {\n            lastIndex = notebook.model.cells.length;\n        }\n        if (shift > 0) {\n            notebook.moveCell(firstIndex, lastIndex, lastIndex - firstIndex);\n        }\n        else {\n            notebook.moveCell(firstIndex, firstIndex + shift, lastIndex - firstIndex);\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    /**\n     * Move the selected cell(s) down.\n     *\n     * @param notebook = The target notebook widget.\n     */\n    function moveDown(notebook) {\n        move(notebook, 1);\n    }\n    NotebookActions.moveDown = moveDown;\n    /**\n     * Move the selected cell(s) up.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function moveUp(notebook) {\n        move(notebook, -1);\n    }\n    NotebookActions.moveUp = moveUp;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     * @param value - The target cell type.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.changeCellType(notebook, value, translator);\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.changeCellType = changeCellType;\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.run = run;\n    /**\n     * Run specified cells.\n     *\n     * @param notebook - The target notebook widget.\n     * @param cells - The cells to run.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be preserved.\n     * The mode will be changed to command.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function runCells(notebook, cells, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runCells(notebook, cells, sessionContext, sessionDialogs, translator);\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.runCells = runCells;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    async function runAndAdvance(notebook, sessionContext, sessionDialogs, translator) {\n        var _a;\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            // Do not use push here, as we want an widget insertion\n            // to make sure no placeholder widget is rendered.\n            model.sharedModel.insertCell(notebook.widgets.length, {\n                cell_type: notebook.notebookConfig.defaultCell,\n                metadata: notebook.notebookConfig.defaultCell === 'code'\n                    ? {\n                        // This is an empty cell created by user, thus is trusted\n                        trusted: true\n                    }\n                    : {}\n            });\n            notebook.activeCellIndex++;\n            if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n                await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                    // no-op\n                });\n            }\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        // If a cell is outside of viewport and scrolling is needed, the `smart`\n        // logic in `handleRunState` will choose appropriate alignment, except\n        // for the case of a small cell less than one viewport away for which it\n        // would use the `auto` heuristic, for which we set the preferred alignment\n        // to `center` as in most cases there will be space below and above a cell\n        // that is smaller than (or approximately equal to) the viewport size.\n        void Private.handleRunState(notebook, state, 'center');\n        return promise;\n    }\n    NotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    async function runAndInsert(notebook, sessionContext, sessionDialogs, translator) {\n        var _a;\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        const model = notebook.model;\n        model.sharedModel.insertCell(notebook.activeCellIndex + 1, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        notebook.activeCellIndex++;\n        if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n            await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                // no-op\n            });\n        }\n        notebook.mode = 'edit';\n        void Private.handleRunState(notebook, state, 'center');\n        return promise;\n    }\n    NotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const lastIndex = notebook.widgets.length;\n        const promise = Private.runCells(notebook, notebook.widgets, sessionContext, sessionDialogs, translator);\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook);\n        notebook.activeCellIndex = previousIndex;\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext, sessionDialogs, translator) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runCells(notebook, notebook.widgets.slice(0, notebook.activeCellIndex), sessionContext, sessionDialogs, translator);\n        notebook.deselectAll();\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const lastIndex = notebook.widgets.length;\n        const promise = Private.runCells(notebook, notebook.widgets.slice(notebook.activeCellIndex), sessionContext, sessionDialogs, translator);\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        void Private.handleRunState(notebook, state);\n        return promise;\n    }\n    NotebookActions.runAllBelow = runAllBelow;\n    /**\n     * Replaces the selection in the active cell of the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param text - The text to replace the selection.\n     */\n    function replaceSelection(notebook, text) {\n        var _a, _b, _c;\n        if (!notebook.model || !((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor)) {\n            return;\n        }\n        (_c = (_b = notebook.activeCell.editor).replaceSelection) === null || _c === void 0 ? void 0 : _c.call(_b, text);\n    }\n    NotebookActions.replaceSelection = replaceSelection;\n    /**\n     * Select the above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the first cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const footer = notebook.layout.footer;\n        if (footer && document.activeElement === footer.node) {\n            footer.node.blur();\n            notebook.mode = 'command';\n            return;\n        }\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex - 1;\n        // find first non hidden cell above current cell\n        while (possibleNextCellIndex >= 0) {\n            const possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex -= 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectAbove = selectAbove;\n    /**\n     * Select the cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the last cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let maxCellIndex = notebook.widgets.length - 1;\n        // Find last non-hidden cell\n        while (notebook.widgets[maxCellIndex].isHidden ||\n            notebook.widgets[maxCellIndex].inputHidden) {\n            maxCellIndex -= 1;\n        }\n        if (notebook.activeCellIndex === maxCellIndex) {\n            const footer = notebook.layout.footer;\n            footer === null || footer === void 0 ? void 0 : footer.node.focus();\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex + 1;\n        // find first non hidden cell below current cell\n        while (possibleNextCellIndex < maxCellIndex) {\n            let possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex += 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectBelow = selectBelow;\n    /** Insert new heading of same level above active cell.\n     *\n     * @param notebook - The target notebook widget\n     */\n    async function insertSameLevelHeadingAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let headingLevel = Private.Headings.determineHeadingLevel(notebook.activeCell, notebook);\n        if (headingLevel == -1) {\n            await Private.Headings.insertHeadingAboveCellIndex(0, 1, notebook);\n        }\n        else {\n            await Private.Headings.insertHeadingAboveCellIndex(notebook.activeCellIndex, headingLevel, notebook);\n        }\n    }\n    NotebookActions.insertSameLevelHeadingAbove = insertSameLevelHeadingAbove;\n    /** Insert new heading of same level at end of current section.\n     *\n     * @param notebook - The target notebook widget\n     */\n    async function insertSameLevelHeadingBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let headingLevel = Private.Headings.determineHeadingLevel(notebook.activeCell, notebook);\n        headingLevel = headingLevel > -1 ? headingLevel : 1;\n        let cellIdxOfHeadingBelow = Private.Headings.findLowerEqualLevelHeadingBelow(notebook.activeCell, notebook, true);\n        await Private.Headings.insertHeadingAboveCellIndex(cellIdxOfHeadingBelow == -1\n            ? notebook.model.cells.length\n            : cellIdxOfHeadingBelow, headingLevel, notebook);\n    }\n    NotebookActions.insertSameLevelHeadingBelow = insertSameLevelHeadingBelow;\n    /**\n     * Select the heading above the active cell or, if already at heading, collapse it.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the active cell is the topmost heading in collapsed state\n     * The existing selection will be cleared.\n     */\n    function selectHeadingAboveOrCollapseHeading(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let hInfoActiveCell = getHeadingInfo(notebook.activeCell);\n        // either collapse or find the right heading to jump to\n        if (hInfoActiveCell.isHeading && !hInfoActiveCell.collapsed) {\n            setHeadingCollapse(notebook.activeCell, true, notebook);\n        }\n        else {\n            let targetHeadingCellIdx = Private.Headings.findLowerEqualLevelParentHeadingAbove(notebook.activeCell, notebook, true);\n            if (targetHeadingCellIdx > -1) {\n                notebook.activeCellIndex = targetHeadingCellIdx;\n            }\n        }\n        // clear selection and handle state\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectHeadingAboveOrCollapseHeading = selectHeadingAboveOrCollapseHeading;\n    /**\n     * Select the heading below the active cell or, if already at heading, expand it.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the active cell is the last heading in expanded state\n     * The existing selection will be cleared.\n     */\n    function selectHeadingBelowOrExpandHeading(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let hInfo = getHeadingInfo(notebook.activeCell);\n        if (hInfo.isHeading && hInfo.collapsed) {\n            setHeadingCollapse(notebook.activeCell, false, notebook);\n        }\n        else {\n            let targetHeadingCellIdx = Private.Headings.findHeadingBelow(notebook.activeCell, notebook, true // return index of heading cell\n            );\n            if (targetHeadingCellIdx > -1) {\n                notebook.activeCellIndex = targetHeadingCellIdx;\n            }\n        }\n        notebook.deselectAll();\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectHeadingBelowOrExpandHeading = selectHeadingBelowOrExpandHeading;\n    /**\n     * Extend the selection to the cell above.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toTop - If true, denotes selection to extend to the top.\n     *\n     * #### Notes\n     * This is a no-op if the first cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionAbove(notebook, toTop = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toTop is true, if yes, selection is made to the top.\n        if (toTop) {\n            notebook.extendContiguousSelectionTo(0);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionAbove = extendSelectionAbove;\n    /**\n     * Extend the selection to the cell below.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toBottom - If true, denotes selection to extend to the bottom.\n     *\n     * #### Notes\n     * This is a no-op if the last cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionBelow(notebook, toBottom = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toBottom is true, if yes selection is made to the bottom.\n        if (toBottom) {\n            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionBelow = extendSelectionBelow;\n    /**\n     * Select all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function selectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n    }\n    NotebookActions.selectAll = selectAll;\n    /**\n     * Deselect all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function deselectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.deselectAll();\n    }\n    NotebookActions.deselectAll = deselectAll;\n    /**\n     * Copy the selected cell(s) data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function copy(notebook) {\n        Private.copyOrCut(notebook, false);\n    }\n    NotebookActions.copy = copy;\n    /**\n     * Cut the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This action can be undone.\n     * A new code cell is added if all cells are cut.\n     */\n    function cut(notebook) {\n        Private.copyOrCut(notebook, true);\n    }\n    NotebookActions.cut = cut;\n    /**\n     * Paste cells from the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function paste(notebook, mode = 'below') {\n        const clipboard = Clipboard.getInstance();\n        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        const values = clipboard.getData(JUPYTER_CELL_MIME);\n        addCells(notebook, mode, values, true);\n        void focusActiveCell(notebook);\n    }\n    NotebookActions.paste = paste;\n    /**\n     * Duplicate selected cells in the notebook without using the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function duplicate(notebook, mode = 'below') {\n        const values = Private.selectedCells(notebook);\n        if (!values || values.length === 0) {\n            return;\n        }\n        addCells(notebook, mode, values, false); // Cells not from the clipboard\n    }\n    NotebookActions.duplicate = duplicate;\n    /**\n     * Adds cells to the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * @param values  The cells to add to the notebook.\n     *\n     * @param cellsFromClipboard  True if the cells were sourced from the clipboard.\n     *\n     * #### Notes\n     * The last added cell becomes the active cell.\n     * This is a no-op if values is an empty array.\n     * This action can be undone.\n     */\n    function addCells(notebook, mode = 'below', values, cellsFromClipboard = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        notebook.mode = 'command';\n        let index = 0;\n        const prevActiveCellIndex = notebook.activeCellIndex;\n        model.sharedModel.transact(() => {\n            // Set the starting index of the paste operation depending upon the mode.\n            switch (mode) {\n                case 'below':\n                    index = notebook.activeCellIndex + 1;\n                    break;\n                case 'belowSelected':\n                    notebook.widgets.forEach((child, childIndex) => {\n                        if (notebook.isSelectedOrActive(child)) {\n                            index = childIndex + 1;\n                        }\n                    });\n                    break;\n                case 'above':\n                    index = notebook.activeCellIndex;\n                    break;\n                case 'replace': {\n                    // Find the cells to delete.\n                    const toDelete = [];\n                    notebook.widgets.forEach((child, index) => {\n                        const deletable = child.model.sharedModel.getMetadata('deletable') !== false;\n                        if (notebook.isSelectedOrActive(child) && deletable) {\n                            toDelete.push(index);\n                        }\n                    });\n                    // If cells are not deletable, we may not have anything to delete.\n                    if (toDelete.length > 0) {\n                        // Delete the cells as one undo event.\n                        toDelete.reverse().forEach(i => {\n                            model.sharedModel.deleteCell(i);\n                        });\n                    }\n                    index = toDelete[0];\n                    break;\n                }\n                default:\n                    break;\n            }\n            model.sharedModel.insertCells(index, values.map(cell => {\n                cell.id =\n                    cell.cell_type === 'code' &&\n                        notebook.lastClipboardInteraction === 'cut' &&\n                        typeof cell.id === 'string'\n                        ? cell.id\n                        : undefined;\n                return cell;\n            }));\n        });\n        notebook.activeCellIndex = prevActiveCellIndex + values.length;\n        notebook.deselectAll();\n        if (cellsFromClipboard) {\n            notebook.lastClipboardInteraction = 'paste';\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    /**\n     * Undo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to undo.\n     */\n    function undo(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.undo();\n        notebook.deselectAll();\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.undo = undo;\n    /**\n     * Redo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to redo.\n     */\n    function redo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.redo();\n        notebook.deselectAll();\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.redo = redo;\n    /**\n     * Toggle the line number of all cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The original state is based on the state of the active cell.\n     * The `mode` of the widget will be preserved.\n     */\n    function toggleAllLineNumbers(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const config = notebook.editorConfig;\n        const lineNumbers = !(config.code.lineNumbers &&\n            config.markdown.lineNumbers &&\n            config.raw.lineNumbers);\n        const newConfig = {\n            code: { ...config.code, lineNumbers },\n            markdown: { ...config.markdown, lineNumbers },\n            raw: { ...config.raw, lineNumbers }\n        };\n        notebook.editorConfig = newConfig;\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;\n    /**\n     * Clear the code outputs of the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let index = -1;\n        for (const cell of notebook.model.cells) {\n            const child = notebook.widgets[++index];\n            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {\n                cell.sharedModel.transact(() => {\n                    cell.clearExecution();\n                    child.outputHidden = false;\n                }, false);\n                Private.outputCleared.emit({ notebook, cell: child });\n            }\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearOutputs = clearOutputs;\n    /**\n     * Clear all the code outputs on the widget.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let index = -1;\n        for (const cell of notebook.model.cells) {\n            const child = notebook.widgets[++index];\n            if (cell.type === 'code') {\n                cell.sharedModel.transact(() => {\n                    cell.clearExecution();\n                    child.outputHidden = false;\n                }, false);\n                Private.outputCleared.emit({ notebook, cell: child });\n            }\n        }\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearAllOutputs = clearAllOutputs;\n    /**\n     * Hide the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.hideCode = hideCode;\n    /**\n     * Show the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.showCode = showCode;\n    /**\n     * Hide the code on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.hideAllCode = hideAllCode;\n    /**\n     * Show the code on all code cells.\n     *\n     * @param notebook The target notebook widget.\n     */\n    function showAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllCode = showAllCode;\n    /**\n     * Hide the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideOutput = hideOutput;\n    /**\n     * Show the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.showOutput = showOutput;\n    /**\n     * Toggle output visibility on selected code cells.\n     * If at least one output is visible, all outputs are hidden.\n     * If no outputs are visible, all outputs are made visible.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function toggleOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        for (const cell of notebook.widgets) {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                if (cell.outputHidden === false) {\n                    // We found at least one visible output; hide outputs for this cell\n                    return hideOutput(notebook);\n                }\n            }\n        }\n        // We found no selected cells or no selected cells with visible output;\n        // show outputs for selected cells\n        return showOutput(notebook);\n    }\n    NotebookActions.toggleOutput = toggleOutput;\n    /**\n     * Hide the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideAllOutputs = hideAllOutputs;\n    /**\n     * Render side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderSideBySide(notebook) {\n        notebook.renderingLayout = 'side-by-side';\n    }\n    NotebookActions.renderSideBySide = renderSideBySide;\n    /**\n     * Render not side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderDefault(notebook) {\n        notebook.renderingLayout = 'default';\n    }\n    NotebookActions.renderDefault = renderDefault;\n    /**\n     * Show the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllOutputs = showAllOutputs;\n    /**\n     * Enable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function enableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = true;\n            }\n        });\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.enableOutputScrolling = enableOutputScrolling;\n    /**\n     * Disable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function disableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = false;\n            }\n        });\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.disableOutputScrolling = disableOutputScrolling;\n    /**\n     * Go to the last cell that is run or current if it is running.\n     *\n     * Note: This requires execution timing to be toggled on or this will have\n     * no effect.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function selectLastRunCell(notebook) {\n        let latestTime = null;\n        let latestCellIdx = null;\n        notebook.widgets.forEach((cell, cellIndx) => {\n            if (cell.model.type === 'code') {\n                const execution = cell.model.getMetadata('execution');\n                if (execution &&\n                    JSONExt.isObject(execution) &&\n                    execution['iopub.status.busy'] !== undefined) {\n                    // The busy status is used as soon as a request is received:\n                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html\n                    const timestamp = execution['iopub.status.busy'].toString();\n                    if (timestamp) {\n                        const startTime = new Date(timestamp);\n                        if (!latestTime || startTime >= latestTime) {\n                            latestTime = startTime;\n                            latestCellIdx = cellIndx;\n                        }\n                    }\n                }\n            }\n        });\n        if (latestCellIdx !== null) {\n            notebook.activeCellIndex = latestCellIdx;\n        }\n    }\n    NotebookActions.selectLastRunCell = selectLastRunCell;\n    /**\n     * Set the markdown header level.\n     *\n     * @param notebook - The target notebook widget.\n     * @param level - The header level.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * All selected cells will be switched to markdown.\n     * The level will be clamped between 1 and 6.\n     * If there is an existing header, it will be replaced.\n     * There will always be one blank space after the header.\n     * The cells will be unrendered.\n     */\n    function setMarkdownHeader(notebook, level, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        level = Math.min(Math.max(level, 1), 6);\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                Private.setMarkdownHeader(cells.get(index), level);\n            }\n        });\n        Private.changeCellType(notebook, 'markdown', translator);\n        void Private.handleState(notebook, state);\n    }\n    NotebookActions.setMarkdownHeader = setMarkdownHeader;\n    /**\n     * Collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function collapseAllHeadings(notebook) {\n        const state = Private.getState(notebook);\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, true, notebook);\n                NotebookActions.setCellCollapse(cell, true);\n            }\n        }\n        notebook.activeCellIndex = 0;\n        void Private.handleState(notebook, state, true);\n    }\n    NotebookActions.collapseAllHeadings = collapseAllHeadings;\n    /**\n     * Un-collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function expandAllHeadings(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, false, notebook);\n                // similar to collapseAll.\n                NotebookActions.setCellCollapse(cell, false);\n            }\n        }\n    }\n    NotebookActions.expandAllHeadings = expandAllHeadings;\n    function findNearestParentHeader(cell, notebook) {\n        const index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return;\n        }\n        // Finds the nearest header above the given cell. If the cell is a header itself, it does not return itself;\n        // this can be checked directly by calling functions.\n        if (index >= notebook.widgets.length) {\n            return;\n        }\n        let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);\n        for (let cellN = index - 1; cellN >= 0; cellN--) {\n            if (cellN < notebook.widgets.length) {\n                let hInfo = getHeadingInfo(notebook.widgets[cellN]);\n                if (hInfo.isHeading &&\n                    hInfo.headingLevel < childHeaderInfo.headingLevel) {\n                    return notebook.widgets[cellN];\n                }\n            }\n        }\n        // else no parent header found.\n        return;\n    }\n    /**\n     * Finds the \"parent\" heading of the given cell and expands.\n     * Used for the case that a cell becomes active that is within a collapsed heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function expandParent(cell, notebook) {\n        let nearestParentCell = findNearestParentHeader(cell, notebook);\n        if (!nearestParentCell) {\n            return;\n        }\n        if (!getHeadingInfo(nearestParentCell).collapsed &&\n            !nearestParentCell.isHidden) {\n            return;\n        }\n        if (nearestParentCell.isHidden) {\n            expandParent(nearestParentCell, notebook);\n        }\n        if (getHeadingInfo(nearestParentCell).collapsed) {\n            setHeadingCollapse(nearestParentCell, false, notebook);\n        }\n    }\n    NotebookActions.expandParent = expandParent;\n    /**\n     * Finds the next heading that isn't a child of the given markdown heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function findNextParentHeading(cell, notebook) {\n        let index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return -1;\n        }\n        let childHeaderInfo = getHeadingInfo(cell);\n        for (index = index + 1; index < notebook.widgets.length; index++) {\n            let hInfo = getHeadingInfo(notebook.widgets[index]);\n            if (hInfo.isHeading &&\n                hInfo.headingLevel <= childHeaderInfo.headingLevel) {\n                return index;\n            }\n        }\n        // else no parent header found. return the index of the last cell\n        return notebook.widgets.length;\n    }\n    NotebookActions.findNextParentHeading = findNextParentHeading;\n    /**\n     * Set the given cell and ** all \"child\" cells **\n     * to the given collapse / expand if cell is\n     * a markdown header.\n     *\n     * @param cell - The cell\n     * @param collapsing - Whether to collapse or expand the cell\n     * @param notebook - The target notebook widget.\n     */\n    function setHeadingCollapse(cell, collapsing, notebook) {\n        const which = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (which === -1) {\n            return -1;\n        }\n        if (!notebook.widgets.length) {\n            return which + 1;\n        }\n        let selectedHeadingInfo = NotebookActions.getHeadingInfo(cell);\n        if (cell.isHidden ||\n            !(cell instanceof MarkdownCell) ||\n            !selectedHeadingInfo.isHeading) {\n            // otherwise collapsing and uncollapsing already hidden stuff can\n            // cause some funny looking bugs.\n            return which + 1;\n        }\n        let localCollapsed = false;\n        let localCollapsedLevel = 0;\n        // iterate through all cells after the active cell.\n        let cellNum;\n        for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {\n            let subCell = notebook.widgets[cellNum];\n            let subCellHeadingInfo = NotebookActions.getHeadingInfo(subCell);\n            if (subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {\n                // then reached an equivalent or higher heading level than the\n                // original the end of the collapse.\n                cellNum -= 1;\n                break;\n            }\n            if (localCollapsed &&\n                subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= localCollapsedLevel) {\n                // then reached the end of the local collapsed, so unset NotebookActions.\n                localCollapsed = false;\n            }\n            if (collapsing || localCollapsed) {\n                // then no extra handling is needed for further locally collapsed\n                // headings.\n                subCell.setHidden(true);\n                continue;\n            }\n            if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {\n                localCollapsed = true;\n                localCollapsedLevel = subCellHeadingInfo.headingLevel;\n                // but don't collapse the locally collapsed heading, so continue to\n                // expand the heading. This will get noticed in the next round.\n            }\n            subCell.setHidden(false);\n        }\n        if (cellNum === notebook.widgets.length) {\n            cell.numberChildNodes = cellNum - which - 1;\n        }\n        else {\n            cell.numberChildNodes = cellNum - which;\n        }\n        NotebookActions.setCellCollapse(cell, collapsing);\n        return cellNum + 1;\n    }\n    NotebookActions.setHeadingCollapse = setHeadingCollapse;\n    /**\n     * Toggles the collapse state of the active cell of the given notebook\n     * and ** all of its \"child\" cells ** if the cell is a heading.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function toggleCurrentHeadingCollapse(notebook) {\n        if (!notebook.activeCell || notebook.activeCellIndex === undefined) {\n            return;\n        }\n        let headingInfo = NotebookActions.getHeadingInfo(notebook.activeCell);\n        if (headingInfo.isHeading) {\n            // Then toggle!\n            NotebookActions.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);\n        }\n        notebook.scrollToItem(notebook.activeCellIndex).catch(reason => {\n            // no-op\n        });\n    }\n    NotebookActions.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;\n    /**\n     * If cell is a markdown heading, sets the headingCollapsed field,\n     * and otherwise hides the cell.\n     *\n     * @param cell - The cell to collapse / expand\n     * @param collapsing - Whether to collapse or expand the given cell\n     */\n    function setCellCollapse(cell, collapsing) {\n        if (cell instanceof MarkdownCell) {\n            cell.headingCollapsed = collapsing;\n        }\n        else {\n            cell.setHidden(collapsing);\n        }\n    }\n    NotebookActions.setCellCollapse = setCellCollapse;\n    /**\n     * If given cell is a markdown heading, returns the heading level.\n     * If given cell is not markdown, returns 7 (there are only 6 levels of markdown headings)\n     *\n     * @param cell - The target cell widget.\n     */\n    function getHeadingInfo(cell) {\n        if (!(cell instanceof MarkdownCell)) {\n            return { isHeading: false, headingLevel: 7 };\n        }\n        let level = cell.headingInfo.level;\n        let collapsed = cell.headingCollapsed;\n        return { isHeading: level > 0, headingLevel: level, collapsed: collapsed };\n    }\n    NotebookActions.getHeadingInfo = getHeadingInfo;\n    /**\n     * Trust the notebook after prompting the user.\n     *\n     * @param notebook - The target notebook widget.\n     * @param translator - The application translator.\n     *\n     * @returns a promise that resolves when the transaction is finished.\n     *\n     * #### Notes\n     * No dialog will be presented if the notebook is already trusted.\n     */\n    function trust(notebook, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        if (!notebook.model) {\n            return Promise.resolve();\n        }\n        // Do nothing if already trusted.\n        const trusted = every(notebook.model.cells, cell => cell.trusted);\n        // FIXME\n        const trustMessage = (React.createElement(\"p\", null,\n            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you open it.'),\n            React.createElement(\"br\", null),\n            trans.__('Selecting \"Trust\" will re-render this notebook in a trusted state.'),\n            React.createElement(\"br\", null),\n            trans.__('For more information, see'),\n            ' ',\n            React.createElement(\"a\", { href: \"https://jupyter-server.readthedocs.io/en/stable/operators/security.html\", target: \"_blank\", rel: \"noopener noreferrer\" }, trans.__('the Jupyter security documentation')),\n            \".\"));\n        if (trusted) {\n            return showDialog({\n                body: trans.__('Notebook is already trusted'),\n                buttons: [Dialog.okButton()]\n            }).then(() => undefined);\n        }\n        return showDialog({\n            body: trustMessage,\n            title: trans.__('Trust this notebook?'),\n            buttons: [\n                Dialog.cancelButton(),\n                Dialog.warnButton({\n                    label: trans.__('Trust'),\n                    ariaLabel: trans.__('Confirm Trusting this notebook')\n                })\n            ] // FIXME?\n        }).then(result => {\n            if (result.button.accept) {\n                if (notebook.model) {\n                    for (const cell of notebook.model.cells) {\n                        cell.trusted = true;\n                    }\n                }\n            }\n        });\n    }\n    NotebookActions.trust = trust;\n    /**\n     * If the notebook has an active cell, focus it.\n     *\n     * @param notebook The target notebook widget\n     * @param options Optional options to change the behavior of this function\n     * @param options.waitUntilReady If true, do not call focus until activeCell.ready is resolved\n     * @param options.preventScroll If true, do not scroll the active cell into view\n     *\n     * @returns a promise that resolves when focus has been called on the active\n     * cell's node.\n     *\n     * #### Notes\n     * By default, waits until after the active cell has been attached unless\n     * called with { waitUntilReady: false }\n     */\n    async function focusActiveCell(notebook, options = { waitUntilReady: true, preventScroll: false }) {\n        const { activeCell } = notebook;\n        const { waitUntilReady, preventScroll } = options;\n        if (!activeCell) {\n            return;\n        }\n        if (waitUntilReady) {\n            await activeCell.ready;\n        }\n        if (notebook.isDisposed || activeCell.isDisposed) {\n            return;\n        }\n        activeCell.node.focus({\n            preventScroll\n        });\n    }\n    NotebookActions.focusActiveCell = focusActiveCell;\n    /*\n     * Access last notebook history.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    async function accessPreviousHistory(notebook) {\n        if (!notebook.notebookConfig.accessKernelHistory) {\n            return;\n        }\n        const activeCell = notebook.activeCell;\n        if (activeCell) {\n            if (notebook.kernelHistory) {\n                const previousHistory = await notebook.kernelHistory.back(activeCell);\n                notebook.kernelHistory.updateEditor(activeCell, previousHistory);\n            }\n        }\n    }\n    NotebookActions.accessPreviousHistory = accessPreviousHistory;\n    /**\n     * Access next notebook history.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    async function accessNextHistory(notebook) {\n        if (!notebook.notebookConfig.accessKernelHistory) {\n            return;\n        }\n        const activeCell = notebook.activeCell;\n        if (activeCell) {\n            if (notebook.kernelHistory) {\n                const nextHistory = await notebook.kernelHistory.forward(activeCell);\n                notebook.kernelHistory.updateEditor(activeCell, nextHistory);\n            }\n        }\n    }\n    NotebookActions.accessNextHistory = accessNextHistory;\n})(NotebookActions || (NotebookActions = {}));\n/**\n * Set the notebook cell executor and the related signals.\n */\nexport function setCellExecutor(executor) {\n    if (Private.executor) {\n        throw new Error('Cell executor can only be set once.');\n    }\n    Private.executor = executor;\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    Private.executed = new Signal({});\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    Private.executionScheduled = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.selectionExecuted = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.outputCleared = new Signal({});\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        var _a, _b;\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCellId: (_b = (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model.id) !== null && _b !== void 0 ? _b : null\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    async function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, activeCellIndex } = notebook;\n        if (scrollIfNeeded && activeCell) {\n            await notebook.scrollToItem(activeCellIndex, 'auto', 0).catch(reason => {\n                // no-op\n            });\n        }\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    async function handleRunState(notebook, state, alignPreference) {\n        const { activeCell, activeCellIndex } = notebook;\n        if (activeCell) {\n            await notebook\n                .scrollToItem(activeCellIndex, 'smart', 0, alignPreference)\n                .catch(reason => {\n                // no-op\n            });\n        }\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Run the selected cells.\n     *\n     * @param notebook Notebook\n     * @param cells Cells to run\n     * @param sessionContext Notebook session context\n     * @param sessionDialogs Session dialogs\n     * @param translator Application translator\n     */\n    function runCells(notebook, cells, sessionContext, sessionDialogs, translator) {\n        const lastCell = cells[-1];\n        notebook.mode = 'command';\n        let initializingDialogShown = false;\n        return Promise.all(cells.map(cell => {\n            if (cell.model.type === 'code' &&\n                notebook.notebookConfig.enableKernelInitNotification &&\n                sessionContext &&\n                sessionContext.kernelDisplayStatus === 'initializing' &&\n                !initializingDialogShown) {\n                initializingDialogShown = true;\n                translator = translator || nullTranslator;\n                const trans = translator.load('jupyterlab');\n                Notification.emit(trans.__(`Kernel '${sessionContext.kernelDisplayName}' for '${sessionContext.path}' is still initializing. You can run code cells when the kernel has initialized.`), 'warning', {\n                    autoClose: false\n                });\n                return Promise.resolve(false);\n            }\n            if (cell.model.type === 'code' &&\n                notebook.notebookConfig.enableKernelInitNotification &&\n                initializingDialogShown) {\n                return Promise.resolve(false);\n            }\n            return runCell(notebook, cell, sessionContext, sessionDialogs, translator);\n        }))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell\n            });\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message.startsWith('KernelReplyNotOK')) {\n                cells.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.model.executionState = 'idle';\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell\n            });\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runCells = runCells;\n    /**\n     * Run the selected cells.\n     *\n     * @param notebook Notebook\n     * @param sessionContext Notebook session context\n     * @param sessionDialogs Session dialogs\n     * @param translator Application translator\n     */\n    function runSelected(notebook, sessionContext, sessionDialogs, translator) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return runCells(notebook, selected, sessionContext, sessionDialogs, translator);\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    async function runCell(notebook, cell, sessionContext, sessionDialogs, translator) {\n        if (!Private.executor) {\n            console.warn('Requesting cell execution without any cell executor defined. Falling back to default execution.');\n        }\n        const options = {\n            cell,\n            notebook: notebook.model,\n            notebookConfig: notebook.notebookConfig,\n            onCellExecuted: args => {\n                Private.executed.emit({ notebook, ...args });\n            },\n            onCellExecutionScheduled: args => {\n                Private.executionScheduled.emit({ notebook, ...args });\n            },\n            sessionContext,\n            sessionDialogs,\n            translator\n        };\n        return Private.executor ? Private.executor.runCell(options) : defaultRunCell(options);\n    }\n    /**\n     * Get the selected cell(s) without affecting the clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns A list of 0 or more selected cells\n     */\n    function selectedCells(notebook) {\n        return notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n    }\n    Private.selectedCells = selectedCells;\n    /**\n     * Copy or cut the selected cell data to the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param cut - True if the cells should be cut, false if they should be copied.\n     */\n    function copyOrCut(notebook, cut) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = getState(notebook);\n        const clipboard = Clipboard.getInstance();\n        notebook.mode = 'command';\n        clipboard.clear();\n        const data = Private.selectedCells(notebook);\n        clipboard.setData(JUPYTER_CELL_MIME, data);\n        if (cut) {\n            deleteCells(notebook);\n        }\n        else {\n            notebook.deselectAll();\n        }\n        if (cut) {\n            notebook.lastClipboardInteraction = 'cut';\n        }\n        else {\n            notebook.lastClipboardInteraction = 'copy';\n        }\n        void handleState(notebook, state);\n    }\n    Private.copyOrCut = copyOrCut;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value, translator) {\n        const notebookSharedModel = notebook.model.sharedModel;\n        notebook.widgets.forEach((child, index) => {\n            if (!notebook.isSelectedOrActive(child)) {\n                return;\n            }\n            if (child.model.type === 'code' &&\n                child.outputArea.pendingInput) {\n                translator = translator || nullTranslator;\n                const trans = translator.load('jupyterlab');\n                // Do not permit changing cell type when input is pending\n                void showDialog({\n                    title: trans.__('Cell type not changed due to pending input'),\n                    body: trans.__('The cell type has not been changed to avoid kernel deadlock as this cell has pending input! Submit your pending input and try again.'),\n                    buttons: [Dialog.okButton()]\n                });\n                return;\n            }\n            if (child.model.getMetadata('editable') == false) {\n                translator = translator || nullTranslator;\n                const trans = translator.load('jupyterlab');\n                // Do not permit changing cell type when the cell is readonly\n                void showDialog({\n                    title: trans.__('Cell is read-only'),\n                    body: trans.__('The cell is read-only, its type cannot be changed!'),\n                    buttons: [Dialog.okButton()]\n                });\n                return;\n            }\n            if (child.model.type !== value) {\n                const raw = child.model.toJSON();\n                notebookSharedModel.transact(() => {\n                    notebookSharedModel.deleteCell(index);\n                    if (value === 'code') {\n                        // After change of type outputs are deleted so cell can be trusted.\n                        raw.metadata.trusted = true;\n                    }\n                    else {\n                        // Otherwise clear the metadata as trusted is only \"valid\" on code\n                        // cells (since other cell types cannot have outputs).\n                        raw.metadata.trusted = undefined;\n                    }\n                    const newCell = notebookSharedModel.insertCell(index, {\n                        cell_type: value,\n                        source: raw.source,\n                        metadata: raw.metadata\n                    });\n                    if (raw.attachments && ['markdown', 'raw'].includes(value)) {\n                        newCell.attachments =\n                            raw.attachments;\n                    }\n                });\n            }\n            if (value === 'markdown') {\n                // Fetch the new widget and unrender it.\n                child = notebook.widgets[index];\n                child.rendered = false;\n            }\n        });\n        notebook.deselectAll();\n    }\n    Private.changeCellType = changeCellType;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * If the last cell is deleted, then the previous one will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        const model = notebook.model;\n        const sharedModel = model.sharedModel;\n        const toDelete = [];\n        notebook.mode = 'command';\n        // Find the cells to delete.\n        notebook.widgets.forEach((child, index) => {\n            var _a;\n            const deletable = child.model.getMetadata('deletable') !== false;\n            if (notebook.isSelectedOrActive(child) && deletable) {\n                toDelete.push(index);\n                (_a = notebook.model) === null || _a === void 0 ? void 0 : _a.deletedCells.push(child.model.id);\n            }\n        });\n        // If cells are not deletable, we may not have anything to delete.\n        if (toDelete.length > 0) {\n            // Delete the cells as one undo event.\n            sharedModel.transact(() => {\n                // Delete cells in reverse order to maintain the correct indices.\n                toDelete.reverse().forEach(index => {\n                    sharedModel.deleteCell(index);\n                });\n                // Add a new cell if the notebook is empty. This is done\n                // within the compound operation to make the deletion of\n                // a notebook's last cell undoable.\n                if (sharedModel.cells.length == toDelete.length) {\n                    sharedModel.insertCell(0, {\n                        cell_type: notebook.notebookConfig.defaultCell,\n                        metadata: notebook.notebookConfig.defaultCell === 'code'\n                            ? {\n                                // This is an empty cell created in empty notebook, thus is trusted\n                                trusted: true\n                            }\n                            : {}\n                    });\n                }\n            });\n            // Select the *first* interior cell not deleted or the cell\n            // *after* the last selected cell.\n            // Note: The activeCellIndex is clamped to the available cells,\n            // so if the last cell is deleted the previous cell will be activated.\n            // The *first* index is the index of the last cell in the initial\n            // toDelete list due to the `reverse` operation above.\n            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;\n        }\n        // Deselect any remaining, undeletable cells. Do this even if we don't\n        // delete anything so that users are aware *something* happened.\n        notebook.deselectAll();\n    }\n    Private.deleteCells = deleteCells;\n    /**\n     * Set the markdown header level of a cell.\n     */\n    function setMarkdownHeader(cell, level) {\n        // Remove existing header or leading white space.\n        let source = cell.sharedModel.getSource();\n        const regex = /^(#+\\s*)|^(\\s*)/;\n        const newHeader = Array(level + 1).join('#') + ' ';\n        const matches = regex.exec(source);\n        if (matches) {\n            source = source.slice(matches[0].length);\n        }\n        cell.sharedModel.setSource(newHeader + source);\n    }\n    Private.setMarkdownHeader = setMarkdownHeader;\n    /** Functionality related to collapsible headings */\n    let Headings;\n    (function (Headings) {\n        /** Find the heading that is parent to cell.\n         *\n         * @param childCell - The cell that is child to the sought heading\n         * @param notebook - The target notebook widget\n         * @param includeChildCell [default=false] - if set to true and childCell is a heading itself, the childCell will be returned\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the parent heading or (-1 | null) if there is no parent heading.\n         */\n        function findParentHeading(childCell, notebook, includeChildCell = false, returnIndex = false) {\n            let cellIdx = notebook.widgets.indexOf(childCell) - (includeChildCell ? 1 : 0);\n            while (cellIdx >= 0) {\n                let headingInfo = NotebookActions.getHeadingInfo(notebook.widgets[cellIdx]);\n                if (headingInfo.isHeading) {\n                    return returnIndex ? cellIdx : notebook.widgets[cellIdx];\n                }\n                cellIdx--;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findParentHeading = findParentHeading;\n        /** Find heading above with leq level than baseCell heading level.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findLowerEqualLevelParentHeadingAbove(baseCell, notebook, returnIndex = false) {\n            let baseHeadingLevel = Private.Headings.determineHeadingLevel(baseCell, notebook);\n            if (baseHeadingLevel == -1) {\n                baseHeadingLevel = 1; // if no heading level can be determined, assume we're on level 1\n            }\n            // find the heading above with heading level <= baseHeadingLevel and return its index\n            let cellIdx = notebook.widgets.indexOf(baseCell) - 1;\n            while (cellIdx >= 0) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading &&\n                    headingInfo.headingLevel <= baseHeadingLevel) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx--;\n            }\n            return returnIndex ? -1 : null; // no heading found\n        }\n        Headings.findLowerEqualLevelParentHeadingAbove = findLowerEqualLevelParentHeadingAbove;\n        /** Find next heading with equal or lower level.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findLowerEqualLevelHeadingBelow(baseCell, notebook, returnIndex = false) {\n            let baseHeadingLevel = Private.Headings.determineHeadingLevel(baseCell, notebook);\n            if (baseHeadingLevel == -1) {\n                baseHeadingLevel = 1; // if no heading level can be determined, assume we're on level 1\n            }\n            let cellIdx = notebook.widgets.indexOf(baseCell) + 1;\n            while (cellIdx < notebook.widgets.length) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading &&\n                    headingInfo.headingLevel <= baseHeadingLevel) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx++;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findLowerEqualLevelHeadingBelow = findLowerEqualLevelHeadingBelow;\n        /** Find next heading.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findHeadingBelow(baseCell, notebook, returnIndex = false) {\n            let cellIdx = notebook.widgets.indexOf(baseCell) + 1;\n            while (cellIdx < notebook.widgets.length) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx++;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findHeadingBelow = findHeadingBelow;\n        /** Determine the heading level of a cell.\n         *\n         * @param baseCell - The cell of which the heading level shall be determined\n         * @param notebook - The target notebook widget\n         *\n         * @returns the heading level or -1 if there is no parent heading\n         *\n         * #### Notes\n         * If the baseCell is a heading itself, the heading level of baseCell is returned.\n         * If the baseCell is not a heading itself, the level of the parent heading is returned.\n         * If there is no parent heading, -1 is returned.\n         */\n        function determineHeadingLevel(baseCell, notebook) {\n            let headingInfoBaseCell = NotebookActions.getHeadingInfo(baseCell);\n            // fill baseHeadingLevel or return null if there is no heading at or above baseCell\n            if (headingInfoBaseCell.isHeading) {\n                return headingInfoBaseCell.headingLevel;\n            }\n            else {\n                let parentHeading = findParentHeading(baseCell, notebook, true);\n                if (parentHeading == null) {\n                    return -1;\n                }\n                return NotebookActions.getHeadingInfo(parentHeading).headingLevel;\n            }\n        }\n        Headings.determineHeadingLevel = determineHeadingLevel;\n        /** Insert a new heading cell at given position.\n         *\n         * @param cellIndex - where to insert\n         * @param headingLevel - level of the new heading\n         * @param notebook - target notebook\n         *\n         * #### Notes\n         * Enters edit mode after insert.\n         */\n        async function insertHeadingAboveCellIndex(cellIndex, headingLevel, notebook) {\n            var _a;\n            headingLevel = Math.min(Math.max(headingLevel, 1), 6);\n            const state = Private.getState(notebook);\n            const model = notebook.model;\n            const sharedModel = model.sharedModel;\n            sharedModel.insertCell(cellIndex, {\n                cell_type: 'markdown',\n                source: '#'.repeat(headingLevel) + ' '\n            });\n            notebook.activeCellIndex = cellIndex;\n            if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n                await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                    // no-op\n                });\n            }\n            notebook.deselectAll();\n            void Private.handleState(notebook, state, true);\n            notebook.mode = 'edit';\n            notebook.widgets[cellIndex].setHidden(false);\n        }\n        Headings.insertHeadingAboveCellIndex = insertHeadingAboveCellIndex;\n    })(Headings = Private.Headings || (Private.Headings = {}));\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CodeCellModel, MarkdownCellModel, RawCellModel } from '@jupyterlab/cells';\nimport { Signal } from '@lumino/signaling';\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList {\n    /**\n     * Construct the cell list.\n     */\n    constructor(model) {\n        this.model = model;\n        this._cellMap = new WeakMap();\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this._insertCells(0, this.model.cells);\n        this.model.changed.connect(this._onSharedModelChanged, this);\n    }\n    /**\n     * A signal emitted when the cell list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Test whether the cell list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Get the length of the cell list.\n     *\n     * @returns The number of cells in the cell list.\n     */\n    get length() {\n        return this.model.cells.length;\n    }\n    /**\n     * Create an iterator over the cells in the cell list.\n     *\n     * @returns A new iterator starting at the front of the cell list.\n     */\n    *[Symbol.iterator]() {\n        for (const cell of this.model.cells) {\n            yield this._cellMap.get(cell);\n        }\n    }\n    /**\n     * Dispose of the resources held by the cell list.\n     */\n    dispose() {\n        var _a;\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // Clean up the cell map and cell order objects.\n        for (const cell of this.model.cells) {\n            (_a = this._cellMap.get(cell)) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        Signal.clearData(this);\n    }\n    /**\n     * Get the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The cell at the specified index.\n     */\n    get(index) {\n        return this._cellMap.get(this.model.cells[index]);\n    }\n    _insertCells(index, cells) {\n        cells.forEach(sharedModel => {\n            let cellModel;\n            switch (sharedModel.cell_type) {\n                case 'code': {\n                    cellModel = new CodeCellModel({\n                        sharedModel: sharedModel\n                    });\n                    break;\n                }\n                case 'markdown': {\n                    cellModel = new MarkdownCellModel({\n                        sharedModel: sharedModel\n                    });\n                    break;\n                }\n                default: {\n                    cellModel = new RawCellModel({\n                        sharedModel: sharedModel\n                    });\n                }\n            }\n            this._cellMap.set(sharedModel, cellModel);\n            sharedModel.disposed.connect(() => {\n                cellModel.dispose();\n                this._cellMap.delete(sharedModel);\n            });\n        });\n        return this.length;\n    }\n    _onSharedModelChanged(self, change) {\n        var _a;\n        let currpos = 0;\n        // We differ emitting the list changes to ensure cell model for all current shared cell have been created.\n        const events = new Array();\n        (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach(delta => {\n            if (delta.insert != null) {\n                this._insertCells(currpos, delta.insert);\n                events.push({\n                    type: 'add',\n                    newIndex: currpos,\n                    newValues: delta.insert.map(c => this._cellMap.get(c)),\n                    oldIndex: -2,\n                    oldValues: []\n                });\n                currpos += delta.insert.length;\n            }\n            else if (delta.delete != null) {\n                events.push({\n                    type: 'remove',\n                    newIndex: -1,\n                    newValues: [],\n                    oldIndex: currpos,\n                    // Cells have been disposed, so we don't know which one are gone.\n                    oldValues: new Array(delta.delete).fill(undefined)\n                });\n            }\n            else if (delta.retain != null) {\n                currpos += delta.retain;\n            }\n        });\n        events.forEach(msg => this._changed.emit(msg));\n    }\n}\n//# sourceMappingURL=celllist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Toolbar as AppToolbar, Dialog, SessionContextDialogs, showDialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { addIcon, addToolbarButtonClass, copyIcon, cutIcon, fastForwardIcon, HTMLSelect, pasteIcon, ReactWidget, runIcon, saveIcon, Toolbar, ToolbarButton, ToolbarButtonComponent, UseSignal } from '@jupyterlab/ui-components';\nimport * as React from 'react';\nimport { NotebookActions } from './actions';\n/**\n * The class name added to toolbar cell type dropdown wrapper.\n */\nconst TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';\n/**\n * The class name added to toolbar cell type dropdown.\n */\nconst TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';\n/**\n * A namespace for the default toolbar items.\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createSaveButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        function onClick() {\n            if (panel.context.model.readOnly) {\n                return showDialog({\n                    title: trans.__('Cannot Save'),\n                    body: trans.__('Document is read-only'),\n                    buttons: [Dialog.okButton()]\n                });\n            }\n            void panel.context.save().then(() => {\n                if (!panel.isDisposed) {\n                    return panel.context.createCheckpoint();\n                }\n            });\n        }\n        return addToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: panel.context.fileChanged }, () => (React.createElement(ToolbarButtonComponent, { icon: saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&\n                panel.context &&\n                panel.context.contentsModel &&\n                panel.context.contentsModel.writable) })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n    /**\n     * Create an insert toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createInsertButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                NotebookActions.insertBelow(panel.content);\n            },\n            tooltip: trans.__('Insert a cell below')\n        });\n    }\n    ToolbarItems.createInsertButton = createInsertButton;\n    /**\n     * Create a cut toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCutButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: cutIcon,\n            onClick: () => {\n                NotebookActions.cut(panel.content);\n            },\n            tooltip: trans.__('Cut the selected cells')\n        });\n    }\n    ToolbarItems.createCutButton = createCutButton;\n    /**\n     * Create a copy toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCopyButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: copyIcon,\n            onClick: () => {\n                NotebookActions.copy(panel.content);\n            },\n            tooltip: trans.__('Copy the selected cells')\n        });\n    }\n    ToolbarItems.createCopyButton = createCopyButton;\n    /**\n     * Create a paste toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createPasteButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: pasteIcon,\n            onClick: () => {\n                NotebookActions.paste(panel.content);\n            },\n            tooltip: trans.__('Paste cells from the clipboard')\n        });\n    }\n    ToolbarItems.createPasteButton = createPasteButton;\n    /**\n     * Create a run toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRunButton(panel, sessionDialogs, translator) {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: runIcon,\n            onClick: () => {\n                void NotebookActions.runAndAdvance(panel.content, panel.sessionContext, sessionDialogs, translator);\n            },\n            tooltip: trans.__('Run the selected cells and advance')\n        });\n    }\n    ToolbarItems.createRunButton = createRunButton;\n    /**\n     * Create a restart run all toolbar item\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRestartRunAllButton(panel, dialogs, translator) {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: fastForwardIcon,\n            onClick: () => {\n                const dialogs_ = dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator });\n                void dialogs_.restart(panel.sessionContext).then(restarted => {\n                    if (restarted) {\n                        void NotebookActions.runAll(panel.content, panel.sessionContext, dialogs_, translator);\n                    }\n                    return restarted;\n                });\n            },\n            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')\n        });\n    }\n    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;\n    /**\n     * Create a cell type switcher item.\n     *\n     * #### Notes\n     * It will display the type of the current active cell.\n     * If more than one cell is selected but are of different types,\n     * it will display `'-'`.\n     * When the user changes the cell type, it will change the\n     * cell types of the selected cells.\n     * It can handle a change to the context.\n     */\n    function createCellTypeItem(panel, translator) {\n        return new CellTypeSwitcher(panel.content, translator);\n    }\n    ToolbarItems.createCellTypeItem = createCellTypeItem;\n    /**\n     * Get the default toolbar items for panel\n     *\n     * @deprecated since v4\n     */\n    function getDefaultItems(panel, sessionDialogs, translator) {\n        return [\n            { name: 'save', widget: createSaveButton(panel, translator) },\n            { name: 'insert', widget: createInsertButton(panel, translator) },\n            { name: 'cut', widget: createCutButton(panel, translator) },\n            { name: 'copy', widget: createCopyButton(panel, translator) },\n            { name: 'paste', widget: createPasteButton(panel, translator) },\n            {\n                name: 'run',\n                widget: createRunButton(panel, sessionDialogs, translator)\n            },\n            {\n                name: 'interrupt',\n                widget: AppToolbar.createInterruptButton(panel.sessionContext, translator)\n            },\n            {\n                name: 'restart',\n                widget: AppToolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'restart-and-run',\n                widget: createRestartRunAllButton(panel, sessionDialogs, translator)\n            },\n            { name: 'cellType', widget: createCellTypeItem(panel, translator) },\n            { name: 'spacer', widget: Toolbar.createSpacerItem() },\n            {\n                name: 'kernelName',\n                widget: AppToolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)\n            }\n        ];\n    }\n    ToolbarItems.getDefaultItems = getDefaultItems;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A toolbar widget that switches cell types.\n */\nexport class CellTypeSwitcher extends ReactWidget {\n    /**\n     * Construct a new cell type switcher.\n     */\n    constructor(widget, translator) {\n        super();\n        /**\n         * Handle `change` events for the HTMLSelect component.\n         */\n        this.handleChange = (event) => {\n            if (event.target.value !== '-') {\n                NotebookActions.changeCellType(this._notebook, event.target.value);\n                this._notebook.activate();\n            }\n        };\n        /**\n         * Handle `keydown` events for the HTMLSelect component.\n         */\n        this.handleKeyDown = (event) => {\n            if (event.keyCode === 13) {\n                this._notebook.activate();\n            }\n        };\n        this._trans = (translator || nullTranslator).load('jupyterlab');\n        this.addClass(TOOLBAR_CELLTYPE_CLASS);\n        this._notebook = widget;\n        if (widget.model) {\n            this.update();\n        }\n        widget.activeCellChanged.connect(this.update, this);\n        // Follow a change in the selection.\n        widget.selectionChanged.connect(this.update, this);\n    }\n    render() {\n        let value = '-';\n        if (this._notebook.activeCell) {\n            value = this._notebook.activeCell.model.type;\n        }\n        for (const widget of this._notebook.widgets) {\n            if (this._notebook.isSelectedOrActive(widget)) {\n                if (widget.model.type !== value) {\n                    value = '-';\n                    break;\n                }\n            }\n        }\n        return (React.createElement(HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, \"aria-label\": this._trans.__('Cell type'), title: this._trans.__('Select the cell type') },\n            React.createElement(\"option\", { value: \"-\" }, \"-\"),\n            React.createElement(\"option\", { value: \"code\" }, this._trans.__('Code')),\n            React.createElement(\"option\", { value: \"markdown\" }, this._trans.__('Markdown')),\n            React.createElement(\"option\", { value: \"raw\" }, this._trans.__('Raw'))));\n    }\n}\n//# sourceMappingURL=default-toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { translateKernelStatuses } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport React from 'react';\nimport { ProgressCircle } from '@jupyterlab/statusbar';\nimport { circleIcon, offlineBoltIcon, VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport { KernelMessage } from '@jupyterlab/services';\n/**\n * A react functional component for rendering execution indicator.\n */\nexport function ExecutionIndicatorComponent(props) {\n    const translator = props.translator || nullTranslator;\n    const kernelStatuses = translateKernelStatuses(translator);\n    const trans = translator.load('jupyterlab');\n    const state = props.state;\n    const showOnToolBar = props.displayOption.showOnToolBar;\n    const showProgress = props.displayOption.showProgress;\n    const tooltipClass = showOnToolBar ? 'down' : 'up';\n    const emptyDiv = React.createElement(\"div\", null);\n    if (!state) {\n        return emptyDiv;\n    }\n    const kernelStatus = state.kernelStatus;\n    const circleIconProps = {\n        alignSelf: 'normal',\n        height: '24px'\n    };\n    const time = state.totalTime;\n    const scheduledCellNumber = state.scheduledCellNumber || 0;\n    const remainingCellNumber = state.scheduledCell.size || 0;\n    const executedCellNumber = scheduledCellNumber - remainingCellNumber;\n    let percentage = (100 * executedCellNumber) / scheduledCellNumber;\n    let displayClass = showProgress ? '' : 'hidden';\n    if (!showProgress && percentage < 100) {\n        percentage = 0;\n    }\n    const progressBar = (percentage) => (React.createElement(ProgressCircle, { progress: percentage, width: 16, height: 24, label: trans.__('Kernel status') }));\n    const titleFactory = (translatedStatus) => trans.__('Kernel status: %1', translatedStatus);\n    const reactElement = (status, circle, popup) => (React.createElement(\"div\", { className: 'jp-Notebook-ExecutionIndicator', title: showProgress ? '' : titleFactory(kernelStatuses[status]), \"data-status\": status },\n        circle,\n        React.createElement(\"div\", { className: `jp-Notebook-ExecutionIndicator-tooltip ${tooltipClass} ${displayClass}` },\n            React.createElement(\"span\", null,\n                \" \",\n                titleFactory(kernelStatuses[status]),\n                \" \"),\n            popup)));\n    if (state.kernelStatus === 'connecting' ||\n        state.kernelStatus === 'disconnected' ||\n        state.kernelStatus === 'unknown') {\n        return reactElement(kernelStatus, React.createElement(offlineBoltIcon.react, { ...circleIconProps }), []);\n    }\n    if (state.kernelStatus === 'starting' ||\n        state.kernelStatus === 'terminating' ||\n        state.kernelStatus === 'restarting' ||\n        state.kernelStatus === 'initializing') {\n        return reactElement(kernelStatus, React.createElement(circleIcon.react, { ...circleIconProps }), []);\n    }\n    if (state.executionStatus === 'busy') {\n        return reactElement('busy', progressBar(percentage), [\n            React.createElement(\"span\", { key: 0 }, trans.__(`Executed ${executedCellNumber}/${scheduledCellNumber} cells`)),\n            React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n        ]);\n    }\n    else {\n        // No cell is scheduled, fall back to the status of kernel\n        const progress = state.kernelStatus === 'busy' ? 0 : 100;\n        const popup = state.kernelStatus === 'busy' || time === 0\n            ? []\n            : [\n                React.createElement(\"span\", { key: 0 }, trans._n('Executed %1 cell', 'Executed %1 cells', scheduledCellNumber)),\n                React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n            ];\n        return reactElement(state.kernelStatus, progressBar(progress), popup);\n    }\n}\n/**\n * A VDomRenderer widget for displaying the execution status.\n */\nexport class ExecutionIndicator extends VDomRenderer {\n    /**\n     * Construct the kernel status widget.\n     */\n    constructor(translator, showProgress = true) {\n        super(new ExecutionIndicator.Model());\n        this.translator = translator || nullTranslator;\n        this.addClass('jp-mod-highlighted');\n    }\n    /**\n     * Render the execution status item.\n     */\n    render() {\n        if (this.model === null || !this.model.renderFlag) {\n            return React.createElement(\"div\", null);\n        }\n        else {\n            const nb = this.model.currentNotebook;\n            if (!nb) {\n                return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: undefined, translator: this.translator }));\n            }\n            return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: this.model.executionState(nb), translator: this.translator }));\n        }\n    }\n}\n/**\n * A namespace for ExecutionIndicator statics.\n */\n(function (ExecutionIndicator) {\n    /**\n     * A VDomModel for the execution status indicator.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super();\n            /**\n             * A weak map to hold execution status of multiple notebooks.\n             */\n            this._notebookExecutionProgress = new WeakMap();\n            this._displayOption = { showOnToolBar: true, showProgress: true };\n            this._renderFlag = true;\n        }\n        /**\n         * Attach a notebook with session context to model in order to keep\n         * track of multiple notebooks. If a session context is already\n         * attached, only set current activated notebook to input.\n         *\n         * @param data - The  notebook and session context to be attached to model\n         */\n        attachNotebook(data) {\n            var _a, _b, _c, _d;\n            if (data && data.content && data.context) {\n                const nb = data.content;\n                const context = data.context;\n                this._currentNotebook = nb;\n                if (!this._notebookExecutionProgress.has(nb)) {\n                    this._notebookExecutionProgress.set(nb, {\n                        executionStatus: 'idle',\n                        kernelStatus: 'idle',\n                        totalTime: 0,\n                        interval: 0,\n                        timeout: 0,\n                        scheduledCell: new Set(),\n                        scheduledCellNumber: 0,\n                        needReset: true\n                    });\n                    const state = this._notebookExecutionProgress.get(nb);\n                    const contextStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.statusChanged.connect(contextStatusChanged, this);\n                    const contextConnectionStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.connectionStatusChanged.connect(contextConnectionStatusChanged, this);\n                    context.disposed.connect(ctx => {\n                        ctx.connectionStatusChanged.disconnect(contextConnectionStatusChanged, this);\n                        ctx.statusChanged.disconnect(contextStatusChanged, this);\n                    });\n                    const handleKernelMsg = (sender, msg) => {\n                        const message = msg.msg;\n                        const msgId = message.header.msg_id;\n                        if (message.header.msg_type === 'execute_request') {\n                            // A cell code is scheduled for executing\n                            this._cellScheduledCallback(nb, msgId);\n                        }\n                        else if (KernelMessage.isStatusMsg(message) &&\n                            message.content.execution_state === 'idle') {\n                            // Idle status message case.\n                            const parentId = message.parent_header\n                                .msg_id;\n                            this._cellExecutedCallback(nb, parentId);\n                        }\n                        else if (KernelMessage.isStatusMsg(message) &&\n                            message.content.execution_state === 'restarting') {\n                            this._restartHandler(nb);\n                        }\n                        else if (message.header.msg_type === 'execute_input') {\n                            // A cell code starts executing.\n                            this._startTimer(nb);\n                        }\n                    };\n                    (_b = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.anyMessage.connect(handleKernelMsg);\n                    (_d = (_c = context.session) === null || _c === void 0 ? void 0 : _c.kernel) === null || _d === void 0 ? void 0 : _d.disposed.connect(kernel => kernel.anyMessage.disconnect(handleKernelMsg));\n                    const kernelChangedSlot = (_, kernelData) => {\n                        if (state) {\n                            this._resetTime(state);\n                            this.stateChanged.emit(void 0);\n                            if (kernelData.newValue) {\n                                kernelData.newValue.anyMessage.connect(handleKernelMsg);\n                            }\n                        }\n                    };\n                    context.kernelChanged.connect(kernelChangedSlot);\n                    context.disposed.connect(ctx => ctx.kernelChanged.disconnect(kernelChangedSlot));\n                }\n            }\n        }\n        /**\n         * The current activated notebook in model.\n         */\n        get currentNotebook() {\n            return this._currentNotebook;\n        }\n        /**\n         * The display options for progress bar and elapsed time.\n         */\n        get displayOption() {\n            return this._displayOption;\n        }\n        /**\n         * Set the display options for progress bar and elapsed time.\n         *\n         * @param options - Options to be used\n         */\n        set displayOption(options) {\n            this._displayOption = options;\n        }\n        /**\n         * Get the execution state associated with a notebook.\n         *\n         * @param nb - The notebook used to identify execution\n         * state.\n         *\n         * @returns - The associated execution state.\n         */\n        executionState(nb) {\n            return this._notebookExecutionProgress.get(nb);\n        }\n        /**\n         * Schedule switch to idle status and clearing of the timer.\n         *\n         * ### Note\n         *\n         * To keep track of cells executed under 1 second,\n         * the execution state is marked as `needReset` 1 second after executing\n         * these cells. This `Timeout` will be cleared if there is any cell\n         * scheduled after that.\n         */\n        _scheduleSwitchToIdle(state) {\n            window.setTimeout(() => {\n                state.executionStatus = 'idle';\n                clearInterval(state.interval);\n                this.stateChanged.emit(void 0);\n            }, 150);\n            state.timeout = window.setTimeout(() => {\n                state.needReset = true;\n            }, 1000);\n        }\n        /**\n         * The function is called on kernel's idle status message.\n         * It is used to keep track of number of executed\n         * cells or Comm custom messages and the status of kernel.\n         *\n         * @param nb - The notebook which contains the executed code cell.\n         * @param msg_id - The id of message.\n         */\n        _cellExecutedCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && state.scheduledCell.has(msg_id)) {\n                state.scheduledCell.delete(msg_id);\n                if (state.scheduledCell.size === 0) {\n                    this._scheduleSwitchToIdle(state);\n                }\n            }\n        }\n        /**\n         * The function is called on kernel's restarting status message.\n         * It is used to clear the state tracking the number of executed\n         * cells.\n         *\n         * @param nb - The notebook which contains the executed code cell.\n         */\n        _restartHandler(nb) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state) {\n                state.scheduledCell.clear();\n                this._scheduleSwitchToIdle(state);\n            }\n        }\n        /**\n         * This function is called on kernel's `execute_input` message to start\n         * the elapsed time counter.\n         *\n         * @param  nb - The notebook which contains the scheduled execution request.\n         */\n        _startTimer(nb) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (!state) {\n                return;\n            }\n            if (state.scheduledCell.size > 0) {\n                if (state.executionStatus !== 'busy') {\n                    state.executionStatus = 'busy';\n                    clearTimeout(state.timeout);\n                    this.stateChanged.emit(void 0);\n                    state.interval = window.setInterval(() => {\n                        this._tick(state);\n                    }, 1000);\n                }\n            }\n            else {\n                this._resetTime(state);\n            }\n        }\n        /**\n         * The function is called on kernel's `execute_request` message or Comm message, it is\n         * used to keep track number of scheduled cell or Comm execution message\n         * and the status of kernel.\n         *\n         * @param  nb - The notebook which contains the scheduled code.\n         * cell\n         * @param  msg_id - The id of message.\n         */\n        _cellScheduledCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && !state.scheduledCell.has(msg_id)) {\n                if (state.needReset) {\n                    this._resetTime(state);\n                }\n                state.scheduledCell.add(msg_id);\n                state.scheduledCellNumber += 1;\n            }\n        }\n        /**\n         * Increment the executed time of input execution state\n         * and emit `stateChanged` signal to re-render the indicator.\n         *\n         * @param  data - the state to be updated.\n         */\n        _tick(data) {\n            data.totalTime += 1;\n            this.stateChanged.emit(void 0);\n        }\n        /**\n         * Reset the input execution state.\n         *\n         * @param  data - the state to be rested.\n         */\n        _resetTime(data) {\n            data.totalTime = 0;\n            data.scheduledCellNumber = 0;\n            data.executionStatus = 'idle';\n            data.scheduledCell = new Set();\n            clearTimeout(data.timeout);\n            clearInterval(data.interval);\n            data.needReset = false;\n        }\n        get renderFlag() {\n            return this._renderFlag;\n        }\n        updateRenderOption(options) {\n            if (this.displayOption.showOnToolBar) {\n                if (!options.showOnToolBar) {\n                    this._renderFlag = false;\n                }\n                else {\n                    this._renderFlag = true;\n                }\n            }\n            this.displayOption.showProgress = options.showProgress;\n            this.stateChanged.emit(void 0);\n        }\n    }\n    ExecutionIndicator.Model = Model;\n    function createExecutionIndicatorItem(panel, translator, loadSettings) {\n        const toolbarItem = new ExecutionIndicator(translator);\n        toolbarItem.model.displayOption = {\n            showOnToolBar: true,\n            showProgress: true\n        };\n        toolbarItem.model.attachNotebook({\n            content: panel.content,\n            context: panel.sessionContext\n        });\n        if (loadSettings) {\n            loadSettings\n                .then(settings => {\n                const updateSettings = (newSettings) => {\n                    toolbarItem.model.updateRenderOption(getSettingValue(newSettings));\n                };\n                settings.changed.connect(updateSettings);\n                updateSettings(settings);\n                toolbarItem.disposed.connect(() => {\n                    settings.changed.disconnect(updateSettings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        return toolbarItem;\n    }\n    ExecutionIndicator.createExecutionIndicatorItem = createExecutionIndicatorItem;\n    function getSettingValue(settings) {\n        let showOnToolBar = true;\n        let showProgress = true;\n        const configValues = settings.get('kernelStatus').composite;\n        if (configValues) {\n            showOnToolBar = !configValues.showOnStatusBar;\n            showProgress = configValues.showProgress;\n        }\n        return { showOnToolBar, showProgress };\n    }\n    ExecutionIndicator.getSettingValue = getSettingValue;\n})(ExecutionIndicator || (ExecutionIndicator = {}));\n//# sourceMappingURL=executionindicator.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\n/**\n * A console history manager object.\n */\nexport class NotebookHistory {\n    /**\n     * Construct a new console history object.\n     */\n    constructor(options) {\n        /**\n         * The number of history items to increase a batch size by per subsequent request.\n         */\n        this._requestBatchSize = 10;\n        this._cursor = 0;\n        this._hasSession = false;\n        this._history = [];\n        this._placeholder = '';\n        this._kernelSession = '';\n        this._setByHistory = false;\n        this._isDisposed = false;\n        this._editor = null;\n        this._filtered = [];\n        this._kernel = null;\n        this._sessionContext = options.sessionContext;\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        void this._handleKernel().then(() => {\n            this._sessionContext.kernelChanged.connect(this._handleKernel, this);\n        });\n        this._toRequest = this._requestBatchSize;\n    }\n    /**\n     * The current editor used by the history manager.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(value) {\n        if (this._editor === value) {\n            return;\n        }\n        const prev = this._editor;\n        if (prev) {\n            prev.model.sharedModel.changed.disconnect(this.onTextChange, this);\n        }\n        this._editor = value;\n        if (value) {\n            value.model.sharedModel.changed.connect(this.onTextChange, this);\n        }\n    }\n    /**\n     * The placeholder text that a history session began with.\n     */\n    get placeholder() {\n        return this._placeholder;\n    }\n    /**\n     * Kernel session number for filtering\n     */\n    get kernelSession() {\n        return this._kernelSession;\n    }\n    /**\n     * Get whether the notebook history manager is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the notebook history manager.\n     */\n    dispose() {\n        this._isDisposed = true;\n        this._history.length = 0;\n        Signal.clearData(this);\n    }\n    /**\n     * Set placeholder and editor. Start session if one is not already started.\n     *\n     * @param activeCell - The currently selected Cell in the notebook.\n     */\n    async checkSession(activeCell) {\n        var _a;\n        if (!this._hasSession) {\n            await this._retrieveHistory();\n            this._hasSession = true;\n            this.editor = activeCell.editor;\n            this._placeholder = ((_a = this._editor) === null || _a === void 0 ? void 0 : _a.model.sharedModel.getSource()) || '';\n            // Filter the history with the placeholder string.\n            this.setFilter(this._placeholder);\n            this._cursor = this._filtered.length - 1;\n        }\n    }\n    /**\n     * Get the previous item in the notebook history.\n     *\n     * @param activeCell - The currently selected Cell in the notebook.\n     *\n     * @returns A Promise resolving to the historical cell content text.\n     */\n    async back(activeCell) {\n        await this.checkSession(activeCell);\n        --this._cursor;\n        if (this._cursor < 0) {\n            await this.fetchBatch();\n        }\n        this._cursor = Math.max(0, this._cursor);\n        const content = this._filtered[this._cursor];\n        // This shouldn't ever be undefined as `setFilter` will always be run first\n        return content;\n    }\n    /**\n     * Get the next item in the notebook history.\n     *\n     * @param activeCell - The currently selected Cell in the notebook.\n     *\n     * @returns A Promise resolving to the historical cell content text.\n     */\n    async forward(activeCell) {\n        await this.checkSession(activeCell);\n        ++this._cursor;\n        this._cursor = Math.min(this._filtered.length - 1, this._cursor);\n        const content = this._filtered[this._cursor];\n        // This shouldn't ever be undefined as `setFilter` will always be run first\n        return content;\n    }\n    /**\n     * Update the editor of the cell with provided text content.\n     *\n     * @param activeCell - The currently selected Cell in the notebook.\n     * @param content - the result from back or forward\n     */\n    updateEditor(activeCell, content) {\n        var _a, _b;\n        if (activeCell) {\n            const model = (_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.model;\n            const source = model === null || model === void 0 ? void 0 : model.sharedModel.getSource();\n            if (this.isDisposed || !content) {\n                return;\n            }\n            if (source === content) {\n                return;\n            }\n            this._setByHistory = true;\n            model === null || model === void 0 ? void 0 : model.sharedModel.setSource(content);\n            let columnPos = 0;\n            columnPos = content.indexOf('\\n');\n            if (columnPos < 0) {\n                columnPos = content.length;\n            }\n            (_b = activeCell.editor) === null || _b === void 0 ? void 0 : _b.setCursorPosition({ line: 0, column: columnPos });\n        }\n    }\n    /**\n     * Reset the history navigation state, i.e., start a new history session.\n     */\n    reset() {\n        this._hasSession = false;\n        this._placeholder = '';\n        this._toRequest = this._requestBatchSize;\n    }\n    /**\n     * Fetches a subsequent batch of history. Updates the filtered history and cursor to correct place in history,\n     * accounting for potentially new history items above it.\n     */\n    async fetchBatch() {\n        this._toRequest += this._requestBatchSize;\n        let oldFilteredReversed = this._filtered.slice().reverse();\n        let oldHistory = this._history.slice();\n        await this._retrieveHistory().then(() => {\n            this.setFilter(this._placeholder);\n            let cursorOffset = 0;\n            let filteredReversed = this._filtered.slice().reverse();\n            for (let i = 0; i < oldFilteredReversed.length; i++) {\n                let item = oldFilteredReversed[i];\n                for (let ij = i + cursorOffset; ij < filteredReversed.length; ij++) {\n                    if (item === filteredReversed[ij]) {\n                        break;\n                    }\n                    else {\n                        cursorOffset += 1;\n                    }\n                }\n            }\n            this._cursor =\n                this._filtered.length - (oldFilteredReversed.length + 1) - cursorOffset;\n        });\n        if (this._cursor < 0) {\n            if (this._history.length > oldHistory.length) {\n                await this.fetchBatch();\n            }\n        }\n    }\n    /**\n     * Populate the history collection on history reply from a kernel.\n     *\n     * @param value The kernel message history reply.\n     *\n     * #### Notes\n     * History entries have the shape:\n     * [session: number, line: number, input: string]\n     * Contiguous duplicates are stripped out of the API response.\n     */\n    onHistory(value, cell) {\n        this._history.length = 0;\n        let last = ['', '', ''];\n        let current = ['', '', ''];\n        let kernelSession = '';\n        if (value.content.status === 'ok') {\n            for (let i = 0; i < value.content.history.length; i++) {\n                current = value.content.history[i];\n                if (current !== last) {\n                    kernelSession = value.content.history[i][0];\n                    this._history.push((last = current));\n                }\n            }\n            // set the kernel session for filtering\n            if (!this.kernelSession) {\n                if (current[2] == (cell === null || cell === void 0 ? void 0 : cell.model.sharedModel.getSource())) {\n                    this._kernelSession = kernelSession;\n                }\n            }\n        }\n    }\n    /**\n     * Handle a text change signal from the editor.\n     */\n    onTextChange() {\n        if (this._setByHistory) {\n            this._setByHistory = false;\n            return;\n        }\n        this.reset();\n    }\n    /**\n     * Handle the current kernel changing.\n     */\n    async _handleKernel() {\n        var _a;\n        this._kernel = (_a = this._sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!this._kernel) {\n            this._history.length = 0;\n            return;\n        }\n        await this._retrieveHistory().catch();\n        return;\n    }\n    /**\n     * retrieve the history from the kernel\n     *\n     * @param cell - The string to use when filtering the data.\n     */\n    async _retrieveHistory(cell) {\n        var _a;\n        return await ((_a = this._kernel) === null || _a === void 0 ? void 0 : _a.requestHistory(request(this._toRequest)).then(v => {\n            this.onHistory(v, cell);\n        }).catch(() => {\n            console.warn(this._trans.__('History was unable to be retrieved'));\n        }));\n    }\n    /**\n     * Set the filter data.\n     *\n     * @param filterStr - The string to use when filtering the data.\n     */\n    setFilter(filterStr = '') {\n        // Apply the new filter and remove contiguous duplicates.\n        this._filtered.length = 0;\n        let last = '';\n        let current = '';\n        for (let i = 0; i < this._history.length; i++) {\n            current = this._history[i][2];\n            if (current !== last && filterStr !== current) {\n                this._filtered.push((last = current));\n            }\n        }\n        this._filtered.push(filterStr);\n    }\n}\nfunction request(n) {\n    return {\n        output: false,\n        raw: true,\n        hist_access_type: 'tail',\n        n: n\n    };\n}\n//# sourceMappingURL=history.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { YNotebook } from '@jupyter/ydoc';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { CellList } from './celllist';\n/**\n * An implementation of a notebook Model.\n */\nexport class NotebookModel {\n    /**\n     * Construct a new notebook model.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        /**\n         * Whether the model should disposed the shared model on disposal or not.\n         */\n        this.standaloneModel = false;\n        this._dirty = false;\n        this._readOnly = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._isDisposed = false;\n        this._metadataChanged = new Signal(this);\n        this.standaloneModel = typeof options.sharedModel === 'undefined';\n        if (options.sharedModel) {\n            this.sharedModel = options.sharedModel;\n        }\n        else {\n            this.sharedModel = YNotebook.create({\n                disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : true,\n                data: {\n                    nbformat: nbformat.MAJOR_VERSION,\n                    nbformat_minor: nbformat.MINOR_VERSION,\n                    metadata: {\n                        kernelspec: { name: '', display_name: '' },\n                        language_info: { name: (_b = options.languagePreference) !== null && _b !== void 0 ? _b : '' }\n                    }\n                }\n            });\n        }\n        this._cells = new CellList(this.sharedModel);\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        this._deletedCells = [];\n        this._collaborationEnabled = !!(options === null || options === void 0 ? void 0 : options.collaborationEnabled);\n        this._cells.changed.connect(this._onCellsChanged, this);\n        this.sharedModel.changed.connect(this._onStateChanged, this);\n        this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);\n    }\n    /**\n     * A signal emitted when the document content changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * Signal emitted when notebook metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * A signal emitted when the document state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Get the observable list of notebook cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /**\n     * The dirty state of the document.\n     */\n    get dirty() {\n        return this._dirty;\n    }\n    set dirty(newValue) {\n        const oldValue = this._dirty;\n        if (newValue === oldValue) {\n            return;\n        }\n        this._dirty = newValue;\n        this.triggerStateChange({\n            name: 'dirty',\n            oldValue,\n            newValue\n        });\n    }\n    /**\n     * The read only state of the document.\n     */\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(newValue) {\n        if (newValue === this._readOnly) {\n            return;\n        }\n        const oldValue = this._readOnly;\n        this._readOnly = newValue;\n        this.triggerStateChange({ name: 'readOnly', oldValue, newValue });\n    }\n    /**\n     * The metadata associated with the notebook.\n     *\n     * ### Notes\n     * This is a copy of the metadata. Changing a part of it\n     * won't affect the model.\n     * As this returns a copy of all metadata, it is advised to\n     * use `getMetadata` to speed up the process of getting a single key.\n     */\n    get metadata() {\n        return this.sharedModel.metadata;\n    }\n    /**\n     * The major version number of the nbformat.\n     */\n    get nbformat() {\n        return this.sharedModel.nbformat;\n    }\n    /**\n     * The minor version number of the nbformat.\n     */\n    get nbformatMinor() {\n        return this.sharedModel.nbformat_minor;\n    }\n    /**\n     * The default kernel name of the document.\n     */\n    get defaultKernelName() {\n        var _a;\n        const spec = this.getMetadata('kernelspec');\n        return (_a = spec === null || spec === void 0 ? void 0 : spec.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * A list of deleted cells for the notebook..\n     */\n    get deletedCells() {\n        return this._deletedCells;\n    }\n    /**\n     * The default kernel language of the document.\n     */\n    get defaultKernelLanguage() {\n        var _a;\n        const info = this.getMetadata('language_info');\n        return (_a = info === null || info === void 0 ? void 0 : info.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Whether the model is collaborative or not.\n     */\n    get collaborative() {\n        return this._collaborationEnabled;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        const cells = this.cells;\n        this._cells = null;\n        cells.dispose();\n        if (this.standaloneModel) {\n            this.sharedModel.dispose();\n        }\n        Signal.clearData(this);\n    }\n    /**\n     * Delete a metadata\n     *\n     * @param key Metadata key\n     */\n    deleteMetadata(key) {\n        return this.sharedModel.deleteMetadata(key);\n    }\n    /**\n     * Get a metadata\n     *\n     * ### Notes\n     * This returns a copy of the key value.\n     *\n     * @param key Metadata key\n     */\n    getMetadata(key) {\n        return this.sharedModel.getMetadata(key);\n    }\n    /**\n     * Set a metadata\n     *\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n    setMetadata(key, value) {\n        if (typeof value === 'undefined') {\n            this.sharedModel.deleteMetadata(key);\n        }\n        else {\n            this.sharedModel.setMetadata(key, value);\n        }\n    }\n    /**\n     * Serialize the model to a string.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value) {\n        this.fromJSON(JSON.parse(value));\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        this._ensureMetadata();\n        return this.sharedModel.toJSON();\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value) {\n        var _a, _b;\n        const copy = JSONExt.deepCopy(value);\n        const origNbformat = value.metadata.orig_nbformat;\n        // Alert the user if the format changes.\n        copy.nbformat = Math.max(value.nbformat, nbformat.MAJOR_VERSION);\n        if (copy.nbformat !== value.nbformat ||\n            copy.nbformat_minor < nbformat.MINOR_VERSION) {\n            copy.nbformat_minor = nbformat.MINOR_VERSION;\n        }\n        if (origNbformat !== undefined && copy.nbformat !== origNbformat) {\n            const newer = copy.nbformat > origNbformat;\n            let msg;\n            if (newer) {\n                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\n'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, copy.nbformat);\n            }\n            else {\n                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\nSome features of the original notebook may not be available.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, copy.nbformat);\n            }\n            void showDialog({\n                title: this._trans.__('Notebook converted'),\n                body: msg,\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n        }\n        // Ensure there is at least one cell\n        if (((_b = (_a = copy.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0) {\n            copy['cells'] = [\n                { cell_type: 'code', source: '', metadata: { trusted: true } }\n            ];\n        }\n        this.sharedModel.fromJSON(copy);\n        this._ensureMetadata();\n        this.dirty = true;\n    }\n    /**\n     * Handle a change in the cells list.\n     */\n    _onCellsChanged(list, change) {\n        switch (change.type) {\n            case 'add':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            case 'remove':\n                break;\n            case 'set':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            default:\n                break;\n        }\n        this.triggerContentChange();\n    }\n    _onMetadataChanged(sender, changes) {\n        this._metadataChanged.emit(changes);\n        this.triggerContentChange();\n    }\n    _onStateChanged(sender, changes) {\n        if (changes.stateChange) {\n            changes.stateChange.forEach(value => {\n                if (value.name === 'dirty') {\n                    // Setting `dirty` will trigger the state change.\n                    // We always set `dirty` because the shared model state\n                    // and the local attribute are synchronized one way shared model -> _dirty\n                    this.dirty = value.newValue;\n                }\n                else if (value.oldValue !== value.newValue) {\n                    this.triggerStateChange({\n                        newValue: undefined,\n                        oldValue: undefined,\n                        ...value\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Make sure we have the required metadata fields.\n     */\n    _ensureMetadata(languageName = '') {\n        if (!this.getMetadata('language_info')) {\n            this.sharedModel.setMetadata('language_info', { name: languageName });\n        }\n        if (!this.getMetadata('kernelspec')) {\n            this.sharedModel.setMetadata('kernelspec', {\n                name: '',\n                display_name: ''\n            });\n        }\n    }\n    /**\n     * Trigger a state change signal.\n     */\n    triggerStateChange(args) {\n        this._stateChanged.emit(args);\n    }\n    /**\n     * Trigger a content changed signal.\n     */\n    triggerContentChange() {\n        this._contentChanged.emit(void 0);\n        this.dirty = true;\n    }\n    /**\n     * Whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n}\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from './model';\n/**\n * A model factory for notebooks.\n */\nexport class NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._disposed = false;\n        this._disableDocumentWideUndoRedo =\n            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : true;\n        this._collaborative = (_b = options.collaborative) !== null && _b !== void 0 ? _b : true;\n    }\n    /**\n     * Define the disableDocumentWideUndoRedo property.\n     *\n     * @experimental\n     * @alpha\n     */\n    get disableDocumentWideUndoRedo() {\n        return this._disableDocumentWideUndoRedo;\n    }\n    set disableDocumentWideUndoRedo(disableDocumentWideUndoRedo) {\n        this._disableDocumentWideUndoRedo = disableDocumentWideUndoRedo;\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'notebook';\n    }\n    /**\n     * The content type of the file.\n     */\n    get contentType() {\n        return 'notebook';\n    }\n    /**\n     * The format of the file.\n     */\n    get fileFormat() {\n        return 'json';\n    }\n    /**\n     * Whether the model is collaborative or not.\n     */\n    get collaborative() {\n        return this._collaborative;\n    }\n    /**\n     * Get whether the model factory has been disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the model factory.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param options Model options.\n     *\n     * @returns A new document model.\n     */\n    createNew(options = {}) {\n        return new NotebookModel({\n            languagePreference: options.languagePreference,\n            sharedModel: options.sharedModel,\n            collaborationEnabled: options.collaborationEnabled && this.collaborative,\n            disableDocumentWideUndoRedo: this._disableDocumentWideUndoRedo\n        });\n    }\n    /**\n     * Get the preferred kernel language given a path.\n     */\n    preferredLanguage(path) {\n        return '';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport * as React from 'react';\n/**\n * A pure function for rendering a Command/Edit mode component.\n *\n * @param props the props for rendering the component.\n *\n * @returns a tsx component for command/edit mode.\n */\nfunction CommandEditComponent(props) {\n    const trans = (props.translator || nullTranslator).load('jupyterlab');\n    return (React.createElement(TextItem, { source: trans.__('Mode: %1', props.modeNames[props.notebookMode]) }));\n}\n/**\n * StatusBar item to display which notebook mode user is in.\n */\nexport class CommandEditStatus extends VDomRenderer {\n    /**\n     * Construct a new CommandEdit status item.\n     */\n    constructor(translator) {\n        super(new CommandEditStatus.Model());\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._modeNames = {\n            command: this._trans.__('Command'),\n            edit: this._trans.__('Edit')\n        };\n    }\n    /**\n     * Render the CommandEdit status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = this._trans.__('Notebook is in %1 mode', this._modeNames[this.model.notebookMode]);\n        return (React.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator, modeNames: this._modeNames }));\n    }\n}\n/**\n * A namespace for CommandEdit statics.\n */\n(function (CommandEditStatus) {\n    /**\n     * A VDomModel for the CommandEdit renderer.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            /**\n             * On a change to the notebook, update the mode.\n             */\n            this._onChanged = (_notebook) => {\n                const oldMode = this._notebookMode;\n                if (this._notebook) {\n                    this._notebookMode = _notebook.mode;\n                }\n                else {\n                    this._notebookMode = 'command';\n                }\n                this._triggerChange(oldMode, this._notebookMode);\n            };\n            this._notebookMode = 'command';\n            this._notebook = null;\n        }\n        /**\n         * The current mode of the current notebook.\n         */\n        get notebookMode() {\n            return this._notebookMode;\n        }\n        /**\n         * Set the current notebook for the model.\n         */\n        set notebook(notebook) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.stateChanged.disconnect(this._onChanged, this);\n                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);\n            }\n            const oldMode = this._notebookMode;\n            this._notebook = notebook;\n            if (this._notebook === null) {\n                this._notebookMode = 'command';\n            }\n            else {\n                this._notebookMode = this._notebook.mode;\n                this._notebook.stateChanged.connect(this._onChanged, this);\n                this._notebook.activeCellChanged.connect(this._onChanged, this);\n                this._notebook.modelContentChanged.connect(this._onChanged, this);\n            }\n            this._triggerChange(oldMode, this._notebookMode);\n        }\n        /**\n         * Trigger a state change for the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState !== newState) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    CommandEditStatus.Model = Model;\n})(CommandEditStatus || (CommandEditStatus = {}));\n//# sourceMappingURL=modestatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { IEditorMimeTypeService } from '@jupyterlab/codeeditor';\nimport { untilReady, VirtualDocument, WidgetLSPAdapter } from '@jupyterlab/lsp';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookAdapter extends WidgetLSPAdapter {\n    constructor(editorWidget, options) {\n        super(editorWidget, options);\n        this.editorWidget = editorWidget;\n        this.options = options;\n        this._type = 'code';\n        this._readyDelegate = new PromiseDelegate();\n        this._editorToCell = new Map();\n        this.editor = editorWidget.content;\n        this._cellToEditor = new WeakMap();\n        Promise.all([\n            this.widget.context.sessionContext.ready,\n            this.connectionManager.ready\n        ])\n            .then(async () => {\n            await this.initOnceReady();\n            this._readyDelegate.resolve();\n        })\n            .catch(console.error);\n    }\n    /**\n     * Get current path of the document.\n     */\n    get documentPath() {\n        return this.widget.context.path;\n    }\n    /**\n     * Get the mime type of the document.\n     */\n    get mimeType() {\n        var _a;\n        let mimeType;\n        let languageMetadata = this.language_info();\n        if (!languageMetadata || !languageMetadata.mimetype) {\n            // fallback to the code cell mime type if no kernel in use\n            mimeType = this.widget.content.codeMimetype;\n        }\n        else {\n            mimeType = languageMetadata.mimetype;\n        }\n        return Array.isArray(mimeType)\n            ? (_a = mimeType[0]) !== null && _a !== void 0 ? _a : IEditorMimeTypeService.defaultMimeType\n            : mimeType;\n    }\n    /**\n     * Get the file extension of the document.\n     */\n    get languageFileExtension() {\n        let languageMetadata = this.language_info();\n        if (!languageMetadata || !languageMetadata.file_extension) {\n            return;\n        }\n        return languageMetadata.file_extension.replace('.', '');\n    }\n    /**\n     * Get the inner HTMLElement of the document widget.\n     */\n    get wrapperElement() {\n        return this.widget.node;\n    }\n    /**\n     *  Get the list of CM editor with its type in the document,\n     */\n    get editors() {\n        if (this.isDisposed) {\n            return [];\n        }\n        let notebook = this.widget.content;\n        this._editorToCell.clear();\n        if (notebook.isDisposed) {\n            return [];\n        }\n        return notebook.widgets.map(cell => {\n            return {\n                ceEditor: this._getCellEditor(cell),\n                type: cell.model.type,\n                value: cell.model.sharedModel.getSource()\n            };\n        });\n    }\n    /**\n     * Get the activated CM editor.\n     */\n    get activeEditor() {\n        return this.editor.activeCell\n            ? this._getCellEditor(this.editor.activeCell)\n            : undefined;\n    }\n    /**\n     * Promise that resolves once the adapter is initialized\n     */\n    get ready() {\n        return this._readyDelegate.promise;\n    }\n    /**\n     * Get the index of editor from the cursor position in the virtual\n     * document.\n     * @deprecated This is error-prone and will be removed in JupyterLab 5.0, use `getEditorIndex()` with `virtualDocument.getEditorAtVirtualLine(position)` instead.\n     *\n     * @param position - the position of cursor in the virtual document.\n     */\n    getEditorIndexAt(position) {\n        let cell = this._getCellAt(position);\n        let notebook = this.widget.content;\n        return notebook.widgets.findIndex(otherCell => {\n            return cell === otherCell;\n        });\n    }\n    /**\n     * Get the index of input editor\n     *\n     * @param ceEditor - instance of the code editor\n     */\n    getEditorIndex(ceEditor) {\n        let cell = this._editorToCell.get(ceEditor);\n        return this.editor.widgets.findIndex(otherCell => {\n            return cell === otherCell;\n        });\n    }\n    /**\n     * Get the wrapper of input editor.\n     *\n     * @param ceEditor - instance of the code editor\n     */\n    getEditorWrapper(ceEditor) {\n        let cell = this._editorToCell.get(ceEditor);\n        return cell.node;\n    }\n    /**\n     * Callback on kernel changed event, it will disconnect the\n     * document with the language server and then reconnect.\n     *\n     * @param _session - Session context of changed kernel\n     * @param change - Changed data\n     */\n    async onKernelChanged(_session, change) {\n        if (!change.newValue) {\n            return;\n        }\n        try {\n            // note: we need to wait until ready before updating language info\n            const oldLanguageInfo = this._languageInfo;\n            await untilReady(this.isReady, -1);\n            await this._updateLanguageInfo();\n            const newLanguageInfo = this._languageInfo;\n            if ((oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.name) != newLanguageInfo.name ||\n                (oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.mimetype) != (newLanguageInfo === null || newLanguageInfo === void 0 ? void 0 : newLanguageInfo.mimetype) ||\n                (oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.file_extension) != (newLanguageInfo === null || newLanguageInfo === void 0 ? void 0 : newLanguageInfo.file_extension)) {\n                console.log(`Changed to ${this._languageInfo.name} kernel, reconnecting`);\n                this.reloadConnection();\n            }\n            else {\n                console.log('Keeping old LSP connection as the new kernel uses the same langauge');\n            }\n        }\n        catch (err) {\n            console.warn(err);\n            // try to reconnect anyway\n            this.reloadConnection();\n        }\n    }\n    /**\n     * Dispose the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.widget.context.sessionContext.kernelChanged.disconnect(this.onKernelChanged, this);\n        this.widget.content.activeCellChanged.disconnect(this._activeCellChanged, this);\n        super.dispose();\n        // editors are needed for the parent dispose() to unbind signals, so they are the last to go\n        this._editorToCell.clear();\n        Signal.clearData(this);\n    }\n    /**\n     * Method to check if the notebook context is ready.\n     */\n    isReady() {\n        var _a;\n        return (!this.widget.isDisposed &&\n            this.widget.context.isReady &&\n            this.widget.content.isVisible &&\n            this.widget.content.widgets.length > 0 &&\n            ((_a = this.widget.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) != null);\n    }\n    /**\n     * Update the virtual document on cell changing event.\n     *\n     * @param cells - Observable list of changed cells\n     * @param change - Changed data\n     */\n    async handleCellChange(cells, change) {\n        let cellsAdded = [];\n        let cellsRemoved = [];\n        const type = this._type;\n        if (change.type === 'set') {\n            // handling of conversions is important, because the editors get re-used and their handlers inherited,\n            // so we need to clear our handlers from editors of e.g. markdown cells which previously were code cells.\n            let convertedToMarkdownOrRaw = [];\n            let convertedToCode = [];\n            if (change.newValues.length === change.oldValues.length) {\n                // during conversion the cells should not get deleted nor added\n                for (let i = 0; i < change.newValues.length; i++) {\n                    if (change.oldValues[i].type === type &&\n                        change.newValues[i].type !== type) {\n                        convertedToMarkdownOrRaw.push(change.newValues[i]);\n                    }\n                    else if (change.oldValues[i].type !== type &&\n                        change.newValues[i].type === type) {\n                        convertedToCode.push(change.newValues[i]);\n                    }\n                }\n                cellsAdded = convertedToCode;\n                cellsRemoved = convertedToMarkdownOrRaw;\n            }\n        }\n        else if (change.type == 'add') {\n            cellsAdded = change.newValues.filter(cellModel => cellModel.type === type);\n        }\n        // note: editorRemoved is not emitted for removal of cells by change of type 'remove' (but only during cell type conversion)\n        // because there is no easy way to get the widget associated with the removed cell(s) - because it is no\n        // longer in the notebook widget list! It would need to be tracked on our side, but it is not necessary\n        // as (except for a tiny memory leak) it should not impact the functionality in any way\n        if (cellsRemoved.length ||\n            cellsAdded.length ||\n            change.type === 'set' ||\n            change.type === 'move' ||\n            change.type === 'remove') {\n            // in contrast to the file editor document which can be only changed by the modification of the editor content,\n            // the notebook document can also get modified by a change in the number or arrangement of editors themselves;\n            // for this reason each change has to trigger documents update (so that LSP mirror is in sync).\n            await this.updateDocuments();\n        }\n        for (let cellModel of cellsAdded) {\n            let cellWidget = this.widget.content.widgets.find(cell => cell.model.id === cellModel.id);\n            if (!cellWidget) {\n                console.warn(`Widget for added cell with ID: ${cellModel.id} not found!`);\n                continue;\n            }\n            // Add editor to the mapping if needed\n            this._getCellEditor(cellWidget);\n        }\n    }\n    /**\n     * Generate the virtual document associated with the document.\n     */\n    createVirtualDocument() {\n        return new VirtualDocument({\n            language: this.language,\n            foreignCodeExtractors: this.options.foreignCodeExtractorsManager,\n            path: this.documentPath,\n            fileExtension: this.languageFileExtension,\n            // notebooks are continuous, each cell is dependent on the previous one\n            standalone: false,\n            // notebooks are not supported by LSP servers\n            hasLspSupportedFile: false\n        });\n    }\n    /**\n     * Get the metadata of notebook.\n     */\n    language_info() {\n        return this._languageInfo;\n    }\n    /**\n     * Initialization function called once the editor and the LSP connection\n     * manager is ready. This function will create the virtual document and\n     * connect various signals.\n     */\n    async initOnceReady() {\n        await untilReady(this.isReady.bind(this), -1);\n        await this._updateLanguageInfo();\n        this.initVirtual();\n        // connect the document, but do not open it as the adapter will handle this\n        // after registering all features\n        this.connectDocument(this.virtualDocument, false).catch(console.warn);\n        this.widget.context.sessionContext.kernelChanged.connect(this.onKernelChanged, this);\n        this.widget.content.activeCellChanged.connect(this._activeCellChanged, this);\n        this._connectModelSignals(this.widget);\n        this.editor.modelChanged.connect(notebook => {\n            // note: this should not usually happen;\n            // there is no default action that would trigger this,\n            // its just a failsafe in case if another extension decides\n            // to swap the notebook model\n            console.warn('Model changed, connecting cell change handler; this is not something we were expecting');\n            this._connectModelSignals(notebook);\n        });\n    }\n    /**\n     * Connect the cell changed event to its handler\n     *\n     * @param  notebook - The notebook that emitted event.\n     */\n    _connectModelSignals(notebook) {\n        if (notebook.model === null) {\n            console.warn(`Model is missing for notebook ${notebook}, cannot connect cell changed signal!`);\n        }\n        else {\n            notebook.model.cells.changed.connect(this.handleCellChange, this);\n        }\n    }\n    /**\n     * Update the stored language info with the one from the notebook.\n     */\n    async _updateLanguageInfo() {\n        var _a, _b, _c, _d;\n        const language_info = (_d = (await ((_c = (_b = (_a = this.widget.context.sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.info))) === null || _d === void 0 ? void 0 : _d.language_info;\n        if (language_info) {\n            this._languageInfo = language_info;\n        }\n        else {\n            throw new Error('Language info update failed (no session, kernel, or info available)');\n        }\n    }\n    /**\n     * Handle the cell changed event\n     * @param  notebook - The notebook that emitted event\n     * @param cell - Changed cell.\n     */\n    _activeCellChanged(notebook, cell) {\n        if (!cell || cell.model.type !== this._type) {\n            return;\n        }\n        this._activeEditorChanged.emit({\n            editor: this._getCellEditor(cell)\n        });\n    }\n    /**\n     * Get the cell at the cursor position of the virtual document.\n     * @param  pos - Position in the virtual document.\n     */\n    _getCellAt(pos) {\n        let editor = this.virtualDocument.getEditorAtVirtualLine(pos);\n        return this._editorToCell.get(editor);\n    }\n    /**\n     * Get the cell editor and add new ones to the mappings.\n     *\n     * @param cell Cell widget\n     * @returns Cell editor accessor\n     */\n    _getCellEditor(cell) {\n        if (!this._cellToEditor.has(cell)) {\n            const editor = Object.freeze({\n                getEditor: () => cell.editor,\n                ready: async () => {\n                    await cell.ready;\n                    return cell.editor;\n                },\n                reveal: async () => {\n                    await this.editor.scrollToCell(cell);\n                    return cell.editor;\n                }\n            });\n            this._cellToEditor.set(cell, editor);\n            this._editorToCell.set(editor, cell);\n            cell.disposed.connect(() => {\n                this._cellToEditor.delete(cell);\n                this._editorToCell.delete(editor);\n                this._editorRemoved.emit({\n                    editor\n                });\n            });\n            this._editorAdded.emit({\n                editor\n            });\n        }\n        return this._cellToEditor.get(cell);\n    }\n}\n//# sourceMappingURL=notebooklspadapter.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { JSONEditor } from '@jupyterlab/codeeditor';\nimport { ObservableJSON } from '@jupyterlab/observables';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Collapser } from '@jupyterlab/ui-components';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nclass RankedPanel extends Widget {\n    constructor() {\n        super();\n        this._items = [];\n        this.layout = new PanelLayout();\n        this.addClass('jp-RankedPanel');\n    }\n    addWidget(widget, rank) {\n        const rankItem = { widget, rank };\n        const index = ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);\n        ArrayExt.insert(this._items, index, rankItem);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n    }\n    /**\n     * Handle the removal of a child\n     *\n     */\n    onChildRemoved(msg) {\n        const index = ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);\n        if (index !== -1) {\n            ArrayExt.removeAt(this._items, index);\n        }\n    }\n}\n/**\n * A widget that provides metadata tools.\n */\nexport class NotebookTools extends Widget {\n    /**\n     * Construct a new NotebookTools object.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-NotebookTools');\n        this.translator = options.translator || nullTranslator;\n        this._tools = [];\n        this.layout = new PanelLayout();\n        this._tracker = options.tracker;\n        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);\n        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);\n        this._onActiveNotebookPanelChanged();\n        this._onActiveCellChanged();\n        this._onSelectionChanged();\n    }\n    /**\n     * The active cell widget.\n     */\n    get activeCell() {\n        return this._tracker.activeCell;\n    }\n    /**\n     * The currently selected cells.\n     */\n    get selectedCells() {\n        const panel = this._tracker.currentWidget;\n        if (!panel) {\n            return [];\n        }\n        const notebook = panel.content;\n        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));\n    }\n    /**\n     * The current notebook.\n     */\n    get activeNotebookPanel() {\n        return this._tracker.currentWidget;\n    }\n    /**\n     * Add a cell tool item.\n     */\n    addItem(options) {\n        var _a;\n        const tool = options.tool;\n        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;\n        let section;\n        const extendedTool = this._tools.find(extendedTool => extendedTool.section === options.section);\n        if (extendedTool)\n            section = extendedTool.panel;\n        else {\n            throw new Error(`The section ${options.section} does not exist`);\n        }\n        tool.addClass('jp-NotebookTools-tool');\n        section.addWidget(tool, rank);\n        // TODO: perhaps the necessary notebookTools functionality should be\n        // consolidated into a single object, rather than a broad reference to this.\n        tool.notebookTools = this;\n        // Trigger the tool to update its active notebook and cell.\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);\n    }\n    /*\n     * Add a section to the notebook tool with its widget\n     */\n    addSection(options) {\n        var _a;\n        const sectionName = options.sectionName;\n        const label = options.label || options.sectionName;\n        const widget = options.tool;\n        let rank = (_a = options.rank) !== null && _a !== void 0 ? _a : null;\n        const newSection = new RankedPanel();\n        newSection.title.label = label;\n        if (widget)\n            newSection.addWidget(widget, 0);\n        this._tools.push({\n            section: sectionName,\n            panel: newSection,\n            rank: rank\n        });\n        if (rank != null)\n            this.layout.insertWidget(rank, new Collapser({ widget: newSection }));\n        else {\n            // If no rank is provided, try to add the new section before the AdvancedTools.\n            let advancedToolsRank = null;\n            const layout = this.layout;\n            for (let i = 0; i < layout.widgets.length; i++) {\n                let w = layout.widgets[i];\n                if (w instanceof Collapser) {\n                    if (w.widget.id === 'advancedToolsSection') {\n                        advancedToolsRank = i;\n                        break;\n                    }\n                }\n            }\n            if (advancedToolsRank !== null)\n                this.layout.insertWidget(advancedToolsRank, new Collapser({ widget: newSection }));\n            else\n                this.layout.addWidget(new Collapser({ widget: newSection }));\n        }\n    }\n    /**\n     * Handle a change to the notebook panel.\n     */\n    _onActiveNotebookPanelChanged() {\n        if (this._prevActiveNotebookModel &&\n            !this._prevActiveNotebookModel.isDisposed) {\n            this._prevActiveNotebookModel.metadataChanged.disconnect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content\n            ? this.activeNotebookPanel.content.model\n            : null;\n        this._prevActiveNotebookModel = activeNBModel;\n        if (activeNBModel) {\n            activeNBModel.metadataChanged.connect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);\n        }\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    _onActiveCellChanged() {\n        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {\n            this._prevActiveCell.metadataChanged.disconnect(this._onActiveCellMetadataChanged, this);\n        }\n        const activeCell = this.activeCell ? this.activeCell.model : null;\n        this._prevActiveCell = activeCell;\n        if (activeCell) {\n            activeCell.metadataChanged.connect(this._onActiveCellMetadataChanged, this);\n        }\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);\n        }\n    }\n    /**\n     * Handle a change in the selection.\n     */\n    _onSelectionChanged() {\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);\n        }\n    }\n    /**\n     * Handle a change in the active cell metadata.\n     */\n    _onActiveNotebookPanelMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', { oldValue: undefined, newValue: undefined, ...args });\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, message);\n        }\n    }\n    /**\n     * Handle a change in the notebook model metadata.\n     */\n    _onActiveCellMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activecell-metadata-changed', { newValue: undefined, oldValue: undefined, ...args });\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, message);\n        }\n    }\n    *_toolChildren() {\n        for (let tool of this._tools) {\n            yield* tool.panel.children();\n        }\n    }\n}\n/**\n * The namespace for NotebookTools class statics.\n */\n(function (NotebookTools) {\n    /**\n     * A singleton conflatable `'activenotebookpanel-changed'` message.\n     */\n    NotebookTools.ActiveNotebookPanelMessage = new ConflatableMessage('activenotebookpanel-changed');\n    /**\n     * A singleton conflatable `'activecell-changed'` message.\n     */\n    NotebookTools.ActiveCellMessage = new ConflatableMessage('activecell-changed');\n    /**\n     * A singleton conflatable `'selection-changed'` message.\n     */\n    NotebookTools.SelectionMessage = new ConflatableMessage('selection-changed');\n    /**\n     * The base notebook tool, meant to be subclassed.\n     */\n    class Tool extends Widget {\n        dispose() {\n            super.dispose();\n            if (this.notebookTools) {\n                this.notebookTools = null;\n            }\n        }\n        /**\n         * Process a message sent to the widget.\n         *\n         * @param msg - The message sent to the widget.\n         */\n        processMessage(msg) {\n            super.processMessage(msg);\n            switch (msg.type) {\n                case 'activenotebookpanel-changed':\n                    this.onActiveNotebookPanelChanged(msg);\n                    break;\n                case 'activecell-changed':\n                    this.onActiveCellChanged(msg);\n                    break;\n                case 'selection-changed':\n                    this.onSelectionChanged(msg);\n                    break;\n                case 'activecell-metadata-changed':\n                    this.onActiveCellMetadataChanged(msg);\n                    break;\n                case 'activenotebookpanel-metadata-changed':\n                    this.onActiveNotebookPanelMetadataChanged(msg);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle a change to the notebook panel.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the selection.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onSelectionChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellMetadataChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            /* no-op */\n        }\n    }\n    NotebookTools.Tool = Tool;\n    /**\n     * A raw metadata editor.\n     */\n    class MetadataEditorTool extends Tool {\n        /**\n         * Construct a new raw metadata tool.\n         */\n        constructor(options) {\n            super();\n            const { editorFactory } = options;\n            this.addClass('jp-MetadataEditorTool');\n            const layout = (this.layout = new PanelLayout());\n            this._editorFactory = editorFactory;\n            this._editorLabel = options.label || 'Edit Metadata';\n            this.createEditor();\n            const titleNode = new Widget({ node: document.createElement('label') });\n            titleNode.node.textContent = options.label || 'Edit Metadata';\n            layout.addWidget(titleNode);\n            layout.addWidget(this.editor);\n        }\n        /**\n         * The editor used by the tool.\n         */\n        get editor() {\n            return this._editor;\n        }\n        /**\n         * Handle a change to the notebook.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            this.editor.dispose();\n            if (this.notebookTools.activeNotebookPanel) {\n                this.createEditor();\n            }\n        }\n        createEditor() {\n            this._editor = new JSONEditor({\n                editorFactory: this._editorFactory\n            });\n            this.editor.title.label = this._editorLabel;\n            this.layout.addWidget(this.editor);\n        }\n    }\n    NotebookTools.MetadataEditorTool = MetadataEditorTool;\n})(NotebookTools || (NotebookTools = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A comparator function for widget rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=notebooktools.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/**\n * The class name added to a drop target.\n */\nexport const DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The class name added to a drop source.\n */\nexport const DROP_SOURCE_CLASS = 'jp-mod-dropSource';\n//# sourceMappingURL=constants.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { CodeCell, CodeCellModel } from '@jupyterlab/cells';\nimport { WindowedLayout, WindowedListModel } from '@jupyterlab/ui-components';\nimport { MessageLoop } from '@lumino/messaging';\nimport { Debouncer } from '@lumino/polling';\nimport { Widget } from '@lumino/widgets';\nimport { DROP_SOURCE_CLASS, DROP_TARGET_CLASS } from './constants';\n/**\n * Notebook view model for the windowed list.\n */\nexport class NotebookViewModel extends WindowedListModel {\n    /**\n     * Construct a notebook windowed list model.\n     */\n    constructor(cells, options) {\n        super(options);\n        this.cells = cells;\n        /**\n         * Cell size estimator\n         *\n         * @param index Cell index\n         * @returns Cell height in pixels\n         */\n        this.estimateWidgetSize = (index) => {\n            const model = this.cells[index].model;\n            const height = this.cellsEstimatedHeight.get(model.id);\n            if (typeof height === 'number') {\n                return height;\n            }\n            const nLines = model.sharedModel.getSource().split('\\n').length;\n            let outputsLines = 0;\n            if (model instanceof CodeCellModel && !model.isDisposed) {\n                for (let outputIdx = 0; outputIdx < model.outputs.length; outputIdx++) {\n                    const output = model.outputs.get(outputIdx);\n                    const data = output.data['text/plain'];\n                    if (typeof data === 'string') {\n                        outputsLines += data.split('\\n').length;\n                    }\n                    else if (Array.isArray(data)) {\n                        outputsLines += data.join('').split('\\n').length;\n                    }\n                }\n            }\n            return (NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT * (nLines + outputsLines) +\n                NotebookViewModel.DEFAULT_CELL_MARGIN);\n        };\n        /**\n         * Render the cell at index.\n         *\n         * @param index Cell index\n         * @returns Cell widget\n         */\n        this.widgetRenderer = (index) => {\n            return this.cells[index];\n        };\n        /**\n         * Threshold used to decide if the cell should be scrolled to in the `smart` mode.\n         * Defaults to scrolling when less than a full line of the cell is visible.\n         */\n        this.scrollDownThreshold = NotebookViewModel.DEFAULT_CELL_MARGIN / 2 +\n            NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT;\n        /**\n         * Threshold used to decide if the cell should be scrolled to in the `smart` mode.\n         * Defaults to scrolling when the cell margin or more is invisible.\n         */\n        this.scrollUpThreshold = NotebookViewModel.DEFAULT_CELL_MARGIN / 2;\n        /**\n         * Mapping between the cell ids and the cell estimated heights\n         *\n         * This height is not refreshed with the changes to the document.\n         * It is only used to measure cells outside the viewport on CPU\n         * idle cycle to improve UX scrolling.\n         */\n        this.cellsEstimatedHeight = new Map();\n        this._emitEstimatedHeightChanged = new Debouncer(() => {\n            this._stateChanged.emit({\n                name: 'estimatedWidgetSize',\n                newValue: null,\n                oldValue: null\n            });\n        });\n        // Set default cell size\n        this._estimatedWidgetSize = NotebookViewModel.DEFAULT_CELL_SIZE;\n    }\n    /**\n     * Set an estimated height for a cell\n     *\n     * @param cellId Cell ID\n     * @param size Cell height\n     */\n    setEstimatedWidgetSize(cellId, size) {\n        if (size === null) {\n            if (this.cellsEstimatedHeight.has(cellId)) {\n                this.cellsEstimatedHeight.delete(cellId);\n            }\n        }\n        else {\n            this.cellsEstimatedHeight.set(cellId, size);\n            this._emitEstimatedHeightChanged.invoke().catch(error => {\n                console.error('Fail to trigger an update following a estimated height update.', error);\n            });\n        }\n    }\n}\n/**\n * Default cell height\n */\nNotebookViewModel.DEFAULT_CELL_SIZE = 39;\n/**\n * Default editor line height\n */\nNotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT = 17;\n/**\n * Default cell margin (top + bottom)\n */\nNotebookViewModel.DEFAULT_CELL_MARGIN = 22;\n/**\n * Windowed list layout for the notebook.\n */\nexport class NotebookWindowedLayout extends WindowedLayout {\n    constructor() {\n        super(...arguments);\n        this._header = null;\n        this._footer = null;\n        this._willBeRemoved = null;\n        this._topHiddenCodeCells = -1;\n    }\n    /**\n     * Notebook's header\n     */\n    get header() {\n        return this._header;\n    }\n    set header(header) {\n        var _a;\n        if (this._header && this._header.isAttached) {\n            Widget.detach(this._header);\n        }\n        this._header = header;\n        if (this._header && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {\n            Widget.attach(this._header, this.parent.node);\n        }\n    }\n    /**\n     * Notebook widget's footer\n     */\n    get footer() {\n        return this._footer;\n    }\n    set footer(footer) {\n        var _a;\n        if (this._footer && this._footer.isAttached) {\n            Widget.detach(this._footer);\n        }\n        this._footer = footer;\n        if (this._footer && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {\n            Widget.attach(this._footer, this.parent.outerNode);\n        }\n    }\n    /**\n     * Notebook's active cell\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    set activeCell(widget) {\n        this._activeCell = widget;\n    }\n    /**\n     * Dispose the layout\n     * */\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        (_a = this._header) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this._footer) === null || _b === void 0 ? void 0 : _b.dispose();\n        super.dispose();\n    }\n    /**\n     * * A message handler invoked on a `'child-removed'` message.\n     * *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        const index = this.widgets.indexOf(widget);\n        // We need to deal with code cell widget not in viewport (aka not in this.widgets) but still\n        // partly attached\n        if (index >= 0) {\n            this.removeWidgetAt(index);\n        } // If the layout is parented, detach the widget from the DOM.\n        else if (widget === this._willBeRemoved && this.parent) {\n            this.detachWidget(index, widget);\n        }\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    attachWidget(index, widget) {\n        // Status may change in onBeforeAttach\n        const wasPlaceholder = widget.isPlaceholder();\n        // Initialized sub-widgets or attached them for CodeCell\n        // Because this reattaches all sub-widget to the DOM which leads\n        // to a loss of focus, we do not call it for soft-hidden cells.\n        const isSoftHidden = this._isSoftHidden(widget);\n        if (this.parent.isAttached && !isSoftHidden) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        if (isSoftHidden) {\n            // Restore visibility for active, or previously active cell\n            this._toggleSoftVisibility(widget, true);\n        }\n        if (!wasPlaceholder &&\n            widget instanceof CodeCell &&\n            widget.node.parentElement) {\n            // We don't remove code cells to preserve outputs internal state\n            widget.node.style.display = '';\n            // Reset cache\n            this._topHiddenCodeCells = -1;\n        }\n        else if (!isSoftHidden) {\n            // Look up the next sibling reference node.\n            const siblingIndex = this._findNearestChildBinarySearch(this.parent.viewportNode.childElementCount - 1, 0, parseInt(widget.dataset.windowedListIndex, 10) + 1);\n            let ref = this.parent.viewportNode.children[siblingIndex];\n            // Insert the widget's node before the sibling.\n            this.parent.viewportNode.insertBefore(widget.node, ref);\n            // Send an `'after-attach'` message if the parent is attached.\n            // Event listeners will be added here\n            // Some widgets are updating/resetting when attached, so\n            // we should not recall this each time a cell move into the\n            // viewport.\n            if (this.parent.isAttached) {\n                MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n            }\n        }\n        widget.inViewport = true;\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    detachWidget(index, widget) {\n        widget.inViewport = false;\n        // Note: `index` is relative to the displayed cells, not all cells,\n        // hence we compare with the widget itself.\n        if (widget === this.activeCell && widget !== this._willBeRemoved) {\n            // Do not change display of the active cell to allow user to continue providing input\n            // into the code mirror editor when out of view. We still hide the cell so to prevent\n            // minor visual glitches when scrolling.\n            this._toggleSoftVisibility(widget, false);\n            // Return before sending \"AfterDetach\" message to CodeCell\n            // to prevent removing contents of the active cell.\n            return;\n        }\n        // TODO we could improve this further by discarding also the code cell without outputs\n        if (\n        // We detach the code cell currently dragged otherwise it won't be attached at the correct position\n        widget instanceof CodeCell &&\n            !widget.node.classList.contains(DROP_SOURCE_CLASS) &&\n            widget !== this._willBeRemoved) {\n            // We don't remove code cells to preserve outputs internal state\n            // Transform does not work because the widget height is kept (at least in FF)\n            widget.node.style.display = 'none';\n            // Reset cache\n            this._topHiddenCodeCells = -1;\n        }\n        else {\n            // Send a `'before-detach'` message if the parent is attached.\n            // This should not be called every time a cell leaves the viewport\n            // as it will remove listeners that won't be added back as afterAttach\n            // is shunted to avoid unwanted update/reset.\n            if (this.parent.isAttached) {\n                // Event listeners will be removed here\n                MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n            }\n            // Remove the widget's node from the parent.\n            this.parent.viewportNode.removeChild(widget.node);\n            // Ensure to clean up drop target class if the widget move out of the viewport\n            widget.node.classList.remove(DROP_TARGET_CLASS);\n        }\n        if (this.parent.isAttached) {\n            // Detach sub widget of CodeCell except the OutputAreaWrapper\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation moves the widget's node to the proper\n     * location in the parent's node and sends the appropriate attach and\n     * detach messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is moved in the parent's node.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Optimize move without de-/attaching as motion appends with parent attached\n        // Case fromIndex === toIndex, already checked in PanelLayout.insertWidget\n        if (this._topHiddenCodeCells < 0) {\n            this._topHiddenCodeCells = 0;\n            for (let idx = 0; idx < this.parent.viewportNode.children.length; idx++) {\n                const n = this.parent.viewportNode.children[idx];\n                if (n.style.display == 'none') {\n                    this._topHiddenCodeCells++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        const ref = this.parent.viewportNode.children[toIndex + this._topHiddenCodeCells];\n        if (fromIndex < toIndex) {\n            ref.insertAdjacentElement('afterend', widget.node);\n        }\n        else {\n            ref.insertAdjacentElement('beforebegin', widget.node);\n        }\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        if (this._header && !this._header.isAttached) {\n            Widget.attach(this._header, this.parent.node, this.parent.node.firstElementChild);\n        }\n        if (this._footer && !this._footer.isAttached) {\n            Widget.attach(this._footer, this.parent.outerNode);\n        }\n    }\n    onBeforeDetach(msg) {\n        var _a, _b;\n        if ((_a = this._header) === null || _a === void 0 ? void 0 : _a.isAttached) {\n            Widget.detach(this._header);\n        }\n        if ((_b = this._footer) === null || _b === void 0 ? void 0 : _b.isAttached) {\n            Widget.detach(this._footer);\n        }\n        super.onBeforeDetach(msg);\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * @param msg Message\n     */\n    onChildRemoved(msg) {\n        this._willBeRemoved = msg.child;\n        super.onChildRemoved(msg);\n        this._willBeRemoved = null;\n    }\n    /**\n     * Toggle \"soft\" visibility of the widget.\n     *\n     * #### Notes\n     * To ensure that user events reach the CodeMirror editor, this method\n     * does not toggle `display` nor `visibility` which have side effects,\n     * but instead hides it in the compositor and ensures that the bounding\n     * box is has an area equal to zero.\n     * To ensure we do not trigger style recalculation, we set the styles\n     * directly on the node instead of using a class.\n     */\n    _toggleSoftVisibility(widget, show) {\n        if (show) {\n            widget.node.style.opacity = '';\n            widget.node.style.height = '';\n            widget.node.style.padding = '';\n        }\n        else {\n            widget.node.style.opacity = '0';\n            // Both padding and height need to be set to zero\n            // to ensure bounding box collapses to invisible.\n            widget.node.style.height = '0';\n            widget.node.style.padding = '0';\n        }\n    }\n    _isSoftHidden(widget) {\n        return widget.node.style.opacity === '0';\n    }\n    _findNearestChildBinarySearch(high, low, index) {\n        while (low <= high) {\n            const middle = low + Math.floor((high - low) / 2);\n            const currentIndex = parseInt(this.parent.viewportNode.children[middle].dataset\n                .windowedListIndex, 10);\n            if (currentIndex === index) {\n                return middle;\n            }\n            else if (currentIndex < index) {\n                low = middle + 1;\n            }\n            else if (currentIndex > index) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n//# sourceMappingURL=windowing.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\nconst NOTEBOOK_FOOTER_CLASS = 'jp-Notebook-footer';\n/**\n * A footer widget added after the last cell of the notebook.\n */\nexport class NotebookFooter extends Widget {\n    /**\n     * Construct a footer widget.\n     */\n    constructor(notebook) {\n        super({ node: document.createElement('button') });\n        this.notebook = notebook;\n        const trans = notebook.translator.load('jupyterlab');\n        this.addClass(NOTEBOOK_FOOTER_CLASS);\n        this.node.setAttribute('tabindex', '-1');\n        this.node.innerText = trans.__('Click to add a cell.');\n    }\n    /**\n     * Handle incoming events.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'click':\n                this.onClick();\n                break;\n            case 'keydown':\n                if (event.key === 'ArrowUp') {\n                    this.onArrowUp();\n                    break;\n                }\n        }\n    }\n    /**\n     * On single click (mouse event), insert a cell below (at the end of the notebook as default behavior).\n     */\n    onClick() {\n        if (this.notebook.widgets.length > 0) {\n            this.notebook.activeCellIndex = this.notebook.widgets.length - 1;\n        }\n        NotebookActions.insertBelow(this.notebook);\n        // Focus on the created cell.\n        void NotebookActions.focusActiveCell(this.notebook);\n    }\n    /**\n     * On arrow up key pressed (keydown keyboard event).\n     * @deprecated To be removed in v5, this is a no-op\n     */\n    onArrowUp() {\n        // The specific behavior has been removed in https://github.com/jupyterlab/jupyterlab/pull/14796\n    }\n    /*\n     * Handle `after-detach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n        super.onBeforeDetach(msg);\n    }\n}\n//# sourceMappingURL=notebookfooter.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DOMUtils } from '@jupyterlab/apputils';\nimport { Cell, CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';\nimport { IEditorMimeTypeService } from '@jupyterlab/codeeditor';\nimport { TableOfContentsUtils } from '@jupyterlab/toc';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { WindowedList } from '@jupyterlab/ui-components';\nimport { ArrayExt, findIndex } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Drag } from '@lumino/dragdrop';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\nimport { DROP_SOURCE_CLASS, DROP_TARGET_CLASS } from './constants';\nimport { NotebookViewModel, NotebookWindowedLayout } from './windowing';\nimport { NotebookFooter } from './notebookfooter';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * The class name added to notebook widgets.\n */\nconst NB_CLASS = 'jp-Notebook';\n/**\n * The class name added to notebook widget cells.\n */\nconst NB_CELL_CLASS = 'jp-Notebook-cell';\n/**\n * The class name added to a notebook in edit mode.\n */\nconst EDIT_CLASS = 'jp-mod-editMode';\n/**\n * The class name added to a notebook in command mode.\n */\nconst COMMAND_CLASS = 'jp-mod-commandMode';\n/**\n * The class name added to the active cell.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class name added to selected cells.\n */\nconst SELECTED_CLASS = 'jp-mod-selected';\n/**\n * The class name added to the cell when dirty.\n */\nconst DIRTY_CLASS = 'jp-mod-dirty';\n/**\n * The class name added to an active cell when there are other selected cells.\n */\nconst OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';\n/**\n * The class name added to unconfined images.\n */\nconst UNCONFINED_CLASS = 'jp-mod-unconfined';\n/**\n * The class name added to the notebook when an element within it is focused\n * and takes keyboard input, such as focused <input> or <div contenteditable>.\n *\n * This class is also effective when the focused element is in shadow DOM.\n */\nconst READ_WRITE_CLASS = 'jp-mod-readWrite';\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * Maximal remaining time for idle callback\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#getting_the_most_out_of_idle_callbacks\n */\nconst MAXIMUM_TIME_REMAINING = 50;\n/**\n * The class attached to the heading collapser button\n */\nconst HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';\n/**\n * The class that controls the visibility of \"heading collapser\" and \"show hidden cells\" buttons.\n */\nconst HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS = 'jp-mod-showHiddenCellsButton';\nconst SIDE_BY_SIDE_CLASS = 'jp-mod-sideBySide';\nif (window.requestIdleCallback === undefined) {\n    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    window.requestIdleCallback = function (handler) {\n        let startTime = Date.now();\n        return setTimeout(function () {\n            handler({\n                didTimeout: false,\n                timeRemaining: function () {\n                    return Math.max(0, 50.0 - (Date.now() - startTime));\n                }\n            });\n        }, 1);\n    };\n    window.cancelIdleCallback = function (id) {\n        clearTimeout(id);\n    };\n}\n/**\n * A widget which renders static non-interactive notebooks.\n *\n * #### Notes\n * The widget model must be set separately and can be changed\n * at any time.  Consumers of the widget must account for a\n * `null` model, and may want to listen to the `modelChanged`\n * signal.\n */\nexport class StaticNotebook extends WindowedList {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        const cells = new Array();\n        const windowingActive = ((_b = (_a = options.notebookConfig) === null || _a === void 0 ? void 0 : _a.windowingMode) !== null && _b !== void 0 ? _b : StaticNotebook.defaultNotebookConfig.windowingMode) === 'full';\n        super({\n            model: new NotebookViewModel(cells, {\n                overscanCount: (_d = (_c = options.notebookConfig) === null || _c === void 0 ? void 0 : _c.overscanCount) !== null && _d !== void 0 ? _d : StaticNotebook.defaultNotebookConfig.overscanCount,\n                windowingActive\n            }),\n            layout: new NotebookWindowedLayout(),\n            renderer: (_e = options.renderer) !== null && _e !== void 0 ? _e : WindowedList.defaultRenderer,\n            scrollbar: false\n        });\n        this._cellCollapsed = new Signal(this);\n        this._cellInViewportChanged = new Signal(this);\n        this._renderingLayoutChanged = new Signal(this);\n        this.addClass(NB_CLASS);\n        this.cellsArray = cells;\n        this._idleCallBack = null;\n        this._editorConfig = StaticNotebook.defaultEditorConfig;\n        this._notebookConfig = StaticNotebook.defaultNotebookConfig;\n        this._mimetype = IEditorMimeTypeService.defaultMimeType;\n        this._notebookModel = null;\n        this._modelChanged = new Signal(this);\n        this._modelContentChanged = new Signal(this);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.rendermime = options.rendermime;\n        this.translator = options.translator || nullTranslator;\n        this.contentFactory = options.contentFactory;\n        this.editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this.notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._updateNotebookConfig();\n        this._mimetypeService = options.mimeTypeService;\n        this.renderingLayout = (_f = options.notebookConfig) === null || _f === void 0 ? void 0 : _f.renderingLayout;\n        this.kernelHistory = options.kernelHistory;\n    }\n    get cellCollapsed() {\n        return this._cellCollapsed;\n    }\n    get cellInViewportChanged() {\n        return this._cellInViewportChanged;\n    }\n    /**\n     * A signal emitted when the model of the notebook changes.\n     */\n    get modelChanged() {\n        return this._modelChanged;\n    }\n    /**\n     * A signal emitted when the model content changes.\n     *\n     * #### Notes\n     * This is a convenience signal that follows the current model.\n     */\n    get modelContentChanged() {\n        return this._modelContentChanged;\n    }\n    /**\n     * A signal emitted when the rendering layout of the notebook changes.\n     */\n    get renderingLayoutChanged() {\n        return this._renderingLayoutChanged;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this._notebookModel;\n    }\n    set model(newValue) {\n        var _a;\n        newValue = newValue || null;\n        if (this._notebookModel === newValue) {\n            return;\n        }\n        const oldValue = this._notebookModel;\n        this._notebookModel = newValue;\n        // Trigger private, protected, and public changes.\n        this._onModelChanged(oldValue, newValue);\n        this.onModelChanged(oldValue, newValue);\n        this._modelChanged.emit(void 0);\n        // Trigger state change\n        this.viewModel.itemsList = (_a = newValue === null || newValue === void 0 ? void 0 : newValue.cells) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Get the mimetype for code cells.\n     */\n    get codeMimetype() {\n        return this._mimetype;\n    }\n    /**\n     * A read-only sequence of the widgets in the notebook.\n     */\n    get widgets() {\n        return this.cellsArray;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n        this._updateEditorConfig();\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n        this._updateNotebookConfig();\n    }\n    get renderingLayout() {\n        return this._renderingLayout;\n    }\n    set renderingLayout(value) {\n        var _a;\n        this._renderingLayout = value;\n        if (this._renderingLayout === 'side-by-side') {\n            this.node.classList.add(SIDE_BY_SIDE_CLASS);\n        }\n        else {\n            this.node.classList.remove(SIDE_BY_SIDE_CLASS);\n        }\n        this._renderingLayoutChanged.emit((_a = this._renderingLayout) !== null && _a !== void 0 ? _a : 'default');\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        var _a;\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._notebookModel = null;\n        (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();\n        super.dispose();\n    }\n    /**\n     * Move cells preserving widget view state.\n     *\n     * #### Notes\n     * This is required because at the model level a move is a deletion\n     * followed by an insertion. Hence the view state is not preserved.\n     *\n     * @param from The index of the cell to move\n     * @param to The new index of the cell\n     * @param n Number of cells to move\n     */\n    moveCell(from, to, n = 1) {\n        if (!this.model) {\n            return;\n        }\n        const boundedTo = Math.min(this.model.cells.length - 1, Math.max(0, to));\n        if (boundedTo === from) {\n            return;\n        }\n        const viewModel = new Array(n);\n        let dirtyState = new Array(n);\n        for (let i = 0; i < n; i++) {\n            viewModel[i] = {};\n            const oldCell = this.widgets[from + i];\n            if (oldCell.model.type === 'markdown') {\n                for (const k of ['rendered', 'headingCollapsed']) {\n                    // @ts-expect-error Cell has no index signature\n                    viewModel[i][k] = oldCell[k];\n                }\n            }\n            else if (oldCell.model.type === 'code') {\n                const oldCodeCell = oldCell.model;\n                dirtyState[i] = oldCodeCell.isDirty;\n            }\n        }\n        this.model.sharedModel.moveCells(from, boundedTo, n);\n        for (let i = 0; i < n; i++) {\n            const newCell = this.widgets[to + i];\n            const view = viewModel[i];\n            for (const state in view) {\n                // @ts-expect-error Cell has no index signature\n                newCell[state] = view[state];\n            }\n            if (from > to) {\n                if (this.widgets[to + i].model.type === 'code') {\n                    this.widgets[to + i].model.isDirty = dirtyState[i];\n                }\n            }\n            else {\n                if (this.widgets[to + i - n + 1].model.type === 'code') {\n                    this.widgets[to + i - n + 1].model.isDirty =\n                        dirtyState[i];\n                }\n            }\n        }\n    }\n    /**\n     * Force rendering the cell outputs of a given cell if it is still a placeholder.\n     *\n     * #### Notes\n     * The goal of this method is to allow search on cell outputs (that is based\n     * on DOM tree introspection).\n     *\n     * @param index The cell index\n     */\n    renderCellOutputs(index) {\n        const cell = this.viewModel.widgetRenderer(index);\n        if (cell instanceof CodeCell && cell.isPlaceholder()) {\n            cell.dataset.windowedListIndex = `${index}`;\n            this.layout.insertWidget(index, cell);\n            if (this.notebookConfig.windowingMode === 'full') {\n                // We need to delay slightly the removal to let codemirror properly initialize\n                requestAnimationFrame(() => {\n                    this.layout.removeWidget(cell);\n                });\n            }\n        }\n    }\n    /**\n     * Adds a message to the notebook as a header.\n     */\n    addHeader() {\n        const trans = this.translator.load('jupyterlab');\n        const info = new Widget();\n        info.node.textContent = trans.__('The notebook is empty. Click the + button on the toolbar to add a new cell.');\n        this.layout.header = info;\n    }\n    /**\n     * Removes the header.\n     */\n    removeHeader() {\n        var _a;\n        (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.layout.header = null;\n    }\n    /**\n     * Handle a new model.\n     *\n     * #### Notes\n     * This method is called after the model change has been handled\n     * internally and before the `modelChanged` signal is emitted.\n     * The default implementation is a no-op.\n     */\n    onModelChanged(oldValue, newValue) {\n        // No-op.\n    }\n    /**\n     * Handle changes to the notebook model content.\n     *\n     * #### Notes\n     * The default implementation emits the `modelContentChanged` signal.\n     */\n    onModelContentChanged(model, args) {\n        this._modelContentChanged.emit(void 0);\n    }\n    /**\n     * Handle changes to the notebook model metadata.\n     *\n     * #### Notes\n     * The default implementation updates the mimetypes of the code cells\n     * when the `language_info` metadata changes.\n     */\n    onMetadataChanged(sender, args) {\n        switch (args.key) {\n            case 'language_info':\n                this._updateMimetype();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     *\n     * The default implementation is a no-op\n     */\n    onCellInserted(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being removed.\n     *\n     * The default implementation is a no-op\n     */\n    onCellRemoved(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onUpdateRequest(msg) {\n        if (this.notebookConfig.windowingMode === 'defer') {\n            void this._runOnIdleTime();\n        }\n        else {\n            super.onUpdateRequest(msg);\n        }\n    }\n    /**\n     * Handle a new model on the widget.\n     */\n    _onModelChanged(oldValue, newValue) {\n        var _a;\n        if (oldValue) {\n            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);\n            oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);\n            oldValue.cells.changed.disconnect(this._onCellsChanged, this);\n            while (this.cellsArray.length) {\n                this._removeCell(0);\n            }\n        }\n        if (!newValue) {\n            this._mimetype = IEditorMimeTypeService.defaultMimeType;\n            return;\n        }\n        this._updateMimetype();\n        const cells = newValue.cells;\n        const collab = (_a = newValue.collaborative) !== null && _a !== void 0 ? _a : false;\n        if (!collab && !cells.length) {\n            newValue.sharedModel.insertCell(0, {\n                cell_type: this.notebookConfig.defaultCell,\n                metadata: this.notebookConfig.defaultCell === 'code'\n                    ? {\n                        // This is an empty cell created in empty notebook, thus is trusted\n                        trusted: true\n                    }\n                    : {}\n            });\n        }\n        let index = -1;\n        for (const cell of cells) {\n            this._insertCell(++index, cell);\n        }\n        newValue.cells.changed.connect(this._onCellsChanged, this);\n        newValue.metadataChanged.connect(this.onMetadataChanged, this);\n        newValue.contentChanged.connect(this.onModelContentChanged, this);\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        this.removeHeader();\n        switch (args.type) {\n            case 'add': {\n                let index = 0;\n                index = args.newIndex;\n                for (const value of args.newValues) {\n                    this._insertCell(index++, value);\n                }\n                this._updateDataWindowedListIndex(args.newIndex, this.model.cells.length, args.newValues.length);\n                break;\n            }\n            case 'remove':\n                for (let length = args.oldValues.length; length > 0; length--) {\n                    this._removeCell(args.oldIndex);\n                }\n                this._updateDataWindowedListIndex(args.oldIndex, this.model.cells.length + args.oldValues.length, -1 * args.oldValues.length);\n                // Add default cell if there are no cells remaining.\n                if (!sender.length) {\n                    const model = this.model;\n                    // Add the cell in a new context to avoid triggering another\n                    // cell changed event during the handling of this signal.\n                    requestAnimationFrame(() => {\n                        if (model && !model.isDisposed && !model.sharedModel.cells.length) {\n                            model.sharedModel.insertCell(0, {\n                                cell_type: this.notebookConfig.defaultCell,\n                                metadata: this.notebookConfig.defaultCell === 'code'\n                                    ? {\n                                        // This is an empty cell created in empty notebook, thus is trusted\n                                        trusted: true\n                                    }\n                                    : {}\n                            });\n                        }\n                    });\n                }\n                break;\n            default:\n                return;\n        }\n        if (!this.model.sharedModel.cells.length) {\n            this.addHeader();\n        }\n        this.update();\n    }\n    /**\n     * Create a cell widget and insert into the notebook.\n     */\n    _insertCell(index, cell) {\n        let widget;\n        switch (cell.type) {\n            case 'code':\n                widget = this._createCodeCell(cell);\n                widget.model.mimeType = this._mimetype;\n                break;\n            case 'markdown':\n                widget = this._createMarkdownCell(cell);\n                if (cell.sharedModel.getSource() === '') {\n                    widget.rendered = false;\n                }\n                break;\n            default:\n                widget = this._createRawCell(cell);\n        }\n        widget.inViewportChanged.connect(this._onCellInViewportChanged, this);\n        widget.addClass(NB_CELL_CLASS);\n        ArrayExt.insert(this.cellsArray, index, widget);\n        this.onCellInserted(index, widget);\n        this._scheduleCellRenderOnIdle();\n    }\n    /**\n     * Create a code cell widget from a code cell model.\n     */\n    _createCodeCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.code;\n        const options = {\n            contentFactory,\n            editorConfig,\n            inputHistoryScope: this.notebookConfig.inputHistoryScope,\n            maxNumberOutputs: this.notebookConfig.maxNumberOutputs,\n            model,\n            placeholder: this._notebookConfig.windowingMode !== 'none',\n            rendermime,\n            translator: this.translator\n        };\n        const cell = this.contentFactory.createCodeCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        cell.syncScrolled = true;\n        cell.outputArea.inputRequested.connect((_, stdin) => {\n            this._onInputRequested(cell).catch(reason => {\n                console.error('Failed to scroll to cell requesting input.', reason);\n            });\n            stdin.disposed.connect(() => {\n                // The input field is removed from the DOM after the user presses Enter.\n                // This causes focus to be lost if we don't explicitly re-focus\n                // somewhere else.\n                cell.node.focus();\n            });\n        });\n        return cell;\n    }\n    /**\n     * Create a markdown cell widget from a markdown cell model.\n     */\n    _createMarkdownCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.markdown;\n        const options = {\n            contentFactory,\n            editorConfig,\n            model,\n            placeholder: this._notebookConfig.windowingMode !== 'none',\n            rendermime,\n            showEditorForReadOnlyMarkdown: this._notebookConfig.showEditorForReadOnlyMarkdown\n        };\n        const cell = this.contentFactory.createMarkdownCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        // Connect collapsed signal for each markdown cell widget\n        cell.headingCollapsedChanged.connect(this._onCellCollapsed, this);\n        return cell;\n    }\n    /**\n     * Create a raw cell widget from a raw cell model.\n     */\n    _createRawCell(model) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            placeholder: this._notebookConfig.windowingMode !== 'none'\n        };\n        const cell = this.contentFactory.createRawCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Remove a cell widget.\n     */\n    _removeCell(index) {\n        const widget = this.cellsArray[index];\n        widget.parent = null;\n        ArrayExt.removeAt(this.cellsArray, index);\n        this.onCellRemoved(index, widget);\n        widget.dispose();\n    }\n    /**\n     * Update the mimetype of the notebook.\n     */\n    _updateMimetype() {\n        var _a;\n        const info = (_a = this._notebookModel) === null || _a === void 0 ? void 0 : _a.getMetadata('language_info');\n        if (!info) {\n            return;\n        }\n        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);\n        for (const widget of this.widgets) {\n            if (widget.model.type === 'code') {\n                widget.model.mimeType = this._mimetype;\n            }\n        }\n    }\n    /**\n     * Callback when a cell collapsed status changes.\n     *\n     * @param cell Cell changed\n     * @param collapsed New collapsed status\n     */\n    _onCellCollapsed(cell, collapsed) {\n        NotebookActions.setHeadingCollapse(cell, collapsed, this);\n        this._cellCollapsed.emit(cell);\n    }\n    /**\n     * Callback when a cell viewport status changes.\n     *\n     * @param cell Cell changed\n     */\n    _onCellInViewportChanged(cell) {\n        this._cellInViewportChanged.emit(cell);\n    }\n    /**\n     * Ensure to load in the DOM a cell requesting an user input\n     *\n     * @param cell Cell requesting an input\n     */\n    async _onInputRequested(cell) {\n        if (!cell.inViewport) {\n            const cellIndex = this.widgets.findIndex(c => c === cell);\n            if (cellIndex >= 0) {\n                await this.scrollToItem(cellIndex);\n                const inputEl = cell.node.querySelector('.jp-Stdin');\n                if (inputEl) {\n                    ElementExt.scrollIntoViewIfNeeded(this.node, inputEl);\n                    inputEl.focus();\n                }\n            }\n        }\n    }\n    _scheduleCellRenderOnIdle() {\n        if (this.notebookConfig.windowingMode !== 'none' && !this.isDisposed) {\n            if (!this._idleCallBack) {\n                this._idleCallBack = requestIdleCallback((deadline) => {\n                    this._idleCallBack = null;\n                    // In case of timeout, render for some time even if it means freezing the UI\n                    // This avoids the cells to never be loaded.\n                    void this._runOnIdleTime(deadline.didTimeout\n                        ? MAXIMUM_TIME_REMAINING\n                        : deadline.timeRemaining());\n                }, {\n                    timeout: 3000\n                });\n            }\n        }\n    }\n    _updateDataWindowedListIndex(start, end, delta) {\n        for (let cellIdx = 0; cellIdx < this.viewportNode.childElementCount; cellIdx++) {\n            const cell = this.viewportNode.children[cellIdx];\n            const globalIndex = parseInt(cell.dataset.windowedListIndex, 10);\n            if (globalIndex >= start && globalIndex < end) {\n                cell.dataset.windowedListIndex = `${globalIndex + delta}`;\n            }\n        }\n    }\n    /**\n     * Update editor settings for notebook cells.\n     */\n    _updateEditorConfig() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            let config = {};\n            switch (cell.model.type) {\n                case 'code':\n                    config = this._editorConfig.code;\n                    break;\n                case 'markdown':\n                    config = this._editorConfig.markdown;\n                    break;\n                default:\n                    config = this._editorConfig.raw;\n                    break;\n            }\n            cell.updateEditorConfig({ ...config });\n        }\n    }\n    async _runOnIdleTime(remainingTime = MAXIMUM_TIME_REMAINING) {\n        const startTime = Date.now();\n        let cellIdx = 0;\n        while (Date.now() - startTime < remainingTime &&\n            cellIdx < this.cellsArray.length) {\n            const cell = this.cellsArray[cellIdx];\n            if (cell.isPlaceholder()) {\n                if (['defer', 'full'].includes(this.notebookConfig.windowingMode)) {\n                    await this._updateForDeferMode(cell, cellIdx);\n                    if (this.notebookConfig.windowingMode === 'full') {\n                        // We need to delay slightly the removal to let codemirror properly initialize\n                        requestAnimationFrame(() => {\n                            this.viewModel.setEstimatedWidgetSize(cell.model.id, cell.node.getBoundingClientRect().height);\n                            this.layout.removeWidget(cell);\n                        });\n                    }\n                }\n            }\n            cellIdx++;\n        }\n        // If the notebook is not fully rendered\n        if (cellIdx < this.cellsArray.length) {\n            // If we are deferring the cell rendering and the rendered cells do\n            // not fill the viewport yet\n            if (this.notebookConfig.windowingMode === 'defer' &&\n                this.viewportNode.clientHeight < this.node.clientHeight) {\n                // Spend more time rendering cells to fill the viewport\n                await this._runOnIdleTime();\n            }\n            else {\n                this._scheduleCellRenderOnIdle();\n            }\n        }\n        else {\n            if (this._idleCallBack) {\n                window.cancelIdleCallback(this._idleCallBack);\n                this._idleCallBack = null;\n            }\n        }\n    }\n    async _updateForDeferMode(cell, cellIdx) {\n        cell.dataset.windowedListIndex = `${cellIdx}`;\n        this.layout.insertWidget(cellIdx, cell);\n        await cell.ready;\n    }\n    /**\n     * Apply updated notebook settings.\n     */\n    _updateNotebookConfig() {\n        // Apply scrollPastEnd setting.\n        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);\n        // Control visibility of heading collapser UI\n        this.toggleClass(HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS, this._notebookConfig.showHiddenCellsButton);\n        // Control editor visibility for read-only Markdown cells\n        const showEditorForReadOnlyMarkdown = this._notebookConfig.showEditorForReadOnlyMarkdown;\n        if (showEditorForReadOnlyMarkdown !== undefined) {\n            for (const cell of this.cellsArray) {\n                if (cell.model.type === 'markdown') {\n                    cell.showEditorForReadOnly =\n                        showEditorForReadOnlyMarkdown;\n                }\n            }\n        }\n        this.viewModel.windowingActive =\n            this._notebookConfig.windowingMode === 'full';\n    }\n}\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\n(function (StaticNotebook) {\n    /**\n     * Default configuration options for cell editors.\n     */\n    StaticNotebook.defaultEditorConfig = {\n        code: {\n            lineNumbers: false,\n            lineWrap: false,\n            matchBrackets: true,\n            tabFocusable: false\n        },\n        markdown: {\n            lineNumbers: false,\n            lineWrap: true,\n            matchBrackets: false,\n            tabFocusable: false\n        },\n        raw: {\n            lineNumbers: false,\n            lineWrap: true,\n            matchBrackets: false,\n            tabFocusable: false\n        }\n    };\n    /**\n     * Default configuration options for notebooks.\n     */\n    StaticNotebook.defaultNotebookConfig = {\n        enableKernelInitNotification: false,\n        showHiddenCellsButton: true,\n        scrollPastEnd: true,\n        defaultCell: 'code',\n        recordTiming: false,\n        inputHistoryScope: 'global',\n        maxNumberOutputs: 50,\n        showEditorForReadOnlyMarkdown: true,\n        disableDocumentWideUndoRedo: true,\n        renderingLayout: 'default',\n        sideBySideLeftMarginOverride: '10px',\n        sideBySideRightMarginOverride: '10px',\n        sideBySideOutputRatio: 1,\n        overscanCount: 1,\n        windowingMode: 'full',\n        accessKernelHistory: false\n    };\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options) {\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options) {\n            return new MarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options) {\n            return new RawCell(options).initializeState();\n        }\n    }\n    StaticNotebook.ContentFactory = ContentFactory;\n})(StaticNotebook || (StaticNotebook = {}));\n/**\n * A virtual scrollbar item representing a notebook cell.\n */\nclass ScrollbarItem {\n    /**\n     * Construct a scrollbar item.\n     */\n    constructor(options) {\n        /**\n         * Render the scrollbar item as an HTML element.\n         */\n        this.render = (props) => {\n            if (!this._element) {\n                this._element = this._createElement();\n                this._notebook.activeCellChanged.connect(this._updateActive);\n                this._notebook.selectionChanged.connect(this._updateSelection);\n                if (this._model.type === 'code') {\n                    const model = this._model;\n                    model.outputs.changed.connect(this._updatePrompt);\n                    model.stateChanged.connect(this._updateState);\n                }\n            }\n            // Add cell type (code/markdown/raw)\n            if (this._model.type != this._element.dataset.type) {\n                this._element.dataset.type = this._model.type;\n            }\n            const source = this._model.sharedModel.source;\n            const trimmedSource = source.length > 10000 ? source.substring(0, 10000) : source;\n            if (trimmedSource !== this._source.textContent) {\n                this._source.textContent = trimmedSource;\n            }\n            this._updateActive();\n            this._updateSelection();\n            this._updatePrompt();\n            this._updateDirty();\n            return this._element;\n        };\n        /**\n         * Dispose of the resources held by the item.\n         */\n        this.dispose = () => {\n            this._isDisposed = true;\n            this._notebook.activeCellChanged.disconnect(this._updateActive);\n            this._notebook.selectionChanged.disconnect(this._updateSelection);\n            if (this._model.type === 'code') {\n                const model = this._model;\n                if (model.outputs) {\n                    model.outputs.changed.disconnect(this._updatePrompt);\n                    model.stateChanged.disconnect(this._updateState);\n                }\n            }\n        };\n        this._updateState = (_, change) => {\n            switch (change.name) {\n                case 'executionCount':\n                case 'executionState':\n                    this._updatePrompt();\n                    break;\n                case 'isDirty': {\n                    this._updateDirty();\n                    break;\n                }\n            }\n        };\n        this._updatePrompt = () => {\n            if (this._model.type !== 'code') {\n                return;\n            }\n            const model = this._model;\n            let hasError = false;\n            for (let i = 0; i < model.outputs.length; i++) {\n                const output = model.outputs.get(i);\n                if (output.type === 'error') {\n                    hasError = true;\n                    break;\n                }\n            }\n            let content;\n            let state = '';\n            if (hasError) {\n                content = '[!]';\n                state = 'error';\n            }\n            else if (model.executionState == 'running') {\n                content = '[*]';\n            }\n            else if (model.executionCount) {\n                content = `[${model.executionCount}]`;\n            }\n            else {\n                content = '[ ]';\n            }\n            if (this._executionIndicator.textContent !== content) {\n                this._executionIndicator.textContent = content;\n            }\n            if (this._element.dataset.output !== state) {\n                this._element.dataset.output = state;\n            }\n        };\n        this._updateActive = () => {\n            var _a;\n            if (!this._element) {\n                this._element = this._createElement();\n            }\n            const li = this._element;\n            const wasActive = li.classList.contains(ACTIVE_CLASS);\n            if (((_a = this._notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model) === this._model) {\n                if (!wasActive) {\n                    li.classList.add(ACTIVE_CLASS);\n                }\n            }\n            else if (wasActive) {\n                li.classList.remove(ACTIVE_CLASS);\n                // Needed due to order in which selection and active changed signals fire\n                li.classList.remove(SELECTED_CLASS);\n            }\n        };\n        this._updateSelection = () => {\n            if (!this._element) {\n                this._element = this._createElement();\n            }\n            const li = this._element;\n            const wasSelected = li.classList.contains(SELECTED_CLASS);\n            if (this._notebook.selectedCells.some(cell => this._model === cell.model)) {\n                if (!wasSelected) {\n                    li.classList.add(SELECTED_CLASS);\n                }\n            }\n            else if (wasSelected) {\n                li.classList.remove(SELECTED_CLASS);\n            }\n        };\n        this._isDisposed = false;\n        this._element = null;\n        // Note: there should be no DOM operations in the constructor\n        this._model = options.model;\n        this._notebook = options.notebook;\n    }\n    /**\n     * Unique item key used for caching.\n     */\n    get key() {\n        return this._model.id;\n    }\n    /**\n     * Test whether the item has been disposed.\n     */\n    get isDisposed() {\n        // Ensure the state is up-to-date in case if the model was disposed\n        // (the model can be disposed when cells are moved/recreated).\n        if (!this._isDisposed && this._model.isDisposed) {\n            this.dispose();\n        }\n        return this._isDisposed;\n    }\n    _updateDirty() {\n        if (this._model.type !== 'code' || !this._element) {\n            return;\n        }\n        const model = this._model;\n        const wasDirty = this._element.classList.contains(DIRTY_CLASS);\n        if (wasDirty !== model.isDirty) {\n            if (model.isDirty) {\n                this._element.classList.add(DIRTY_CLASS);\n            }\n            else {\n                this._element.classList.remove(DIRTY_CLASS);\n            }\n        }\n    }\n    _createElement() {\n        const li = document.createElement('li');\n        const executionIndicator = (this._executionIndicator =\n            document.createElement('div'));\n        executionIndicator.className = 'jp-scrollbarItem-executionIndicator';\n        const source = (this._source = document.createElement('div'));\n        source.className = 'jp-scrollbarItem-source';\n        li.append(executionIndicator);\n        li.append(source);\n        return li;\n    }\n}\n/**\n * A notebook widget that supports interactivity.\n */\nexport class Notebook extends StaticNotebook {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super({\n            renderer: {\n                createOuter() {\n                    return document.createElement('div');\n                },\n                createViewport() {\n                    const el = document.createElement('div');\n                    el.setAttribute('role', 'feed');\n                    el.setAttribute('aria-label', 'Cells');\n                    return el;\n                },\n                createScrollbar() {\n                    return document.createElement('ol');\n                },\n                createScrollbarViewportIndicator() {\n                    return document.createElement('div');\n                },\n                createScrollbarItem(notebook, _index, model) {\n                    return new ScrollbarItem({\n                        notebook,\n                        model\n                    });\n                }\n            },\n            ...options\n        });\n        this._activeCellIndex = -1;\n        this._activeCell = null;\n        this._mode = 'command';\n        this._drag = null;\n        this._dragData = null;\n        this._selectData = null;\n        this._mouseMode = null;\n        this._activeCellChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n        this._checkCacheOnNextResize = false;\n        this._lastClipboardInteraction = null;\n        this._selectedCells = [];\n        // Allow the node to scroll while dragging items.\n        this.outerNode.setAttribute('data-lm-dragscroll', 'true');\n        this.activeCellChanged.connect(this._updateSelectedCells, this);\n        this.jumped.connect((_, index) => (this.activeCellIndex = index));\n        this.selectionChanged.connect(this._updateSelectedCells, this);\n        this.addFooter();\n    }\n    /**\n     * List of selected and active cells\n     */\n    get selectedCells() {\n        return this._selectedCells;\n    }\n    /**\n     * Adds a footer to the notebook.\n     */\n    addFooter() {\n        const info = new NotebookFooter(this);\n        this.layout.footer = info;\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        var _a, _b;\n        const activeCellId = (_a = this.activeCell) === null || _a === void 0 ? void 0 : _a.model.id;\n        super._onCellsChanged(sender, args);\n        if (activeCellId) {\n            const newActiveCellIndex = (_b = this.model) === null || _b === void 0 ? void 0 : _b.sharedModel.cells.findIndex(cell => cell.getId() === activeCellId);\n            if (newActiveCellIndex != null) {\n                this.activeCellIndex = newActiveCellIndex;\n            }\n        }\n    }\n    /**\n     * A signal emitted when the active cell changes.\n     *\n     * #### Notes\n     * This can be due to the active index changing or the\n     * cell at the active index changing.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the state of the notebook changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the selection state of the notebook changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * The interactivity mode of the notebook.\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(newValue) {\n        this.setMode(newValue);\n    }\n    /**\n     * Set the notebook mode.\n     *\n     * @param newValue Notebook mode\n     * @param options Control mode side-effect\n     * @param options.focus Whether to ensure focus (default) or not when setting the mode.\n     */\n    setMode(newValue, options = {}) {\n        var _a;\n        const setFocus = (_a = options.focus) !== null && _a !== void 0 ? _a : true;\n        const activeCell = this.activeCell;\n        if (!activeCell) {\n            newValue = 'command';\n        }\n        if (newValue === this._mode) {\n            if (setFocus) {\n                this._ensureFocus();\n            }\n            return;\n        }\n        // Post an update request.\n        this.update();\n        const oldValue = this._mode;\n        this._mode = newValue;\n        if (newValue === 'edit') {\n            // Edit mode deselects all cells.\n            for (const widget of this.widgets) {\n                this.deselect(widget);\n            }\n            // Edit mode unrenders an active markdown widget.\n            if (activeCell instanceof MarkdownCell) {\n                activeCell.rendered = false;\n            }\n            activeCell.inputHidden = false;\n        }\n        else {\n            if (setFocus) {\n                void NotebookActions.focusActiveCell(this, {\n                    // Do not await the active cell because that creates a bug. If the user\n                    // is editing a code cell and presses Accel Shift C to open the command\n                    // palette, then the command palette opens before\n                    // activeCell.node.focus() is called, which closes the command palette.\n                    // To the end user, it looks as if all the keyboard shortcut did was\n                    // move focus from the cell editor to the cell as a whole.\n                    waitUntilReady: false,\n                    preventScroll: true\n                });\n            }\n        }\n        this._stateChanged.emit({ name: 'mode', oldValue, newValue });\n        if (setFocus) {\n            this._ensureFocus();\n        }\n    }\n    /**\n     * The active cell index of the notebook.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the notebook cells.\n     */\n    get activeCellIndex() {\n        if (!this.model) {\n            return -1;\n        }\n        return this.widgets.length ? this._activeCellIndex : -1;\n    }\n    set activeCellIndex(newValue) {\n        var _a;\n        const oldValue = this._activeCellIndex;\n        if (!this.model || !this.widgets.length) {\n            newValue = -1;\n        }\n        else {\n            newValue = Math.max(newValue, 0);\n            newValue = Math.min(newValue, this.widgets.length - 1);\n        }\n        this._activeCellIndex = newValue;\n        const cell = (_a = this.widgets[newValue]) !== null && _a !== void 0 ? _a : null;\n        this.layout.activeCell = cell;\n        const cellChanged = cell !== this._activeCell;\n        if (cellChanged) {\n            // Post an update request.\n            this.update();\n            this._activeCell = cell;\n        }\n        if (cellChanged || newValue != oldValue) {\n            this._activeCellChanged.emit(cell);\n        }\n        if (this.mode === 'edit' && cell instanceof MarkdownCell) {\n            cell.rendered = false;\n        }\n        this._ensureFocus();\n        if (newValue === oldValue) {\n            return;\n        }\n        this._trimSelections();\n        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });\n    }\n    /**\n     * Get the active cell widget.\n     *\n     * #### Notes\n     * This is a cell or `null` if there is no active cell.\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    get lastClipboardInteraction() {\n        return this._lastClipboardInteraction;\n    }\n    set lastClipboardInteraction(newValue) {\n        this._lastClipboardInteraction = newValue;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Move cells preserving widget view state.\n     *\n     * #### Notes\n     * This is required because at the model level a move is a deletion\n     * followed by an insertion. Hence the view state is not preserved.\n     *\n     * @param from The index of the cell to move\n     * @param to The new index of the cell\n     * @param n Number of cells to move\n     */\n    moveCell(from, to, n = 1) {\n        // Save active cell id to be restored\n        const newActiveCellIndex = from <= this.activeCellIndex && this.activeCellIndex < from + n\n            ? this.activeCellIndex + to - from - (from > to ? 0 : n - 1)\n            : -1;\n        const isSelected = this.widgets\n            .slice(from, from + n)\n            .map(w => this.isSelected(w));\n        super.moveCell(from, to, n);\n        if (newActiveCellIndex >= 0) {\n            this.activeCellIndex = newActiveCellIndex;\n        }\n        if (from > to) {\n            isSelected.forEach((selected, idx) => {\n                if (selected) {\n                    this.select(this.widgets[to + idx]);\n                }\n            });\n        }\n        else {\n            isSelected.forEach((selected, idx) => {\n                if (selected) {\n                    this.select(this.widgets[to - n + 1 + idx]);\n                }\n            });\n        }\n    }\n    /**\n     * Select a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    select(widget) {\n        if (Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, true);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Deselect a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    deselect(widget) {\n        if (!Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, false);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Whether a cell is selected.\n     */\n    isSelected(widget) {\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Whether a cell is selected or is the active cell.\n     */\n    isSelectedOrActive(widget) {\n        if (widget === this._activeCell) {\n            return true;\n        }\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Deselect all of the cells.\n     */\n    deselectAll() {\n        let changed = false;\n        for (const widget of this.widgets) {\n            if (Private.selectedProperty.get(widget)) {\n                changed = true;\n            }\n            Private.selectedProperty.set(widget, false);\n        }\n        if (changed) {\n            this._selectionChanged.emit(void 0);\n        }\n        // Make sure we have a valid active cell.\n        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line\n        this.update();\n    }\n    /**\n     * Move the head of an existing contiguous selection to extend the selection.\n     *\n     * @param index - The new head of the existing selection.\n     *\n     * #### Notes\n     * If there is no existing selection, the active cell is considered an\n     * existing one-cell selection.\n     *\n     * If the new selection is a single cell, that cell becomes the active cell\n     * and all cells are deselected.\n     *\n     * There is no change if there are no cells (i.e., activeCellIndex is -1).\n     */\n    extendContiguousSelectionTo(index) {\n        let { head, anchor } = this.getContiguousSelection();\n        let i;\n        // Handle the case of no current selection.\n        if (anchor === null || head === null) {\n            if (index === this.activeCellIndex) {\n                // Already collapsed selection, nothing more to do.\n                return;\n            }\n            // We will start a new selection below.\n            head = this.activeCellIndex;\n            anchor = this.activeCellIndex;\n        }\n        // Move the active cell. We do this before the collapsing shortcut below.\n        this.activeCellIndex = index;\n        // Make sure the index is valid, according to the rules for setting and clipping the\n        // active cell index. This may change the index.\n        index = this.activeCellIndex;\n        // Collapse the selection if it is only the active cell.\n        if (index === anchor) {\n            this.deselectAll();\n            return;\n        }\n        let selectionChanged = false;\n        if (head < index) {\n            if (head < anchor) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between head and index except anchor.\n            for (i = head + 1; i < index; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        else if (index < head) {\n            if (anchor < head) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between index and head except anchor.\n            for (i = index + 1; i < head; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        // Anchor and index should *always* be selected.\n        if (!Private.selectedProperty.get(this.widgets[anchor])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[anchor], true);\n        if (!Private.selectedProperty.get(this.widgets[index])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[index], true);\n        if (selectionChanged) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Get the head and anchor of a contiguous cell selection.\n     *\n     * The head of a contiguous selection is always the active cell.\n     *\n     * If there are no cells selected, `{head: null, anchor: null}` is returned.\n     *\n     * Throws an error if the currently selected cells do not form a contiguous\n     * selection.\n     */\n    getContiguousSelection() {\n        const cells = this.widgets;\n        const first = ArrayExt.findFirstIndex(cells, c => this.isSelected(c));\n        // Return early if no cells are selected.\n        if (first === -1) {\n            return { head: null, anchor: null };\n        }\n        const last = ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);\n        // Check that the selection is contiguous.\n        for (let i = first; i <= last; i++) {\n            if (!this.isSelected(cells[i])) {\n                throw new Error('Selection not contiguous');\n            }\n        }\n        // Check that the active cell is one of the endpoints of the selection.\n        const activeIndex = this.activeCellIndex;\n        if (first !== activeIndex && last !== activeIndex) {\n            throw new Error('Active cell not at endpoint of selection');\n        }\n        // Determine the head and anchor of the selection.\n        if (first === activeIndex) {\n            return { head: first, anchor: last };\n        }\n        else {\n            return { head: last, anchor: first };\n        }\n    }\n    /**\n     * Scroll so that the given cell is in view. Selects and activates cell.\n     *\n     * @param cell - A cell in the notebook widget.\n     * @param align - Type of alignment.\n     *\n     */\n    async scrollToCell(cell, align = 'auto') {\n        try {\n            await this.scrollToItem(this.widgets.findIndex(c => c === cell), align);\n        }\n        catch (r) {\n            //no-op\n        }\n        // change selection and active cell:\n        this.deselectAll();\n        this.select(cell);\n        cell.activate();\n    }\n    _parseFragment(fragment) {\n        const cleanedFragment = fragment.slice(1);\n        if (!cleanedFragment) {\n            // Bail early\n            return;\n        }\n        const parts = cleanedFragment.split('=');\n        if (parts.length === 1) {\n            // Default to heading if no prefix is given.\n            return {\n                kind: 'heading',\n                value: cleanedFragment\n            };\n        }\n        return {\n            kind: parts[0],\n            value: parts.slice(1).join('=')\n        };\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    async setFragment(fragment) {\n        const parsedFragment = this._parseFragment(fragment);\n        if (!parsedFragment) {\n            // Bail early\n            return;\n        }\n        let result;\n        switch (parsedFragment.kind) {\n            case 'heading':\n                result = await this._findHeading(parsedFragment.value);\n                break;\n            case 'cell-id':\n                result = this._findCellById(parsedFragment.value);\n                break;\n            default:\n                console.warn(`Unknown target type for URI fragment ${fragment}, interpreting as a heading`);\n                result = await this._findHeading(parsedFragment.kind + '=' + parsedFragment.value);\n                break;\n        }\n        if (result == null) {\n            return;\n        }\n        let { cell, element } = result;\n        if (!cell.inViewport) {\n            await this.scrollToCell(cell, 'center');\n        }\n        if (element == null) {\n            element = cell.node;\n        }\n        const widgetBox = this.node.getBoundingClientRect();\n        const elementBox = element.getBoundingClientRect();\n        if (elementBox.top > widgetBox.bottom ||\n            elementBox.bottom < widgetBox.top) {\n            element.scrollIntoView({ block: 'center' });\n        }\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'contextmenu':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtContextMenuCapture(event);\n                }\n                break;\n            case 'mousedown':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtMouseDownCapture(event);\n                }\n                else {\n                    // Skip processing the event when it resulted from a toolbar button click\n                    if (!event.defaultPrevented) {\n                        this._evtMouseDown(event);\n                    }\n                }\n                break;\n            case 'mouseup':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMouseup(event);\n                }\n                break;\n            case 'mousemove':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMousemove(event);\n                }\n                break;\n            case 'keydown':\n                // This works because CodeMirror does not stop the event propagation\n                this._ensureFocus(true);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'focusin':\n                this._evtFocusIn(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                super.handleEvent(event);\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('contextmenu', this, true);\n        node.addEventListener('mousedown', this, true);\n        node.addEventListener('mousedown', this);\n        node.addEventListener('keydown', this);\n        node.addEventListener('dblclick', this);\n        node.addEventListener('focusin', this);\n        node.addEventListener('focusout', this);\n        // Capture drag events for the notebook widget\n        // in order to preempt the drag/drop handlers in the\n        // code editor widgets, which can take text data.\n        node.addEventListener('lm-dragenter', this, true);\n        node.addEventListener('lm-dragleave', this, true);\n        node.addEventListener('lm-dragover', this, true);\n        node.addEventListener('lm-drop', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('contextmenu', this, true);\n        node.removeEventListener('mousedown', this, true);\n        node.removeEventListener('mousedown', this);\n        node.removeEventListener('keydown', this);\n        node.removeEventListener('dblclick', this);\n        node.removeEventListener('focusin', this);\n        node.removeEventListener('focusout', this);\n        node.removeEventListener('lm-dragenter', this, true);\n        node.removeEventListener('lm-dragleave', this, true);\n        node.removeEventListener('lm-dragover', this, true);\n        node.removeEventListener('lm-drop', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        super.onBeforeAttach(msg);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        super.onAfterShow(msg);\n        this._checkCacheOnNextResize = true;\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        var _a;\n        // TODO\n        if (!this._checkCacheOnNextResize) {\n            return super.onResize(msg);\n        }\n        super.onResize(msg);\n        this._checkCacheOnNextResize = false;\n        const cache = this._cellLayoutStateCache;\n        const width = parseInt(this.node.style.width, 10);\n        if (cache) {\n            if (width === cache.width) {\n                // Cache identical, do nothing\n                return;\n            }\n        }\n        // Update cache\n        this._cellLayoutStateCache = { width };\n        // Fallback:\n        for (const w of this.widgets) {\n            if (w instanceof Cell && w.inViewport) {\n                (_a = w.editorWidget) === null || _a === void 0 ? void 0 : _a.update();\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'before-hide'` message.\n     */\n    onBeforeHide(msg) {\n        super.onBeforeHide(msg);\n        // Update cache\n        const width = parseInt(this.node.style.width, 10);\n        this._cellLayoutStateCache = { width };\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        super.onActivateRequest(msg);\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle `update-request` messages sent to the widget.\n     */\n    onUpdateRequest(msg) {\n        super.onUpdateRequest(msg);\n        const activeCell = this.activeCell;\n        // Set the appropriate classes on the cells.\n        if (this.mode === 'edit') {\n            this.addClass(EDIT_CLASS);\n            this.removeClass(COMMAND_CLASS);\n        }\n        else {\n            this.addClass(COMMAND_CLASS);\n            this.removeClass(EDIT_CLASS);\n        }\n        let count = 0;\n        for (const widget of this.widgets) {\n            // Set tabIndex to -1 to allow calling .focus() on cell without allowing\n            // focus via tab key. This allows focus (document.activeElement) to move\n            // up and down the document, cell by cell, when the user presses J/K or\n            // ArrowDown/ArrowUp, but (unlike tabIndex = 0) does not add the notebook\n            // cells (which could be numerous) to the set of nodes that the user would\n            // have to visit when pressing the tab key to move about the UI.\n            widget.node.tabIndex = -1;\n            widget.removeClass(ACTIVE_CLASS);\n            widget.removeClass(OTHER_SELECTED_CLASS);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(SELECTED_CLASS);\n                count++;\n            }\n            else {\n                widget.removeClass(SELECTED_CLASS);\n            }\n        }\n        if (activeCell) {\n            activeCell.addClass(ACTIVE_CLASS);\n            activeCell.addClass(SELECTED_CLASS);\n            // Set tab index to 0 on the active cell so that if the user tabs away from\n            // the notebook then tabs back, they will return to the cell where they\n            // left off.\n            activeCell.node.tabIndex = 0;\n            if (count > 1) {\n                activeCell.addClass(OTHER_SELECTED_CLASS);\n            }\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     */\n    onCellInserted(index, cell) {\n        void cell.ready.then(() => {\n            if (!cell.isDisposed) {\n                cell.editor.edgeRequested.connect(this._onEdgeRequest, this);\n            }\n        });\n        cell.scrollRequested.connect((_emitter, scrollRequest) => {\n            if (cell !== this.activeCell) {\n                // Do nothing for cells other than the active cell\n                // to avoid scroll requests from editor extensions\n                // stealing user focus (this may be revisited).\n                return;\n            }\n            if (!scrollRequest.defaultPrevented) {\n                // Nothing to do if scroll request was already handled.\n                return;\n            }\n            // Node which allows to scroll the notebook\n            const scroller = this.outerNode;\n            if (cell.inViewport) {\n                // If cell got scrolled to the viewport in the meantime,\n                // proceed with scrolling within the cell.\n                return scrollRequest.scrollWithinCell({ scroller });\n            }\n            // If cell is not in the viewport and needs scrolling,\n            // first scroll to the cell and then scroll within the cell.\n            this.scrollToItem(this.activeCellIndex)\n                .then(() => {\n                void cell.ready.then(() => {\n                    scrollRequest.scrollWithinCell({ scroller });\n                });\n            })\n                .catch(reason => {\n                // no-op\n            });\n        });\n        // If the insertion happened above, increment the active cell\n        // index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex + 1\n                : this.activeCellIndex;\n    }\n    /**\n     * Handle a cell being removed.\n     */\n    onCellRemoved(index, cell) {\n        // If the removal happened above, decrement the active\n        // cell index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex - 1\n                : this.activeCellIndex;\n        if (this.isSelected(cell)) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Handle a new model.\n     */\n    onModelChanged(oldValue, newValue) {\n        super.onModelChanged(oldValue, newValue);\n        // Try to set the active cell index to 0.\n        // It will be set to `-1` if there is no new model or the model is empty.\n        this.activeCellIndex = 0;\n    }\n    /**\n     * Handle edge request signals from cells.\n     */\n    _onEdgeRequest(editor, location) {\n        const prev = this.activeCellIndex;\n        if (location === 'top') {\n            this.activeCellIndex--;\n            // Move the cursor to the first position on the last line.\n            if (this.activeCellIndex < prev) {\n                const editor = this.activeCell.editor;\n                if (editor) {\n                    const lastLine = editor.lineCount - 1;\n                    editor.setCursorPosition({ line: lastLine, column: 0 });\n                }\n            }\n        }\n        else if (location === 'bottom') {\n            this.activeCellIndex++;\n            // Move the cursor to the first character.\n            if (this.activeCellIndex > prev) {\n                const editor = this.activeCell.editor;\n                if (editor) {\n                    editor.setCursorPosition({ line: 0, column: 0 });\n                }\n            }\n        }\n        this.mode = 'edit';\n    }\n    /**\n     * Ensure that the notebook has proper focus.\n     */\n    _ensureFocus(force = false) {\n        var _a, _b;\n        // No-op is the footer has the focus.\n        const footer = this.layout.footer;\n        if (footer && document.activeElement === footer.node) {\n            return;\n        }\n        const activeCell = this.activeCell;\n        if (this.mode === 'edit' && activeCell) {\n            // Test for !== true to cover hasFocus is false and editor is not yet rendered.\n            if (((_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.hasFocus()) !== true) {\n                if (activeCell.inViewport) {\n                    (_b = activeCell.editor) === null || _b === void 0 ? void 0 : _b.focus();\n                }\n                else {\n                    this.scrollToItem(this.activeCellIndex)\n                        .then(() => {\n                        void activeCell.ready.then(() => {\n                            var _a;\n                            (_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.focus();\n                        });\n                    })\n                        .catch(reason => {\n                        // no-op\n                    });\n                }\n            }\n        }\n        if (force &&\n            activeCell &&\n            !activeCell.node.contains(document.activeElement)) {\n            void NotebookActions.focusActiveCell(this, {\n                preventScroll: true\n            });\n        }\n    }\n    /**\n     * Find the cell index containing the target html element.\n     *\n     * #### Notes\n     * Returns -1 if the cell is not found.\n     */\n    _findCell(node) {\n        // Trace up the DOM hierarchy to find the root cell node.\n        // Then find the corresponding child and select it.\n        let n = node;\n        while (n && n !== this.node) {\n            if (n.classList.contains(NB_CELL_CLASS)) {\n                const i = ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);\n                if (i !== -1) {\n                    return i;\n                }\n                break;\n            }\n            n = n.parentElement;\n        }\n        return -1;\n    }\n    /**\n     * Find the target of html mouse event and cell index containing this target.\n     *\n     * #### Notes\n     * Returned index is -1 if the cell is not found.\n     */\n    _findEventTargetAndCell(event) {\n        let target = event.target;\n        let index = this._findCell(target);\n        if (index === -1) {\n            // `event.target` sometimes gives an orphaned node in Firefox 57, which\n            // can have `null` anywhere in its parent line. If we fail to find a cell\n            // using `event.target`, try again using a target reconstructed from the\n            // position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            index = this._findCell(target);\n        }\n        return [target, index];\n    }\n    /**\n     * Find heading with given ID in any of the cells.\n     */\n    async _findHeading(queryId) {\n        // Loop on cells, get headings and search for first matching id.\n        for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {\n            const cell = this.widgets[cellIdx];\n            if (cell.model.type === 'raw' ||\n                (cell.model.type === 'markdown' && !cell.rendered)) {\n                // Bail early\n                continue;\n            }\n            for (const heading of cell.headings) {\n                let id = '';\n                switch (heading.type) {\n                    case Cell.HeadingType.HTML:\n                        id = heading.id;\n                        break;\n                    case Cell.HeadingType.Markdown:\n                        {\n                            const mdHeading = heading;\n                            id = await TableOfContentsUtils.Markdown.getHeadingId(this.rendermime.markdownParser, mdHeading.raw, mdHeading.level, this.rendermime.sanitizer);\n                        }\n                        break;\n                }\n                if (id === queryId) {\n                    const element = this.node.querySelector(`h${heading.level}[id=\"${CSS.escape(id)}\"]`);\n                    return {\n                        cell,\n                        element\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Find cell by its unique ID.\n     */\n    _findCellById(queryId) {\n        for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {\n            const cell = this.widgets[cellIdx];\n            if (cell.model.id === queryId) {\n                return {\n                    cell\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * Handle `contextmenu` event.\n     */\n    _evtContextMenuCapture(event) {\n        var _a;\n        // Allow the event to propagate un-modified if the user\n        // is holding the shift-key (and probably requesting\n        // the native context menu).\n        if (event.shiftKey) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        if (widget && ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target))) {\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` event in the capture phase for the widget.\n     */\n    _evtMouseDownCapture(event) {\n        var _a;\n        const { button, shiftKey } = event;\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        // On OS X, the context menu may be triggered with ctrl-left-click. In\n        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,\n        // ctrl-left-click gives an event with button 0 with the ctrl modifier.\n        if (button === 2 &&\n            !shiftKey &&\n            widget &&\n            ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target))) {\n            this.mode = 'command';\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        var _a, _b, _c;\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2)) {\n            return;\n        }\n        // Shift right-click gives the browser default behavior.\n        if (shiftKey && button === 2) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        let targetArea;\n        if (widget) {\n            if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if ((_b = widget.promptNode) === null || _b === void 0 ? void 0 : _b.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'notebook';\n        }\n        // Make sure we go to command mode if the click isn't in the cell editor If\n        // we do click in the cell editor, the editor handles the focus event to\n        // switch to edit mode.\n        if (targetArea !== 'input') {\n            this.mode = 'command';\n        }\n        if (targetArea === 'notebook') {\n            this.deselectAll();\n        }\n        else if (targetArea === 'prompt' || targetArea === 'cell') {\n            // We don't want to prevent the default selection behavior\n            // if there is currently text selected in an output.\n            const hasSelection = ((_c = window.getSelection()) !== null && _c !== void 0 ? _c : '').toString() !== '';\n            if (button === 0 &&\n                shiftKey &&\n                !hasSelection &&\n                !['INPUT', 'OPTION'].includes(target.tagName)) {\n                // Prevent browser selecting text in prompt or output\n                event.preventDefault();\n                // Shift-click - extend selection\n                try {\n                    this.extendContiguousSelectionTo(index);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.deselectAll();\n                    return;\n                }\n                // Enter selecting mode\n                this._mouseMode = 'select';\n                // We don't want to block the shift-click mouse up handler\n                // when the current cell is (and remains) the active cell.\n                this._selectData = {\n                    startedOnActiveCell: index == this.activeCellIndex,\n                    startingCellIndex: this.activeCellIndex\n                };\n                document.addEventListener('mouseup', this, true);\n                document.addEventListener('mousemove', this, true);\n            }\n            else if (button === 0 && !shiftKey) {\n                // Prepare to start a drag if we are on the drag region.\n                if (targetArea === 'prompt') {\n                    // Prepare for a drag start\n                    this._dragData = {\n                        pressX: event.clientX,\n                        pressY: event.clientY,\n                        index: index\n                    };\n                    // Enter possible drag mode\n                    this._mouseMode = 'couldDrag';\n                    document.addEventListener('mouseup', this, true);\n                    document.addEventListener('mousemove', this, true);\n                    event.preventDefault();\n                }\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n            }\n            else if (button === 2) {\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n                event.preventDefault();\n            }\n        }\n        else if (targetArea === 'input') {\n            if (button === 2 && !this.isSelectedOrActive(widget)) {\n                this.deselectAll();\n                this.activeCellIndex = index;\n            }\n        }\n        // If we didn't set focus above, make sure we get focus now.\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle the `'mouseup'` event on the document.\n     */\n    _evtDocumentMouseup(event) {\n        const [, index] = this._findEventTargetAndCell(event);\n        let shouldPreventDefault = true;\n        if (this._mouseMode === 'select' && this._selectData) {\n            // User did not move the mouse over to a difference cell, so there was no selection\n            const { startedOnActiveCell, startingCellIndex } = this._selectData;\n            if (startedOnActiveCell && index === startingCellIndex) {\n                shouldPreventDefault = false;\n            }\n            this._selectData = null;\n        }\n        if (shouldPreventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Remove the event listeners we put on the document\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        if (this._mouseMode === 'couldDrag') {\n            // We didn't end up dragging if we are here, so treat it as a click event.\n            this.deselectAll();\n            this.activeCellIndex = index;\n            // Focus notebook if active cell changes but does not have focus.\n            if (!this.activeCell.node.contains(document.activeElement)) {\n                void NotebookActions.focusActiveCell(this);\n            }\n        }\n        this._mouseMode = null;\n    }\n    /**\n     * Handle the `'mousemove'` event for the widget.\n     */\n    _evtDocumentMousemove(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // If in select mode, update the selection\n        switch (this._mouseMode) {\n            case 'select': {\n                const target = event.target;\n                const index = this._findCell(target);\n                if (index !== -1) {\n                    this.extendContiguousSelectionTo(index);\n                }\n                break;\n            }\n            case 'couldDrag': {\n                // Check for a drag initialization.\n                const data = this._dragData;\n                const dx = Math.abs(event.clientX - data.pressX);\n                const dy = Math.abs(event.clientY - data.pressY);\n                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {\n                    this._mouseMode = null;\n                    this._startDrag(data.index, event.clientX, event.clientY);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the widget.\n     */\n    _evtDragEnter(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.cellsArray[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the widget.\n     */\n    _evtDragLeave(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the widget.\n     */\n    _evtDragOver(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.cellsArray[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Model presence should be checked before calling event handlers\n        const model = this.model;\n        const source = event.source;\n        if (source === this) {\n            // Handle the case where we are moving cells within\n            // the same notebook.\n            event.dropAction = 'move';\n            const toMove = event.mimeData.getData('internal:cells');\n            // For collapsed markdown headings with hidden \"child\" cells, move all\n            // child cells as well as the markdown heading.\n            const cell = toMove[toMove.length - 1];\n            if (cell instanceof MarkdownCell && cell.headingCollapsed) {\n                const nextParent = NotebookActions.findNextParentHeading(cell, source);\n                if (nextParent > 0) {\n                    const index = findIndex(source.widgets, (possibleCell) => {\n                        return cell.model.id === possibleCell.model.id;\n                    });\n                    toMove.push(...source.widgets.slice(index + 1, nextParent));\n                }\n            }\n            // Compute the to/from indices for the move.\n            let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);\n            let toIndex = this._findCell(target);\n            // This check is needed for consistency with the view.\n            if (toIndex !== -1 && toIndex > fromIndex) {\n                toIndex -= 1;\n            }\n            else if (toIndex === -1) {\n                // If the drop is within the notebook but not on any cell,\n                // most often this means it is past the cell areas, so\n                // set it to move the cells to the end of the notebook.\n                toIndex = this.widgets.length - 1;\n            }\n            // Don't move if we are within the block of selected cells.\n            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {\n                return;\n            }\n            // Move the cells one by one\n            this.moveCell(fromIndex, toIndex, toMove.length);\n        }\n        else {\n            // Handle the case where we are copying cells between\n            // notebooks.\n            event.dropAction = 'copy';\n            // Find the target cell and insert the copied cells.\n            let index = this._findCell(target);\n            if (index === -1) {\n                index = this.widgets.length;\n            }\n            const start = index;\n            const values = event.mimeData.getData(JUPYTER_CELL_MIME);\n            // Insert the copies of the original cells.\n            // We preserve trust status of pasted cells by not modifying metadata.\n            model.sharedModel.insertCells(index, values);\n            // Select the inserted cells.\n            this.deselectAll();\n            this.activeCellIndex = start;\n            this.extendContiguousSelectionTo(index - 1);\n        }\n        void NotebookActions.focusActiveCell(this);\n    }\n    /**\n     * Start a drag event.\n     */\n    _startDrag(index, clientX, clientY) {\n        var _a;\n        const cells = this.model.cells;\n        const selected = [];\n        const toMove = [];\n        let i = -1;\n        for (const widget of this.widgets) {\n            const cell = cells.get(++i);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(DROP_SOURCE_CLASS);\n                selected.push(cell.toJSON());\n                toMove.push(widget);\n            }\n        }\n        const activeCell = this.activeCell;\n        let dragImage = null;\n        let countString;\n        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            countString = ' ';\n            if (executionCount) {\n                countString = executionCount.toString();\n            }\n        }\n        else {\n            countString = '';\n        }\n        // Create the drag image.\n        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.sharedModel.getSource().split('\\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');\n        // Set up the drag event.\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            supportedActions: 'copy-move',\n            proposedAction: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        // Add mimeData for the fully reified cell widgets, for the\n        // case where the target is in the same notebook and we\n        // can just move the cells.\n        this._drag.mimeData.setData('internal:cells', toMove);\n        // Add mimeData for the text content of the selected cells,\n        // allowing for drag/drop into plain text fields.\n        const textContent = toMove\n            .map(cell => cell.model.sharedModel.getSource())\n            .join('\\n');\n        this._drag.mimeData.setData('text/plain', textContent);\n        // Remove mousemove and mouseup listeners and start the drag.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        this._mouseMode = null;\n        void this._drag.start(clientX, clientY).then(action => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            for (const widget of toMove) {\n                widget.removeClass(DROP_SOURCE_CLASS);\n            }\n        });\n    }\n    /**\n     * Update the notebook node with class indicating read-write state.\n     */\n    _updateReadWrite() {\n        const inReadWrite = DOMUtils.hasActiveEditableElement(this.node);\n        this.node.classList.toggle(READ_WRITE_CLASS, inReadWrite);\n    }\n    /**\n     * Handle `focus` events for the widget.\n     */\n    _evtFocusIn(event) {\n        var _a, _b;\n        // Update read-write class state.\n        this._updateReadWrite();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            // If the editor itself does not have focus, ensure command mode.\n            if (widget.editorWidget && !widget.editorWidget.node.contains(target)) {\n                this.setMode('command', { focus: false });\n            }\n            // Cell index needs to be updated before changing mode,\n            // otherwise the previous cell may get un-rendered.\n            this.activeCellIndex = index;\n            // If the editor has focus, ensure edit mode.\n            const node = (_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node;\n            if (node === null || node === void 0 ? void 0 : node.contains(target)) {\n                this.setMode('edit', { focus: false });\n            }\n        }\n        else {\n            // No cell has focus, ensure command mode.\n            this.setMode('command', { focus: false });\n            // Prevents the parent element to get the focus.\n            event.preventDefault();\n            // Check if the focus was previously in the active cell to avoid focus looping\n            // between the cell and the cell toolbar.\n            const source = event.relatedTarget;\n            // Focuses on the active cell if the focus did not come from it.\n            // Otherwise focus on the footer element (add cell button).\n            if (this._activeCell && !this._activeCell.node.contains(source)) {\n                this._activeCell.ready\n                    .then(() => {\n                    var _a;\n                    (_a = this._activeCell) === null || _a === void 0 ? void 0 : _a.node.focus({\n                        preventScroll: true\n                    });\n                })\n                    .catch(() => {\n                    var _a;\n                    (_a = this.layout.footer) === null || _a === void 0 ? void 0 : _a.node.focus({\n                        preventScroll: true\n                    });\n                });\n            }\n            else {\n                (_b = this.layout.footer) === null || _b === void 0 ? void 0 : _b.node.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }\n    /**\n     * Handle `focusout` events for the notebook.\n     */\n    _evtFocusOut(event) {\n        var _a;\n        // Update read-write class state.\n        this._updateReadWrite();\n        const relatedTarget = event.relatedTarget;\n        // Bail if the window is losing focus, to preserve edit mode. This test\n        // assumes that we explicitly focus things rather than calling blur()\n        if (!relatedTarget) {\n            return;\n        }\n        // Bail if the item gaining focus is another cell,\n        // and we should not be entering command mode.\n        const index = this._findCell(relatedTarget);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(relatedTarget)) {\n                return;\n            }\n        }\n        // Otherwise enter command mode if not already.\n        if (this.mode !== 'command') {\n            this.setMode('command', { focus: false });\n        }\n    }\n    /**\n     * Handle `dblclick` events for the widget.\n     */\n    _evtDblClick(event) {\n        const model = this.model;\n        if (!model) {\n            return;\n        }\n        this.deselectAll();\n        const [target, index] = this._findEventTargetAndCell(event);\n        if (event.target.classList.contains(HEADING_COLLAPSER_CLASS)) {\n            return;\n        }\n        if (index === -1) {\n            return;\n        }\n        this.activeCellIndex = index;\n        if (model.cells.get(index).type === 'markdown') {\n            const widget = this.widgets[index];\n            widget.rendered = false;\n        }\n        else if (target.localName === 'img') {\n            target.classList.toggle(UNCONFINED_CLASS);\n        }\n    }\n    /**\n     * Remove selections from inactive cells to avoid\n     * spurious cursors.\n     */\n    _trimSelections() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            if (i !== this._activeCellIndex) {\n                const cell = this.widgets[i];\n                if (!cell.model.isDisposed && cell.editor) {\n                    cell.model.selections.delete(cell.editor.uuid);\n                }\n            }\n        }\n    }\n    _updateSelectedCells() {\n        this._selectedCells = this.widgets.filter(cell => this.isSelectedOrActive(cell));\n        if (this.kernelHistory) {\n            this.kernelHistory.reset();\n        }\n    }\n}\n/**\n * The namespace for the `Notebook` class statics.\n */\n(function (Notebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends StaticNotebook.ContentFactory {\n    }\n    Notebook.ContentFactory = ContentFactory;\n})(Notebook || (Notebook = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the selected state of a cell.\n     */\n    Private.selectedProperty = new AttachedProperty({\n        name: 'selected',\n        create: () => false\n    });\n    /**\n     * A custom panel layout for the notebook.\n     */\n    class NotebookPanelLayout extends PanelLayout {\n        /**\n         * A message handler invoked on an `'update-request'` message.\n         *\n         * #### Notes\n         * This is a reimplementation of the base class method,\n         * and is a no-op.\n         */\n        onUpdateRequest(msg) {\n            // This is a no-op.\n        }\n    }\n    Private.NotebookPanelLayout = NotebookPanelLayout;\n    /**\n     * Create a cell drag image.\n     */\n    function createDragImage(count, promptNumber, cellContent) {\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    Private.createDragImage = createDragImage;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, Printing, showDialog } from '@jupyterlab/apputils';\nimport { isMarkdownCellModel } from '@jupyterlab/cells';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { Token } from '@lumino/coreutils';\nimport { Notebook } from './widget';\n/**\n * The class name added to notebook panels.\n */\nconst NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';\nconst NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';\nconst NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';\n/**\n * A widget that hosts a notebook toolbar and content area.\n *\n * #### Notes\n * The widget keeps the document metadata in sync with the current\n * kernel on the context.\n */\nexport class NotebookPanel extends DocumentWidget {\n    /**\n     * Construct a new notebook panel.\n     */\n    constructor(options) {\n        super(options);\n        /**\n         * Whether we are currently in a series of autorestarts we have already\n         * notified the user about.\n         */\n        this._autorestarting = false;\n        // Set up CSS classes\n        this.addClass(NOTEBOOK_PANEL_CLASS);\n        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);\n        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);\n        // Set up things related to the context\n        this.content.model = this.context.model;\n        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);\n        // this.content.fullyRendered.connect(this._onFullyRendered, this);\n        this.context.saveState.connect(this._onSave, this);\n        void this.revealed.then(() => {\n            if (this.isDisposed) {\n                // this widget has already been disposed, bail\n                return;\n            }\n            // Set the document edit mode on initial open if it looks like a new document.\n            if (this.content.widgets.length === 1) {\n                const cellModel = this.content.widgets[0].model;\n                if (cellModel.type === 'code' &&\n                    cellModel.sharedModel.getSource() === '') {\n                    this.content.mode = 'edit';\n                }\n            }\n        });\n    }\n    /**\n     * Handle a change to the document registry save state.\n     *\n     * @param sender The document registry context\n     * @param state The document registry save state\n     */\n    _onSave(sender, state) {\n        if (state === 'started' && this.model) {\n            // Find markdown cells\n            for (const cell of this.model.cells) {\n                if (isMarkdownCellModel(cell)) {\n                    for (const key of cell.attachments.keys) {\n                        if (!cell.sharedModel.getSource().includes(key)) {\n                            cell.attachments.remove(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * The session context used by the panel.\n     */\n    get sessionContext() {\n        return this.context.sessionContext;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this.content.model;\n    }\n    /**\n     * Update the options for the current notebook panel.\n     *\n     * @param config new options to set\n     */\n    setConfig(config) {\n        this.content.editorConfig = config.editorConfig;\n        this.content.notebookConfig = config.notebookConfig;\n        // Update kernel shutdown behavior\n        const kernelPreference = this.context.sessionContext.kernelPreference;\n        this.context.sessionContext.kernelPreference = {\n            ...kernelPreference,\n            shutdownOnDispose: config.kernelShutdown,\n            autoStartDefault: config.autoStartDefault\n        };\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        void this.context.ready.then(() => {\n            void this.content.setFragment(fragment);\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        this.content.dispose();\n        super.dispose();\n    }\n    /**\n     * Prints the notebook by converting to HTML with nbconvert.\n     */\n    [Printing.symbol]() {\n        return async () => {\n            // Save before generating HTML\n            if (this.context.model.dirty && !this.context.model.readOnly) {\n                await this.context.save();\n            }\n            await Printing.printURL(PageConfig.getNBConvertURL({\n                format: 'html',\n                download: false,\n                path: this.context.path\n            }));\n        };\n    }\n    /**\n     * A message handler invoked on a 'before-hide' message.\n     */\n    onBeforeHide(msg) {\n        super.onBeforeHide(msg);\n        // Inform the windowed list that the notebook is gonna be hidden\n        this.content.isParentHidden = true;\n    }\n    /**\n     * A message handler invoked on a 'before-show' message.\n     */\n    onBeforeShow(msg) {\n        // Inform the windowed list that the notebook is gonna be shown\n        // Use onBeforeShow instead of onAfterShow to take into account\n        // resizing (like sidebars got expanded before switching to the notebook tab)\n        this.content.isParentHidden = false;\n        super.onBeforeShow(msg);\n    }\n    /**\n     * Handle a change in the kernel by updating the document metadata.\n     */\n    _onKernelChanged(sender, args) {\n        if (!this.model || !args.newValue) {\n            return;\n        }\n        const { newValue } = args;\n        void newValue.info.then(info => {\n            var _a;\n            if (this.model &&\n                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {\n                this._updateLanguage(info.language_info);\n            }\n        });\n        void this._updateSpec(newValue);\n    }\n    _onSessionStatusChanged(sender, status) {\n        var _a;\n        // If the status is autorestarting, and we aren't already in a series of\n        // autorestarts, show the dialog.\n        if (status === 'autorestarting' && !this._autorestarting) {\n            // The kernel died and the server is restarting it. We notify the user so\n            // they know why their kernel state is gone.\n            void showDialog({\n                title: this._trans.__('Kernel Restarting'),\n                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n            this._autorestarting = true;\n        }\n        else if (status === 'restarting') {\n            // Another autorestart attempt will first change the status to\n            // restarting, then to autorestarting again, so we don't reset the\n            // autorestarting status if the status is 'restarting'.\n            /* no-op */\n        }\n        else {\n            this._autorestarting = false;\n        }\n    }\n    /**\n     * Update the kernel language.\n     */\n    _updateLanguage(language) {\n        this.model.setMetadata('language_info', language);\n    }\n    /**\n     * Update the kernel spec.\n     */\n    async _updateSpec(kernel) {\n        const spec = await kernel.spec;\n        if (this.isDisposed) {\n            return;\n        }\n        this.model.setMetadata('kernelspec', {\n            name: kernel.name,\n            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,\n            language: spec === null || spec === void 0 ? void 0 : spec.language\n        });\n    }\n}\n/**\n * A namespace for `NotebookPanel` statics.\n */\n(function (NotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Notebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new Notebook(options);\n        }\n    }\n    NotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * The notebook renderer token.\n     */\n    NotebookPanel.IContentFactory = new Token('@jupyterlab/notebook:IContentFactory', `A factory object that creates new notebooks.\n    Use this if you want to create and host notebooks in your own UI elements.`);\n})(NotebookPanel || (NotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, MarkdownCell } from '@jupyterlab/cells';\nimport { TableOfContentsFactory, TableOfContentsModel, TableOfContentsUtils } from '@jupyterlab/toc';\nimport { NotebookActions } from './actions';\n/**\n * Cell running status\n */\nexport var RunningStatus;\n(function (RunningStatus) {\n    /**\n     * Cell is idle\n     */\n    RunningStatus[RunningStatus[\"Idle\"] = -1] = \"Idle\";\n    /**\n     * Cell execution is unsuccessful\n     */\n    RunningStatus[RunningStatus[\"Error\"] = -0.5] = \"Error\";\n    /**\n     * Cell execution is scheduled\n     */\n    RunningStatus[RunningStatus[\"Scheduled\"] = 0] = \"Scheduled\";\n    /**\n     * Cell is running\n     */\n    RunningStatus[RunningStatus[\"Running\"] = 1] = \"Running\";\n})(RunningStatus || (RunningStatus = {}));\n/**\n * Table of content model for Notebook files.\n */\nexport class NotebookToCModel extends TableOfContentsModel {\n    /**\n     * Constructor\n     *\n     * @param widget The widget to search in\n     * @param parser Markdown parser\n     * @param sanitizer Sanitizer\n     * @param configuration Default model configuration\n     */\n    constructor(widget, parser, sanitizer, configuration) {\n        super(widget, configuration);\n        this.parser = parser;\n        this.sanitizer = sanitizer;\n        /**\n         * Mapping between configuration options and notebook metadata.\n         *\n         * If it starts with `!`, the boolean value of the configuration option is\n         * opposite to the one stored in metadata.\n         * If it contains `/`, the metadata data is nested.\n         */\n        this.configMetadataMap = {\n            numberHeaders: ['toc-autonumbering', 'toc/number_sections'],\n            numberingH1: ['!toc/skip_h1_title'],\n            baseNumbering: ['toc/base_numbering']\n        };\n        this._runningCells = new Array();\n        this._errorCells = new Array();\n        this._cellToHeadingIndex = new WeakMap();\n        void widget.context.ready.then(() => {\n            // Load configuration from metadata\n            this.setConfiguration({});\n        });\n        this.widget.context.model.metadataChanged.connect(this.onMetadataChanged, this);\n        this.widget.content.activeCellChanged.connect(this.onActiveCellChanged, this);\n        NotebookActions.executionScheduled.connect(this.onExecutionScheduled, this);\n        NotebookActions.executed.connect(this.onExecuted, this);\n        NotebookActions.outputCleared.connect(this.onOutputCleared, this);\n        this.headingsChanged.connect(this.onHeadingsChanged, this);\n    }\n    /**\n     * Type of document supported by the model.\n     *\n     * #### Notes\n     * A `data-document-type` attribute with this value will be set\n     * on the tree view `.jp-TableOfContents-content[data-document-type=\"...\"]`\n     */\n    get documentType() {\n        return 'notebook';\n    }\n    /**\n     * Whether the model gets updated even if the table of contents panel\n     * is hidden or not.\n     */\n    get isAlwaysActive() {\n        return true;\n    }\n    /**\n     * List of configuration options supported by the model.\n     */\n    get supportedOptions() {\n        return [\n            'baseNumbering',\n            'maximalDepth',\n            'numberingH1',\n            'numberHeaders',\n            'includeOutput',\n            'syncCollapseState'\n        ];\n    }\n    /**\n     * Get the headings of a given cell.\n     *\n     * @param cell Cell\n     * @returns The associated headings\n     */\n    getCellHeadings(cell) {\n        const headings = new Array();\n        let headingIndex = this._cellToHeadingIndex.get(cell);\n        if (headingIndex !== undefined) {\n            const candidate = this.headings[headingIndex];\n            headings.push(candidate);\n            while (this.headings[headingIndex - 1] &&\n                this.headings[headingIndex - 1].cellRef === candidate.cellRef) {\n                headingIndex--;\n                headings.unshift(this.headings[headingIndex]);\n            }\n        }\n        return headings;\n    }\n    /**\n     * Dispose the object\n     */\n    dispose() {\n        var _a, _b, _c;\n        if (this.isDisposed) {\n            return;\n        }\n        this.headingsChanged.disconnect(this.onHeadingsChanged, this);\n        (_b = (_a = this.widget.context) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.metadataChanged.disconnect(this.onMetadataChanged, this);\n        (_c = this.widget.content) === null || _c === void 0 ? void 0 : _c.activeCellChanged.disconnect(this.onActiveCellChanged, this);\n        NotebookActions.executionScheduled.disconnect(this.onExecutionScheduled, this);\n        NotebookActions.executed.disconnect(this.onExecuted, this);\n        NotebookActions.outputCleared.disconnect(this.onOutputCleared, this);\n        this._runningCells.length = 0;\n        this._errorCells.length = 0;\n        super.dispose();\n    }\n    /**\n     * Model configuration setter.\n     *\n     * @param c New configuration\n     */\n    setConfiguration(c) {\n        // Ensure configuration update\n        const metadataConfig = this.loadConfigurationFromMetadata();\n        super.setConfiguration({ ...this.configuration, ...metadataConfig, ...c });\n    }\n    /**\n     * Callback on heading collapse.\n     *\n     * @param options.heading The heading to change state (all headings if not provided)\n     * @param options.collapsed The new collapsed status (toggle existing status if not provided)\n     */\n    toggleCollapse(options) {\n        super.toggleCollapse(options);\n        this.updateRunningStatus(this.headings);\n    }\n    /**\n     * Produce the headings for a document.\n     *\n     * @returns The list of new headings or `null` if nothing needs to be updated.\n     */\n    getHeadings() {\n        const cells = this.widget.content.widgets;\n        const headings = [];\n        const documentLevels = new Array();\n        // Generate headings by iterating through all notebook cells...\n        for (let i = 0; i < cells.length; i++) {\n            const cell = cells[i];\n            const model = cell.model;\n            switch (model.type) {\n                case 'code': {\n                    // Collapsing cells is incompatible with output headings\n                    if (!this.configuration.syncCollapseState &&\n                        this.configuration.includeOutput) {\n                        headings.push(...TableOfContentsUtils.filterHeadings(cell.headings, this.configuration, documentLevels).map(heading => {\n                            return {\n                                ...heading,\n                                cellRef: cell,\n                                collapsed: false,\n                                isRunning: RunningStatus.Idle\n                            };\n                        }));\n                    }\n                    break;\n                }\n                case 'markdown': {\n                    const cellHeadings = TableOfContentsUtils.filterHeadings(cell.headings, this.configuration, documentLevels).map((heading, index) => {\n                        return {\n                            ...heading,\n                            cellRef: cell,\n                            collapsed: false,\n                            isRunning: RunningStatus.Idle\n                        };\n                    });\n                    // If there are multiple headings, only collapse the highest heading (i.e. minimal level)\n                    // consistent with the cell.headingInfo\n                    if (this.configuration.syncCollapseState &&\n                        cell.headingCollapsed) {\n                        const minLevel = Math.min(...cellHeadings.map(h => h.level));\n                        const minHeading = cellHeadings.find(h => h.level === minLevel);\n                        minHeading.collapsed = cell.headingCollapsed;\n                    }\n                    headings.push(...cellHeadings);\n                    break;\n                }\n            }\n            if (headings.length > 0) {\n                this._cellToHeadingIndex.set(cell, headings.length - 1);\n            }\n        }\n        this.updateRunningStatus(headings);\n        return Promise.resolve(headings);\n    }\n    /**\n     * Test if two headings are equal or not.\n     *\n     * @param heading1 First heading\n     * @param heading2 Second heading\n     * @returns Whether the headings are equal.\n     */\n    isHeadingEqual(heading1, heading2) {\n        return (super.isHeadingEqual(heading1, heading2) &&\n            heading1.cellRef === heading2.cellRef);\n    }\n    /**\n     * Read table of content configuration from notebook metadata.\n     *\n     * @returns ToC configuration from metadata\n     */\n    loadConfigurationFromMetadata() {\n        const nbModel = this.widget.content.model;\n        const newConfig = {};\n        if (nbModel) {\n            for (const option in this.configMetadataMap) {\n                const keys = this.configMetadataMap[option];\n                for (const k of keys) {\n                    let key = k;\n                    const negate = key[0] === '!';\n                    if (negate) {\n                        key = key.slice(1);\n                    }\n                    const keyPath = key.split('/');\n                    let value = nbModel.getMetadata(keyPath[0]);\n                    for (let p = 1; p < keyPath.length; p++) {\n                        value = (value !== null && value !== void 0 ? value : {})[keyPath[p]];\n                    }\n                    if (value !== undefined) {\n                        if (typeof value === 'boolean' && negate) {\n                            value = !value;\n                        }\n                        newConfig[option] = value;\n                    }\n                }\n            }\n        }\n        return newConfig;\n    }\n    onActiveCellChanged(notebook, cell) {\n        // Highlight the first title as active (if multiple titles are in the same cell)\n        const activeHeading = this.getCellHeadings(cell)[0];\n        this.setActiveHeading(activeHeading !== null && activeHeading !== void 0 ? activeHeading : null, false);\n    }\n    onHeadingsChanged() {\n        if (this.widget.content.activeCell) {\n            this.onActiveCellChanged(this.widget.content, this.widget.content.activeCell);\n        }\n    }\n    onExecuted(_, args) {\n        this._runningCells.forEach((cell, index) => {\n            var _a;\n            if (cell === args.cell) {\n                this._runningCells.splice(index, 1);\n                const headingIndex = this._cellToHeadingIndex.get(cell);\n                if (headingIndex !== undefined) {\n                    const heading = this.headings[headingIndex];\n                    // when the execution is not successful but errorName is undefined,\n                    // the execution is interrupted by previous cells\n                    if (args.success || ((_a = args.error) === null || _a === void 0 ? void 0 : _a.errorName) === undefined) {\n                        heading.isRunning = RunningStatus.Idle;\n                        return;\n                    }\n                    heading.isRunning = RunningStatus.Error;\n                    if (!this._errorCells.includes(cell)) {\n                        this._errorCells.push(cell);\n                    }\n                }\n            }\n        });\n        this.updateRunningStatus(this.headings);\n        this.stateChanged.emit();\n    }\n    onExecutionScheduled(_, args) {\n        if (!this._runningCells.includes(args.cell)) {\n            this._runningCells.push(args.cell);\n        }\n        this._errorCells.forEach((cell, index) => {\n            if (cell === args.cell) {\n                this._errorCells.splice(index, 1);\n            }\n        });\n        this.updateRunningStatus(this.headings);\n        this.stateChanged.emit();\n    }\n    onOutputCleared(_, args) {\n        this._errorCells.forEach((cell, index) => {\n            if (cell === args.cell) {\n                this._errorCells.splice(index, 1);\n                const headingIndex = this._cellToHeadingIndex.get(cell);\n                if (headingIndex !== undefined) {\n                    const heading = this.headings[headingIndex];\n                    heading.isRunning = RunningStatus.Idle;\n                }\n            }\n        });\n        this.updateRunningStatus(this.headings);\n        this.stateChanged.emit();\n    }\n    onMetadataChanged() {\n        this.setConfiguration({});\n    }\n    updateRunningStatus(headings) {\n        // Update isRunning\n        this._runningCells.forEach((cell, index) => {\n            const headingIndex = this._cellToHeadingIndex.get(cell);\n            if (headingIndex !== undefined) {\n                const heading = this.headings[headingIndex];\n                // Running is prioritized over Scheduled, so if a heading is\n                // running don't change status\n                if (heading.isRunning !== RunningStatus.Running) {\n                    heading.isRunning =\n                        index > 0 ? RunningStatus.Scheduled : RunningStatus.Running;\n                }\n            }\n        });\n        this._errorCells.forEach((cell, index) => {\n            const headingIndex = this._cellToHeadingIndex.get(cell);\n            if (headingIndex !== undefined) {\n                const heading = this.headings[headingIndex];\n                // Running and Scheduled are prioritized over Error, so only if\n                // a heading is idle will it be set to Error\n                if (heading.isRunning === RunningStatus.Idle) {\n                    heading.isRunning = RunningStatus.Error;\n                }\n            }\n        });\n        let globalIndex = 0;\n        while (globalIndex < headings.length) {\n            const heading = headings[globalIndex];\n            globalIndex++;\n            if (heading.collapsed) {\n                const maxIsRunning = Math.max(heading.isRunning, getMaxIsRunning(headings, heading.level));\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': maxIsRunning.toString()\n                };\n            }\n            else {\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': heading.isRunning.toString()\n                };\n            }\n        }\n        function getMaxIsRunning(headings, collapsedLevel) {\n            let maxIsRunning = RunningStatus.Idle;\n            while (globalIndex < headings.length) {\n                const heading = headings[globalIndex];\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': heading.isRunning.toString()\n                };\n                if (heading.level > collapsedLevel) {\n                    globalIndex++;\n                    maxIsRunning = Math.max(heading.isRunning, maxIsRunning);\n                    if (heading.collapsed) {\n                        maxIsRunning = Math.max(maxIsRunning, getMaxIsRunning(headings, heading.level));\n                        heading.dataset = {\n                            ...heading.dataset,\n                            'data-running': maxIsRunning.toString()\n                        };\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            return maxIsRunning;\n        }\n    }\n}\n/**\n * Table of content model factory for Notebook files.\n */\nexport class NotebookToCFactory extends TableOfContentsFactory {\n    /**\n     * Constructor\n     *\n     * @param tracker Widget tracker\n     * @param parser Markdown parser\n     * @param sanitizer Sanitizer\n     */\n    constructor(tracker, parser, sanitizer) {\n        super(tracker);\n        this.parser = parser;\n        this.sanitizer = sanitizer;\n        this._scrollToTop = true;\n    }\n    /**\n     * Whether to scroll the active heading to the top\n     * of the document or not.\n     */\n    get scrollToTop() {\n        return this._scrollToTop;\n    }\n    set scrollToTop(v) {\n        this._scrollToTop = v;\n    }\n    /**\n     * Create a new table of contents model for the widget\n     *\n     * @param widget - widget\n     * @param configuration - Table of contents configuration\n     * @returns The table of contents model\n     */\n    _createNew(widget, configuration) {\n        const model = new NotebookToCModel(widget, this.parser, this.sanitizer, configuration);\n        // Connect model signals to notebook panel\n        let headingToElement = new WeakMap();\n        const onActiveHeadingChanged = (model, heading) => {\n            if (heading) {\n                const onCellInViewport = async (cell) => {\n                    if (!cell.inViewport) {\n                        // Bail early\n                        return;\n                    }\n                    const el = headingToElement.get(heading);\n                    if (el) {\n                        if (this.scrollToTop) {\n                            el.scrollIntoView({ block: 'start' });\n                        }\n                        else {\n                            const widgetBox = widget.content.node.getBoundingClientRect();\n                            const elementBox = el.getBoundingClientRect();\n                            if (elementBox.top > widgetBox.bottom ||\n                                elementBox.bottom < widgetBox.top) {\n                                el.scrollIntoView({ block: 'center' });\n                            }\n                        }\n                    }\n                    else {\n                        console.debug('scrolling to heading: using fallback strategy');\n                        await widget.content.scrollToItem(widget.content.activeCellIndex, this.scrollToTop ? 'start' : undefined, 0);\n                    }\n                };\n                const cell = heading.cellRef;\n                const cells = widget.content.widgets;\n                const idx = cells.indexOf(cell);\n                // Switch to command mode to avoid entering Markdown cell in edit mode\n                // if the document was in edit mode\n                if (cell.model.type == 'markdown' && widget.content.mode != 'command') {\n                    widget.content.mode = 'command';\n                }\n                widget.content.activeCellIndex = idx;\n                if (cell.inViewport) {\n                    onCellInViewport(cell).catch(reason => {\n                        console.error(`Fail to scroll to cell to display the required heading (${reason}).`);\n                    });\n                }\n                else {\n                    widget.content\n                        .scrollToItem(idx, this.scrollToTop ? 'start' : undefined)\n                        .then(() => {\n                        return onCellInViewport(cell);\n                    })\n                        .catch(reason => {\n                        console.error(`Fail to scroll to cell to display the required heading (${reason}).`);\n                    });\n                }\n            }\n        };\n        const findHeadingElement = (cell) => {\n            model.getCellHeadings(cell).forEach(async (heading) => {\n                var _a, _b;\n                const elementId = await getIdForHeading(heading, this.parser, this.sanitizer);\n                const selector = elementId\n                    ? `h${heading.level}[id=\"${CSS.escape(elementId)}\"]`\n                    : `h${heading.level}`;\n                if (heading.outputIndex !== undefined) {\n                    // Code cell\n                    headingToElement.set(heading, TableOfContentsUtils.addPrefix(heading.cellRef.outputArea.widgets[heading.outputIndex].node, selector, (_a = heading.prefix) !== null && _a !== void 0 ? _a : ''));\n                }\n                else {\n                    headingToElement.set(heading, TableOfContentsUtils.addPrefix(heading.cellRef.node, selector, (_b = heading.prefix) !== null && _b !== void 0 ? _b : ''));\n                }\n            });\n        };\n        const onHeadingsChanged = (model) => {\n            if (!this.parser) {\n                return;\n            }\n            // Clear all numbering items\n            TableOfContentsUtils.clearNumbering(widget.content.node);\n            // Create a new mapping\n            headingToElement = new WeakMap();\n            widget.content.widgets.forEach(cell => {\n                findHeadingElement(cell);\n            });\n        };\n        const onHeadingCollapsed = (_, heading) => {\n            var _a, _b, _c, _d;\n            if (model.configuration.syncCollapseState) {\n                if (heading !== null) {\n                    const cell = heading.cellRef;\n                    if (cell.headingCollapsed !== ((_a = heading.collapsed) !== null && _a !== void 0 ? _a : false)) {\n                        cell.headingCollapsed = (_b = heading.collapsed) !== null && _b !== void 0 ? _b : false;\n                    }\n                }\n                else {\n                    const collapseState = (_d = (_c = model.headings[0]) === null || _c === void 0 ? void 0 : _c.collapsed) !== null && _d !== void 0 ? _d : false;\n                    widget.content.widgets.forEach(cell => {\n                        if (cell instanceof MarkdownCell) {\n                            if (cell.headingInfo.level >= 0) {\n                                cell.headingCollapsed = collapseState;\n                            }\n                        }\n                    });\n                }\n            }\n        };\n        const onCellCollapsed = (_, cell) => {\n            if (model.configuration.syncCollapseState) {\n                const h = model.getCellHeadings(cell)[0];\n                if (h) {\n                    model.toggleCollapse({\n                        heading: h,\n                        collapsed: cell.headingCollapsed\n                    });\n                }\n            }\n        };\n        const onCellInViewportChanged = (_, cell) => {\n            if (cell.inViewport) {\n                findHeadingElement(cell);\n            }\n            else {\n                // Needed to remove prefix in cell outputs\n                TableOfContentsUtils.clearNumbering(cell.node);\n            }\n        };\n        void widget.context.ready.then(() => {\n            onHeadingsChanged(model);\n            model.activeHeadingChanged.connect(onActiveHeadingChanged);\n            model.headingsChanged.connect(onHeadingsChanged);\n            model.collapseChanged.connect(onHeadingCollapsed);\n            widget.content.cellCollapsed.connect(onCellCollapsed);\n            widget.content.cellInViewportChanged.connect(onCellInViewportChanged);\n            widget.disposed.connect(() => {\n                model.activeHeadingChanged.disconnect(onActiveHeadingChanged);\n                model.headingsChanged.disconnect(onHeadingsChanged);\n                model.collapseChanged.disconnect(onHeadingCollapsed);\n                widget.content.cellCollapsed.disconnect(onCellCollapsed);\n                widget.content.cellInViewportChanged.disconnect(onCellInViewportChanged);\n            });\n        });\n        return model;\n    }\n}\n/**\n * Get the element id for an heading\n * @param heading Heading\n * @param parser The markdownparser\n * @returns The element id\n */\nexport async function getIdForHeading(heading, parser, sanitizer) {\n    let elementId = null;\n    if (heading.type === Cell.HeadingType.Markdown) {\n        elementId = await TableOfContentsUtils.Markdown.getHeadingId(parser, \n        // Type from TableOfContentsUtils.Markdown.IMarkdownHeading\n        heading.raw, heading.level, sanitizer);\n    }\n    else if (heading.type === Cell.HeadingType.HTML) {\n        // Type from TableOfContentsUtils.IHTMLHeading\n        elementId = heading.id;\n    }\n    return elementId;\n}\n//# sourceMappingURL=toc.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, createCellSearchProvider } from '@jupyterlab/cells';\nimport { SearchProvider } from '@jupyterlab/documentsearch';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { NotebookPanel } from './panel';\n/**\n * Notebook document search provider\n */\nexport class NotebookSearchProvider extends SearchProvider {\n    /**\n     * Constructor\n     *\n     * @param widget The widget to search in\n     * @param translator Application translator\n     */\n    constructor(widget, translator = nullTranslator) {\n        super(widget);\n        this.translator = translator;\n        this._textSelection = null;\n        this._currentProviderIndex = null;\n        this._delayedActiveCellChangeHandler = null;\n        this._onSelection = false;\n        this._selectedCells = 1;\n        this._selectedLines = 0;\n        this._query = null;\n        this._searchProviders = [];\n        this._editorSelectionsObservable = null;\n        this._selectionSearchMode = 'cells';\n        this._selectionLock = false;\n        this._searchActive = false;\n        this._handleHighlightsAfterActiveCellChange =\n            this._handleHighlightsAfterActiveCellChange.bind(this);\n        this.widget.model.cells.changed.connect(this._onCellsChanged, this);\n        this.widget.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this.widget.content.selectionChanged.connect(this._onCellSelectionChanged, this);\n        this.widget.content.stateChanged.connect(this._onNotebookStateChanged, this);\n        this._observeActiveCell();\n        this._filtersChanged.connect(this._setEnginesSelectionSearchMode, this);\n    }\n    _onNotebookStateChanged(_, args) {\n        if (args.name === 'mode') {\n            // Delay the update to ensure that `document.activeElement` settled.\n            window.setTimeout(() => {\n                var _a;\n                if (args.newValue === 'command' &&\n                    ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('.jp-DocumentSearch-overlay'))) {\n                    // Do not request updating mode when user switched focus to search overlay.\n                    return;\n                }\n                this._updateSelectionMode();\n                this._filtersChanged.emit();\n            }, 0);\n        }\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     *\n     * @param domain Widget to test\n     * @returns Search ability\n     */\n    static isApplicable(domain) {\n        // check to see if the CMSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return domain instanceof NotebookPanel;\n    }\n    /**\n     * Instantiate a search provider for the notebook panel.\n     *\n     * #### Notes\n     * The widget provided is always checked using `isApplicable` before calling\n     * this factory.\n     *\n     * @param widget The widget to search on\n     * @param translator [optional] The translator object\n     *\n     * @returns The search provider on the notebook panel\n     */\n    static createNew(widget, translator) {\n        return new NotebookSearchProvider(widget, translator);\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        let agg = 0;\n        let found = false;\n        for (let idx = 0; idx < this._searchProviders.length; idx++) {\n            const provider = this._searchProviders[idx];\n            if (this._currentProviderIndex == idx) {\n                const localMatch = provider.currentMatchIndex;\n                if (localMatch === null) {\n                    return null;\n                }\n                agg += localMatch;\n                found = true;\n                break;\n            }\n            else {\n                agg += provider.matchesCount;\n            }\n        }\n        return found ? agg : null;\n    }\n    /**\n     * The number of matches.\n     */\n    get matchesCount() {\n        return this._searchProviders.reduce((sum, provider) => (sum += provider.matchesCount), 0);\n    }\n    /**\n     * Set to true if the widget under search is read-only, false\n     * if it is editable. Will be used to determine whether to show\n     * the replace option.\n     */\n    get isReadOnly() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this.widget) === null || _a === void 0 ? void 0 : _a.content.model) === null || _b === void 0 ? void 0 : _b.readOnly) !== null && _c !== void 0 ? _c : false;\n    }\n    /**\n     * Support for options adjusting replacement behavior.\n     */\n    get replaceOptionsSupport() {\n        return {\n            preserveCase: true\n        };\n    }\n    getSelectionState() {\n        const cellMode = this._selectionSearchMode === 'cells';\n        const selectedCount = cellMode ? this._selectedCells : this._selectedLines;\n        return selectedCount > 1\n            ? 'multiple'\n            : selectedCount === 1 && !cellMode\n                ? 'single'\n                : 'none';\n    }\n    /**\n     * Dispose of the resources held by the search provider.\n     *\n     * #### Notes\n     * If the object's `dispose` method is called more than once, all\n     * calls made after the first will be a no-op.\n     *\n     * #### Undefined Behavior\n     * It is undefined behavior to use any functionality of the object\n     * after it has been disposed unless otherwise explicitly noted.\n     */\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this.widget.content.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n        (_a = this.widget.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this._onCellsChanged, this);\n        this.widget.content.stateChanged.disconnect(this._onNotebookStateChanged, this);\n        this.widget.content.selectionChanged.disconnect(this._onCellSelectionChanged, this);\n        this._stopObservingLastCell();\n        super.dispose();\n        const index = this.widget.content.activeCellIndex;\n        this.endQuery()\n            .then(() => {\n            if (!this.widget.isDisposed) {\n                this.widget.content.activeCellIndex = index;\n            }\n        })\n            .catch(reason => {\n            console.error(`Fail to end search query in notebook:\\n${reason}`);\n        });\n    }\n    /**\n     * Get the filters for the given provider.\n     *\n     * @returns The filters.\n     */\n    getFilters() {\n        const trans = this.translator.load('jupyterlab');\n        return {\n            output: {\n                title: trans.__('Search Cell Outputs'),\n                description: trans.__('Search in the cell outputs.'),\n                disabledDescription: trans.__('Search in the cell outputs (not available when replace options are shown).'),\n                default: false,\n                supportReplace: false\n            },\n            selection: {\n                title: this._selectionSearchMode === 'cells'\n                    ? trans._n('Search in %1 Selected Cell', 'Search in %1 Selected Cells', this._selectedCells)\n                    : trans._n('Search in %1 Selected Line', 'Search in %1 Selected Lines', this._selectedLines),\n                description: trans.__('Search only in the selected cells or text (depending on edit/command mode).'),\n                default: false,\n                supportReplace: true\n            }\n        };\n    }\n    /**\n     * Update the search in selection mode; it should only be called when user\n     * navigates the notebook (enters editing/command mode, changes selection)\n     * but not when the searchbox gets focused (switching the notebook to command\n     * mode) nor when search highlights a match (switching notebook to edit mode).\n     */\n    _updateSelectionMode() {\n        if (this._selectionLock) {\n            return;\n        }\n        this._selectionSearchMode =\n            this._selectedCells === 1 &&\n                this.widget.content.mode === 'edit' &&\n                this._selectedLines !== 0\n                ? 'text'\n                : 'cells';\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery() {\n        var _a;\n        // Get whatever is selected in the browser window.\n        return ((_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n    }\n    /**\n     * Clear currently highlighted match.\n     */\n    async clearHighlight() {\n        this._selectionLock = true;\n        if (this._currentProviderIndex !== null &&\n            this._currentProviderIndex < this._searchProviders.length) {\n            await this._searchProviders[this._currentProviderIndex].clearHighlight();\n            this._currentProviderIndex = null;\n        }\n        this._selectionLock = false;\n    }\n    /**\n     * Highlight the next match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns The next match if available.\n     */\n    async highlightNext(loop = true, options) {\n        const match = await this._stepNext(false, loop, options);\n        return match !== null && match !== void 0 ? match : undefined;\n    }\n    /**\n     * Highlight the previous match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns The previous match if available.\n     */\n    async highlightPrevious(loop = true, options) {\n        const match = await this._stepNext(true, loop, options);\n        return match !== null && match !== void 0 ? match : undefined;\n    }\n    /**\n     * Search for a regular expression with optional filters.\n     *\n     * @param query A regular expression to test for\n     * @param filters Filter parameters to pass to provider\n     *\n     */\n    async startQuery(query, filters) {\n        if (!this.widget) {\n            return;\n        }\n        await this.endQuery();\n        this._searchActive = true;\n        let cells = this.widget.content.widgets;\n        this._query = query;\n        this._filters = {\n            output: false,\n            selection: false,\n            ...(filters !== null && filters !== void 0 ? filters : {})\n        };\n        this._onSelection = this._filters.selection;\n        const currentProviderIndex = this.widget.content.activeCellIndex;\n        // For each cell, create a search provider\n        this._searchProviders = await Promise.all(cells.map(async (cell, index) => {\n            const cellSearchProvider = createCellSearchProvider(cell);\n            await cellSearchProvider.setIsActive(!this._filters.selection ||\n                this.widget.content.isSelectedOrActive(cell));\n            if (this._onSelection &&\n                this._selectionSearchMode === 'text' &&\n                index === currentProviderIndex) {\n                if (this._textSelection) {\n                    await cellSearchProvider.setSearchSelection(this._textSelection);\n                }\n            }\n            await cellSearchProvider.startQuery(query, this._filters);\n            return cellSearchProvider;\n        }));\n        this._currentProviderIndex = currentProviderIndex;\n        // We do not want to show the first \"current\" closest to cursor as depending\n        // on which way the user dragged the selection it would be:\n        // - the first or last match when searching in selection\n        // - the next match when starting search using ctrl + f\n        // `scroll` and `select` are disabled because `startQuery` is also used as\n        // \"restartQuery\" after each text change and if those were enabled, we would\n        // steal the cursor.\n        await this.highlightNext(true, {\n            from: 'selection-start',\n            scroll: false,\n            select: false\n        });\n        return Promise.resolve();\n    }\n    /**\n     * Stop the search and clear all internal state.\n     */\n    async endQuery() {\n        await Promise.all(this._searchProviders.map(provider => {\n            return provider.endQuery().then(() => {\n                provider.dispose();\n            });\n        }));\n        this._searchActive = false;\n        this._searchProviders.length = 0;\n        this._currentProviderIndex = null;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @param newText The replacement text.\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText, loop = true, options) {\n        let replaceOccurred = false;\n        const unrenderMarkdownCell = async (highlightNext = false) => {\n            var _a;\n            // Unrendered markdown cell\n            const activeCell = (_a = this.widget) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n            if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'markdown' &&\n                activeCell.rendered) {\n                activeCell.rendered = false;\n                if (highlightNext) {\n                    await this.highlightNext(loop);\n                }\n            }\n        };\n        if (this._currentProviderIndex !== null) {\n            await unrenderMarkdownCell();\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            replaceOccurred = await searchEngine.replaceCurrentMatch(newText, false, options);\n            if (searchEngine.currentMatchIndex === null) {\n                // switch to next cell\n                await this.highlightNext(loop, { from: 'previous-match' });\n            }\n        }\n        // TODO: markdown unrendering/highlighting sequence is likely incorrect\n        // Force highlighting the first hit in the unrendered cell\n        await unrenderMarkdownCell(true);\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @param newText The replacement text.\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText, options) {\n        const replacementOccurred = await Promise.all(this._searchProviders.map(provider => {\n            return provider.replaceAllMatches(newText, options);\n        }));\n        return replacementOccurred.includes(true);\n    }\n    async validateFilter(name, value) {\n        if (name !== 'output') {\n            // Bail early\n            return value;\n        }\n        // If value is true and some cells have never been rendered, ask confirmation.\n        if (value &&\n            this.widget.content.widgets.some(w => w instanceof CodeCell && w.isPlaceholder())) {\n            const trans = this.translator.load('jupyterlab');\n            const reply = await showDialog({\n                title: trans.__('Confirmation'),\n                body: trans.__('Searching outputs requires you to run all cells and render their outputs. Are you sure you want to search in the cell outputs?'),\n                buttons: [\n                    Dialog.cancelButton({ label: trans.__('Cancel') }),\n                    Dialog.okButton({ label: trans.__('Ok') })\n                ]\n            });\n            if (reply.button.accept) {\n                this.widget.content.widgets.forEach((w, i) => {\n                    if (w instanceof CodeCell && w.isPlaceholder()) {\n                        this.widget.content.renderCellOutputs(i);\n                    }\n                });\n            }\n            else {\n                return false;\n            }\n        }\n        return value;\n    }\n    _addCellProvider(index) {\n        var _a, _b;\n        const cell = this.widget.content.widgets[index];\n        const cellSearchProvider = createCellSearchProvider(cell);\n        ArrayExt.insert(this._searchProviders, index, cellSearchProvider);\n        void cellSearchProvider\n            .setIsActive(!((_b = (_a = this._filters) === null || _a === void 0 ? void 0 : _a.selection) !== null && _b !== void 0 ? _b : false) ||\n            this.widget.content.isSelectedOrActive(cell))\n            .then(() => {\n            if (this._searchActive) {\n                void cellSearchProvider.startQuery(this._query, this._filters);\n            }\n        });\n    }\n    _removeCellProvider(index) {\n        const provider = ArrayExt.removeAt(this._searchProviders, index);\n        provider === null || provider === void 0 ? void 0 : provider.dispose();\n    }\n    async _onCellsChanged(cells, changes) {\n        switch (changes.type) {\n            case 'add':\n                changes.newValues.forEach((model, index) => {\n                    this._addCellProvider(changes.newIndex + index);\n                });\n                break;\n            case 'move':\n                ArrayExt.move(this._searchProviders, changes.oldIndex, changes.newIndex);\n                break;\n            case 'remove':\n                for (let index = 0; index < changes.oldValues.length; index++) {\n                    this._removeCellProvider(changes.oldIndex);\n                }\n                break;\n            case 'set':\n                changes.newValues.forEach((model, index) => {\n                    this._addCellProvider(changes.newIndex + index);\n                    this._removeCellProvider(changes.newIndex + index + 1);\n                });\n                break;\n        }\n        this._stateChanged.emit();\n    }\n    async _stepNext(reverse = false, loop = false, options) {\n        var _a;\n        const activateNewMatch = async (match) => {\n            var _a;\n            const shouldScroll = (_a = options === null || options === void 0 ? void 0 : options.scroll) !== null && _a !== void 0 ? _a : true;\n            if (!shouldScroll) {\n                // do not activate the match if scrolling was disabled\n                return;\n            }\n            this._selectionLock = true;\n            if (this.widget.content.activeCellIndex !== this._currentProviderIndex) {\n                this.widget.content.activeCellIndex = this._currentProviderIndex;\n            }\n            if (this.widget.content.activeCellIndex === -1) {\n                console.warn('No active cell (no cells or no model), aborting search');\n                this._selectionLock = false;\n                return;\n            }\n            const activeCell = this.widget.content.activeCell;\n            if (!activeCell.inViewport) {\n                try {\n                    await this.widget.content.scrollToItem(this._currentProviderIndex);\n                }\n                catch (error) {\n                    // no-op\n                }\n            }\n            // Unhide cell\n            if (activeCell.inputHidden) {\n                activeCell.inputHidden = false;\n            }\n            if (!activeCell.inViewport) {\n                this._selectionLock = false;\n                // It will not be possible the cell is not in the view\n                return;\n            }\n            await activeCell.ready;\n            const editor = activeCell.editor;\n            editor.revealPosition(editor.getPositionAt(match.position));\n            this._selectionLock = false;\n        };\n        if (this._currentProviderIndex === null) {\n            this._currentProviderIndex = this.widget.content.activeCellIndex;\n        }\n        // When going to previous match in cell mode and there is no current we\n        // want to skip the active cell and go to the previous cell; in edit mode\n        // the appropriate behaviour is induced by searching from nearest cursor.\n        if (reverse && this.widget.content.mode === 'command') {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            const currentMatch = searchEngine.getCurrentMatch();\n            if (!currentMatch) {\n                this._currentProviderIndex -= 1;\n            }\n            if (loop) {\n                this._currentProviderIndex =\n                    (this._currentProviderIndex + this._searchProviders.length) %\n                        this._searchProviders.length;\n            }\n        }\n        // If we're looking for the next match after the previous match,\n        // and we've reached the end of the current cell, start at the next one, if possible\n        const from = (_a = options === null || options === void 0 ? void 0 : options.from) !== null && _a !== void 0 ? _a : '';\n        const atEndOfCurrentCell = from === 'previous-match' &&\n            this._searchProviders[this._currentProviderIndex].currentMatchIndex ===\n                null;\n        const startIndex = this._currentProviderIndex;\n        // If we need to move to the next cell or loop, reset the position of the current search provider.\n        if (atEndOfCurrentCell) {\n            void this._searchProviders[this._currentProviderIndex].clearHighlight();\n        }\n        // If we're at the end of the last cell in the provider list and we need to loop, do so\n        if (loop &&\n            atEndOfCurrentCell &&\n            this._currentProviderIndex + 1 >= this._searchProviders.length) {\n            this._currentProviderIndex = 0;\n        }\n        else {\n            this._currentProviderIndex += atEndOfCurrentCell ? 1 : 0;\n        }\n        do {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            const match = reverse\n                ? await searchEngine.highlightPrevious(false, options)\n                : await searchEngine.highlightNext(false, options);\n            if (match) {\n                await activateNewMatch(match);\n                return match;\n            }\n            else {\n                this._currentProviderIndex =\n                    this._currentProviderIndex + (reverse ? -1 : 1);\n                if (loop) {\n                    this._currentProviderIndex =\n                        (this._currentProviderIndex + this._searchProviders.length) %\n                            this._searchProviders.length;\n                }\n            }\n        } while (loop\n            ? // We looped on all cells, no hit found\n                this._currentProviderIndex !== startIndex\n            : 0 <= this._currentProviderIndex &&\n                this._currentProviderIndex < this._searchProviders.length);\n        if (loop) {\n            // try the first provider again\n            const searchEngine = this._searchProviders[startIndex];\n            const match = reverse\n                ? await searchEngine.highlightPrevious(false, options)\n                : await searchEngine.highlightNext(false, options);\n            if (match) {\n                await activateNewMatch(match);\n                return match;\n            }\n        }\n        this._currentProviderIndex = null;\n        return null;\n    }\n    async _onActiveCellChanged() {\n        if (this._delayedActiveCellChangeHandler !== null) {\n            // Prevent handler from running twice if active cell is changed twice\n            // within the same task of the event loop.\n            clearTimeout(this._delayedActiveCellChangeHandler);\n            this._delayedActiveCellChangeHandler = null;\n        }\n        if (this.widget.content.activeCellIndex !== this._currentProviderIndex) {\n            // At this time we cannot handle the change of active cell, because\n            // `activeCellChanged` is also emitted in the middle of cell selection\n            // change, and if selection is getting extended, we do not want to clear\n            // highlights just to re-apply them shortly after, which has side effects\n            // impacting the functionality and performance.\n            this._delayedActiveCellChangeHandler = window.setTimeout(() => {\n                this.delayedActiveCellChangeHandlerReady =\n                    this._handleHighlightsAfterActiveCellChange();\n            }, 0);\n        }\n        this._observeActiveCell();\n    }\n    async _handleHighlightsAfterActiveCellChange() {\n        if (this._onSelection) {\n            const previousProviderCell = this._currentProviderIndex !== null &&\n                this._currentProviderIndex < this.widget.content.widgets.length\n                ? this.widget.content.widgets[this._currentProviderIndex]\n                : null;\n            const previousProviderInCurrentSelection = previousProviderCell &&\n                this.widget.content.isSelectedOrActive(previousProviderCell);\n            if (!previousProviderInCurrentSelection) {\n                await this._updateCellSelection();\n                // Clear highlight from previous provider\n                await this.clearHighlight();\n                // If we are searching in all cells, we should not change the active\n                // provider when switching active cell to preserve current match;\n                // if we are searching within selected cells we should update\n                this._currentProviderIndex = this.widget.content.activeCellIndex;\n            }\n        }\n        await this._ensureCurrentMatch();\n    }\n    /**\n     * If there are results but no match is designated as current,\n     * mark a result as current and highlight it.\n     */\n    async _ensureCurrentMatch() {\n        if (this._currentProviderIndex !== null) {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            if (!searchEngine) {\n                // This can happen when `startQuery()` has not finished yet.\n                return;\n            }\n            const currentMatch = searchEngine.getCurrentMatch();\n            if (!currentMatch && this.matchesCount) {\n                // Select a match as current by highlighting next (with looping) from\n                // the selection start, to prevent \"current\" match from jumping around.\n                await this.highlightNext(true, {\n                    from: 'start',\n                    scroll: false,\n                    select: false\n                });\n            }\n        }\n    }\n    _observeActiveCell() {\n        var _a;\n        const editor = (_a = this.widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n        if (!editor) {\n            return;\n        }\n        this._stopObservingLastCell();\n        editor.model.selections.changed.connect(this._setSelectedLines, this);\n        this._editorSelectionsObservable = editor.model.selections;\n    }\n    _stopObservingLastCell() {\n        if (this._editorSelectionsObservable) {\n            this._editorSelectionsObservable.changed.disconnect(this._setSelectedLines, this);\n        }\n    }\n    _setSelectedLines() {\n        var _a;\n        const editor = (_a = this.widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n        if (!editor) {\n            return;\n        }\n        const selection = editor.getSelection();\n        const { start, end } = selection;\n        const newLines = end.line === start.line && end.column === start.column\n            ? 0\n            : end.line - start.line + 1;\n        this._textSelection = selection;\n        if (newLines !== this._selectedLines) {\n            this._selectedLines = newLines;\n            this._updateSelectionMode();\n        }\n        this._filtersChanged.emit();\n    }\n    /**\n     * Set whether the engines should search within selection only or full text.\n     */\n    async _setEnginesSelectionSearchMode() {\n        let textMode;\n        if (!this._onSelection) {\n            // When search in selection is off we always search full text\n            textMode = false;\n        }\n        else {\n            // When search in selection is off we either search in full cells\n            // (toggling off isActive flag on search engines of non-selected cells)\n            // or in selected text of the active cell.\n            textMode = this._selectionSearchMode === 'text';\n        }\n        if (this._selectionLock) {\n            return;\n        }\n        // Clear old selection restrictions or if relevant, set current restrictions for active provider.\n        await Promise.all(this._searchProviders.map((provider, index) => {\n            const isCurrent = this.widget.content.activeCellIndex === index;\n            provider.setProtectSelection(isCurrent && this._onSelection);\n            return provider.setSearchSelection(isCurrent && textMode ? this._textSelection : null);\n        }));\n    }\n    async _onCellSelectionChanged() {\n        if (this._delayedActiveCellChangeHandler !== null) {\n            // Avoid race condition due to `activeCellChanged` and `selectionChanged`\n            // signals firing in short sequence when selection gets extended, with\n            // handling of the former having potential to undo selection set by the latter.\n            clearTimeout(this._delayedActiveCellChangeHandler);\n            this._delayedActiveCellChangeHandler = null;\n        }\n        await this._updateCellSelection();\n        if (this._currentProviderIndex === null) {\n            // For consistency we set the first cell in selection as current provider.\n            const firstSelectedCellIndex = this.widget.content.widgets.findIndex(cell => this.widget.content.isSelectedOrActive(cell));\n            this._currentProviderIndex = firstSelectedCellIndex;\n        }\n        await this._ensureCurrentMatch();\n    }\n    async _updateCellSelection() {\n        const cells = this.widget.content.widgets;\n        let selectedCells = 0;\n        await Promise.all(cells.map(async (cell, index) => {\n            const provider = this._searchProviders[index];\n            const isSelected = this.widget.content.isSelectedOrActive(cell);\n            if (isSelected) {\n                selectedCells += 1;\n            }\n            if (provider && this._onSelection) {\n                await provider.setIsActive(isSelected);\n            }\n        }));\n        if (selectedCells !== this._selectedCells) {\n            this._selectedCells = selectedCells;\n            this._updateSelectionMode();\n        }\n        this._filtersChanged.emit();\n    }\n}\n//# sourceMappingURL=searchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The notebook widget factory token.\n */\nexport const INotebookWidgetFactory = new Token('@jupyterlab/notebook:INotebookWidgetFactory', 'A service to create the notebook viewer.');\n/**\n * The notebook tools token.\n */\nexport const INotebookTools = new Token('@jupyterlab/notebook:INotebookTools', `A service for the \"Notebook Tools\" panel in the\n  right sidebar. Use this to add your own functionality to the panel.`);\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token('@jupyterlab/notebook:INotebookTracker', `A widget tracker for notebooks.\n  Use this if you want to be able to iterate over and interact with notebooks\n  created by the application.`);\n/**\n * The notebook cell executor token.\n */\nexport const INotebookCellExecutor = new Token('@jupyterlab/notebook:INotebookCellExecutor', `The notebook cell executor`);\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookTracker extends WidgetTracker {\n    constructor() {\n        super(...arguments);\n        this._activeCell = null;\n        this._activeCellChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n    }\n    /**\n     * The currently focused cell.\n     *\n     * #### Notes\n     * This is a read-only property. If there is no cell with the focus, then this\n     * value is `null`.\n     */\n    get activeCell() {\n        const widget = this.currentWidget;\n        if (!widget) {\n            return null;\n        }\n        return widget.content.activeCell || null;\n    }\n    /**\n     * A signal emitted when the current active cell changes.\n     *\n     * #### Notes\n     * If there is no cell with the focus, then `null` will be emitted.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the selection state changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * Add a new notebook panel to the tracker.\n     *\n     * @param panel - The notebook panel being added.\n     */\n    add(panel) {\n        const promise = super.add(panel);\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n        return promise;\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Handle the current change event.\n     */\n    onCurrentChanged(widget) {\n        // Store an internal reference to active cell to prevent false positives.\n        const activeCell = this.activeCell;\n        if (activeCell && activeCell === this._activeCell) {\n            return;\n        }\n        this._activeCell = activeCell;\n        if (!widget) {\n            return;\n        }\n        // Since the notebook has changed, immediately signal an active cell change\n        this._activeCellChanged.emit(widget.content.activeCell || null);\n    }\n    _onActiveCellChanged(sender, cell) {\n        // Check if the active cell change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._activeCell = cell || null;\n            this._activeCellChanged.emit(this._activeCell);\n        }\n    }\n    _onSelectionChanged(sender) {\n        // Check if the selection change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n}\n//# sourceMappingURL=tracker.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { notTrustedIcon, trustedIcon, VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport React from 'react';\nconst TRUST_CLASS = 'jp-StatusItem-trust';\n/**\n * Determine the notebook trust status message.\n */\nfunction cellTrust(props, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    if (props.trustedCells === props.totalCells) {\n        return trans.__('Notebook trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n    else if (props.activeCellTrusted) {\n        return trans.__('Active cell trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n    else {\n        return trans.__('Notebook not trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n}\n/**\n * A pure function for a notebook trust status component.\n *\n * @param props the props for the component.\n *\n * @returns a tsx component for notebook trust.\n */\nfunction NotebookTrustComponent(props) {\n    if (props.allCellsTrusted) {\n        return React.createElement(trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n    else {\n        return React.createElement(notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n}\n/**\n * The NotebookTrust status item.\n */\nexport class NotebookTrustStatus extends VDomRenderer {\n    /**\n     * Construct a new status item.\n     */\n    constructor(translator) {\n        super(new NotebookTrustStatus.Model());\n        this.translator = translator || nullTranslator;\n        this.node.classList.add(TRUST_CLASS);\n    }\n    /**\n     * Render the NotebookTrust status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        const newTitle = cellTrust(this.model, this.translator);\n        if (newTitle !== this.node.title) {\n            this.node.title = newTitle;\n        }\n        return (React.createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells }));\n    }\n}\n/**\n * A namespace for NotebookTrust statics.\n */\n(function (NotebookTrustStatus) {\n    /**\n     * A VDomModel for the NotebookTrust status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._trustedCells = 0;\n            this._totalCells = 0;\n            this._activeCellTrusted = false;\n            this._notebook = null;\n        }\n        /**\n         * The number of trusted code cells in the current notebook.\n         */\n        get trustedCells() {\n            return this._trustedCells;\n        }\n        /**\n         * The total number of code cells in the current notebook.\n         */\n        get totalCells() {\n            return this._totalCells;\n        }\n        /**\n         * Whether the active cell is trusted.\n         */\n        get activeCellTrusted() {\n            return this._activeCellTrusted;\n        }\n        /**\n         * The current notebook for the model.\n         */\n        get notebook() {\n            return this._notebook;\n        }\n        set notebook(model) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);\n            }\n            const oldState = this._getAllState();\n            this._notebook = model;\n            if (this._notebook === null) {\n                this._trustedCells = 0;\n                this._totalCells = 0;\n                this._activeCellTrusted = false;\n            }\n            else {\n                // Add listeners\n                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                this._notebook.modelContentChanged.connect(this._onModelChanged, this);\n                // Derive values\n                if (this._notebook.activeCell) {\n                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;\n                }\n                else {\n                    this._activeCellTrusted = false;\n                }\n                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);\n                this._totalCells = total;\n                this._trustedCells = trusted;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the notebook model changes, update the trust state.\n         */\n        _onModelChanged(notebook) {\n            const oldState = this._getAllState();\n            const { total, trusted } = this._deriveCellTrustState(notebook.model);\n            this._totalCells = total;\n            this._trustedCells = trusted;\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the active cell changes, update the trust state.\n         */\n        _onActiveCellChanged(model, cell) {\n            const oldState = this._getAllState();\n            if (cell) {\n                this._activeCellTrusted = cell.model.trusted;\n            }\n            else {\n                this._activeCellTrusted = false;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Given a notebook model, figure out how many of the code cells are trusted.\n         */\n        _deriveCellTrustState(model) {\n            if (model === null) {\n                return { total: 0, trusted: 0 };\n            }\n            let total = 0;\n            let trusted = 0;\n            for (const cell of model.cells) {\n                if (cell.type !== 'code') {\n                    continue;\n                }\n                total++;\n                if (cell.trusted) {\n                    trusted++;\n                }\n            }\n            return { total, trusted };\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._trustedCells, this._totalCells, this.activeCellTrusted];\n        }\n        /**\n         * Trigger a change in the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] ||\n                oldState[1] !== newState[1] ||\n                oldState[2] !== newState[2]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    NotebookTrustStatus.Model = Model;\n})(NotebookTrustStatus || (NotebookTrustStatus = {}));\n//# sourceMappingURL=truststatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ABCWidgetFactory } from '@jupyterlab/docregistry';\nimport { NotebookPanel } from './panel';\nimport { StaticNotebook } from './widget';\nimport { NotebookHistory } from './history';\n/**\n * A widget factory for notebook panels.\n */\nexport class NotebookWidgetFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new notebook widget factory.\n     *\n     * @param options - The options used to construct the factory.\n     */\n    constructor(options) {\n        super(options);\n        this.rendermime = options.rendermime;\n        this.contentFactory = options.contentFactory;\n        this.mimeTypeService = options.mimeTypeService;\n        this._editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this._notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n    }\n    /**\n     * Create a new widget.\n     *\n     * #### Notes\n     * The factory will start the appropriate kernel.\n     */\n    createNewWidget(context, source) {\n        const translator = context.translator;\n        const kernelHistory = new NotebookHistory({\n            sessionContext: context.sessionContext,\n            translator: translator\n        });\n        const nbOptions = {\n            rendermime: source\n                ? source.content.rendermime\n                : this.rendermime.clone({ resolver: context.urlResolver }),\n            contentFactory: this.contentFactory,\n            mimeTypeService: this.mimeTypeService,\n            editorConfig: source ? source.content.editorConfig : this._editorConfig,\n            notebookConfig: source\n                ? source.content.notebookConfig\n                : this._notebookConfig,\n            translator,\n            kernelHistory\n        };\n        const content = this.contentFactory.createNotebook(nbOptions);\n        return new NotebookPanel({ context, content });\n    }\n}\n//# sourceMappingURL=widgetfactory.js.map"],"names":["async","cell","notebook","notebookConfig","onCellExecuted","onCellExecutionScheduled","sessionContext","sessionDialogs","translator","_a","trans","nullTranslator","load","model","type","rendered","inputHidden","success","isTerminating","showDialog","title","__","body","session","path","buttons","Dialog","okButton","pendingInput","hasNoKernel","startKernel","selectKernel","sharedModel","transact","clearExecution","deletedCells","ran","reply","CodeCell","execute","recordTiming","splice","length","isDisposed","content","status","payload","setNextInput","filter","i","source","text","replace","setSource","notebookModel","cells","index","findIndex","insertCell","cell_type","metadata","trusted","handlePayload","KernelError","reason","message","startsWith","error","Promise","resolve","JUPYTER_CELL_MIME","Error","constructor","errorContent","errorName","ename","errorValue","evalue","super","this","traceback","Object","setPrototypeOf","prototype","NotebookActions","executed","Private","executionScheduled","selectionExecuted","outputCleared","setCellExecutor","executor","move","shift","activeCell","state","getState","firstIndex","widgets","w","isSelectedOrActive","lastIndex","slice","moveCell","handleState","addCells","mode","values","cellsFromClipboard","prevActiveCellIndex","activeCellIndex","forEach","child","childIndex","toDelete","deletable","getMetadata","push","reverse","deleteCell","insertCells","map","id","lastClipboardInteraction","undefined","deselectAll","hideOutput","outputHidden","showOutput","setHeadingCollapse","collapsing","which","possibleCell","selectedHeadingInfo","getHeadingInfo","isHidden","MarkdownCell","isHeading","cellNum","localCollapsed","localCollapsedLevel","subCell","subCellHeadingInfo","headingLevel","setHidden","collapsed","numberChildNodes","setCellCollapse","level","headingInfo","headingCollapsed","focusActiveCell","options","waitUntilReady","preventScroll","ready","node","focus","splitCell","nbModel","editor","selections","getSelections","orig","getSource","offsets","start","end","getOffsetAt","cellCountAfterSplit","clones","offset","offsetIdx","outputs","toJSON","activeCellDelta","scrollToItem","then","catch","mergeCells","mergeAbove","toMerge","primary","active","attachments","isRawCellModel","isMarkdownCellModel","key","keys","get","cellModel","unshift","primaryModel","newModel","join","sort","a","b","deleteCells","insertAbove","newIndex","defaultCell","insertBelow","moveDown","moveUp","changeCellType","value","run","promise","runSelected","handleRunState","runCells","runAndAdvance","inViewport","signalToPromise","inViewportChanged","runAndInsert","runAll","renderAllMarkdown","previousIndex","select","runAllAbove","runAllBelow","replaceSelection","_b","_c","call","selectAbove","footer","layout","document","activeElement","blur","possibleNextCellIndex","possibleNextCell","selectBelow","maxCellIndex","insertSameLevelHeadingAbove","Headings","determineHeadingLevel","insertHeadingAboveCellIndex","insertSameLevelHeadingBelow","cellIdxOfHeadingBelow","findLowerEqualLevelHeadingBelow","selectHeadingAboveOrCollapseHeading","hInfoActiveCell","targetHeadingCellIdx","findLowerEqualLevelParentHeadingAbove","selectHeadingBelowOrExpandHeading","hInfo","findHeadingBelow","extendSelectionAbove","toTop","extendContiguousSelectionTo","extendSelectionBelow","toBottom","selectAll","copy","copyOrCut","cut","paste","clipboard","Clipboard","getInstance","hasData","getData","duplicate","selectedCells","undo","redo","toggleAllLineNumbers","config","editorConfig","lineNumbers","code","markdown","raw","newConfig","clearOutputs","emit","clearAllOutputs","hideCode","showCode","hideAllCode","showAllCode","toggleOutput","hideAllOutputs","renderSideBySide","renderingLayout","renderDefault","showAllOutputs","enableOutputScrolling","outputsScrolled","disableOutputScrolling","selectLastRunCell","latestTime","latestCellIdx","cellIndx","execution","JSONExt","isObject","timestamp","toString","startTime","Date","setMarkdownHeader","Math","min","max","collapseAllHeadings","expandAllHeadings","expandParent","nearestParentCell","childHeaderInfo","cellN","findNearestParentHeader","findNextParentHeading","toggleCurrentHeadingCollapse","trust","every","trustMessage","href","target","rel","cancelButton","warnButton","label","ariaLabel","result","button","accept","accessPreviousHistory","accessKernelHistory","kernelHistory","previousHistory","back","updateEditor","accessNextHistory","nextHistory","forward","wasFocused","contains","activeCellId","scrollIfNeeded","activate","lastCell","initializingDialogShown","all","enableKernelInitNotification","kernelDisplayStatus","Notification","kernelDisplayName","autoClose","console","warn","args","runCell","results","update","executionCount","executionState","Signal","alignPreference","selected","cellJSON","clear","data","setData","notebookSharedModel","outputArea","newCell","includes","newHeader","Array","matches","exec","findParentHeading","childCell","includeChildCell","returnIndex","cellIdx","indexOf","baseCell","baseHeadingLevel","headingInfoBaseCell","parentHeading","cellIndex","repeat","CellList","_cellMap","WeakMap","_changed","_isDisposed","_insertCells","changed","connect","_onSharedModelChanged","Symbol","iterator","dispose","clearData","CodeCellModel","MarkdownCellModel","RawCellModel","set","disposed","delete","self","change","currpos","events","cellsChange","delta","insert","newValues","c","oldIndex","oldValues","fill","retain","msg","ToolbarItems","createSaveButton","panel","onClick","context","readOnly","save","createCheckpoint","addToolbarButtonClass","ReactWidget","create","UseSignal","signal","fileChanged","ToolbarButtonComponent","icon","saveIcon","tooltip","enabled","contentsModel","writable","createInsertButton","ToolbarButton","addIcon","createCutButton","cutIcon","createCopyButton","copyIcon","createPasteButton","pasteIcon","createRunButton","runIcon","createRestartRunAllButton","dialogs","fastForwardIcon","dialogs_","SessionContextDialogs","restart","restarted","createCellTypeItem","CellTypeSwitcher","getDefaultItems","name","widget","createInterruptButton","createRestartButton","Toolbar","createSpacerItem","createKernelNameItem","handleChange","event","_notebook","handleKeyDown","keyCode","_trans","addClass","activeCellChanged","selectionChanged","render","HTMLSelect","className","onChange","onKeyDown","ExecutionIndicatorComponent","props","kernelStatuses","translateKernelStatuses","showOnToolBar","displayOption","showProgress","tooltipClass","emptyDiv","kernelStatus","circleIconProps","alignSelf","height","time","totalTime","scheduledCellNumber","executedCellNumber","scheduledCell","size","percentage","displayClass","progressBar","ProgressCircle","progress","width","titleFactory","translatedStatus","reactElement","circle","popup","offlineBoltIcon","react","circleIcon","executionStatus","_n","ExecutionIndicator","VDomRenderer","Model","renderFlag","nb","currentNotebook","VDomModel","_notebookExecutionProgress","_displayOption","_renderFlag","attachNotebook","_d","_currentNotebook","has","interval","timeout","Set","needReset","contextStatusChanged","ctx","stateChanged","statusChanged","contextConnectionStatusChanged","connectionStatusChanged","disconnect","handleKernelMsg","sender","msgId","header","msg_id","msg_type","_cellScheduledCallback","KernelMessage","isStatusMsg","execution_state","parentId","parent_header","_cellExecutedCallback","_restartHandler","_startTimer","kernel","anyMessage","kernelChangedSlot","_","kernelData","_resetTime","newValue","kernelChanged","_scheduleSwitchToIdle","window","setTimeout","clearInterval","clearTimeout","setInterval","_tick","add","updateRenderOption","getSettingValue","settings","configValues","composite","showOnStatusBar","createExecutionIndicatorItem","loadSettings","toolbarItem","updateSettings","newSettings","NotebookHistory","_requestBatchSize","_cursor","_hasSession","_history","_placeholder","_kernelSession","_setByHistory","_editor","_filtered","_kernel","_sessionContext","_handleKernel","_toRequest","prev","onTextChange","placeholder","kernelSession","checkSession","_retrieveHistory","setFilter","fetchBatch","columnPos","setCursorPosition","line","column","reset","oldFilteredReversed","oldHistory","cursorOffset","filteredReversed","item","ij","onHistory","last","current","history","n","requestHistory","output","hist_access_type","v","filterStr","NotebookModel","standaloneModel","_dirty","_readOnly","_contentChanged","_stateChanged","_metadataChanged","YNotebook","disableDocumentWideUndoRedo","nbformat","nbformat_minor","kernelspec","display_name","language_info","languagePreference","_cells","_deletedCells","_collaborationEnabled","collaborationEnabled","_onCellsChanged","_onStateChanged","metadataChanged","_onMetadataChanged","contentChanged","dirty","oldValue","triggerStateChange","nbformatMinor","defaultKernelName","spec","defaultKernelLanguage","info","collaborative","deleteMetadata","setMetadata","JSON","stringify","fromString","fromJSON","parse","_ensureMetadata","deepCopy","origNbformat","orig_nbformat","list","triggerContentChange","changes","stateChange","languageName","NotebookModelFactory","_disposed","_disableDocumentWideUndoRedo","_collaborative","contentType","fileFormat","createNew","preferredLanguage","CommandEditComponent","TextItem","modeNames","notebookMode","CommandEditStatus","_modeNames","command","edit","arguments","_onChanged","oldMode","_notebookMode","_triggerChange","oldNotebook","modelContentChanged","oldState","newState","NotebookAdapter","WidgetLSPAdapter","editorWidget","_type","_readyDelegate","PromiseDelegate","_editorToCell","Map","_cellToEditor","connectionManager","initOnceReady","documentPath","mimeType","languageMetadata","mimetype","codeMimetype","isArray","IEditorMimeTypeService","defaultMimeType","languageFileExtension","file_extension","wrapperElement","editors","ceEditor","_getCellEditor","activeEditor","getEditorIndexAt","position","_getCellAt","otherCell","getEditorIndex","getEditorWrapper","onKernelChanged","_session","oldLanguageInfo","_languageInfo","untilReady","isReady","_updateLanguageInfo","newLanguageInfo","log","reloadConnection","err","_activeCellChanged","isVisible","handleCellChange","cellsAdded","cellsRemoved","convertedToMarkdownOrRaw","convertedToCode","updateDocuments","cellWidget","find","createVirtualDocument","VirtualDocument","language","foreignCodeExtractors","foreignCodeExtractorsManager","fileExtension","standalone","hasLspSupportedFile","bind","initVirtual","connectDocument","virtualDocument","_connectModelSignals","modelChanged","_activeEditorChanged","pos","getEditorAtVirtualLine","freeze","getEditor","reveal","scrollToCell","_editorRemoved","_editorAdded","RankedPanel","Widget","_items","PanelLayout","addWidget","rank","rankItem","ArrayExt","upperBound","itemCmp","insertWidget","onChildRemoved","findFirstIndex","removeAt","NotebookTools","_tools","_tracker","tracker","currentChanged","_onActiveNotebookPanelChanged","_onActiveCellChanged","_onSelectionChanged","currentWidget","activeNotebookPanel","addItem","tool","section","extendedTool","notebookTools","MessageLoop","sendMessage","ActiveNotebookPanelMessage","ActiveCellMessage","addSection","sectionName","newSection","Collapser","advancedToolsRank","_prevActiveNotebookModel","_onActiveNotebookPanelMetadataChanged","activeNBModel","_toolChildren","_prevActiveCell","_onActiveCellMetadataChanged","SelectionMessage","ObservableJSON","ChangeMessage","children","ConflatableMessage","Tool","processMessage","onActiveNotebookPanelChanged","onActiveCellChanged","onSelectionChanged","onActiveCellMetadataChanged","onActiveNotebookPanelMetadataChanged","MetadataEditorTool","editorFactory","_editorFactory","_editorLabel","createEditor","titleNode","createElement","textContent","JSONEditor","first","second","DROP_TARGET_CLASS","DROP_SOURCE_CLASS","NotebookViewModel","WindowedListModel","estimateWidgetSize","cellsEstimatedHeight","nLines","split","outputsLines","outputIdx","DEFAULT_EDITOR_LINE_HEIGHT","DEFAULT_CELL_MARGIN","widgetRenderer","scrollDownThreshold","scrollUpThreshold","_emitEstimatedHeightChanged","Debouncer","_estimatedWidgetSize","DEFAULT_CELL_SIZE","setEstimatedWidgetSize","cellId","invoke","NotebookWindowedLayout","WindowedLayout","_header","_footer","_willBeRemoved","_topHiddenCodeCells","isAttached","detach","parent","attach","outerNode","_activeCell","removeWidget","removeWidgetAt","detachWidget","attachWidget","wasPlaceholder","isPlaceholder","isSoftHidden","_isSoftHidden","Msg","BeforeAttach","_toggleSoftVisibility","parentElement","style","display","siblingIndex","_findNearestChildBinarySearch","viewportNode","childElementCount","parseInt","dataset","windowedListIndex","ref","insertBefore","AfterAttach","classList","BeforeDetach","removeChild","remove","AfterDetach","moveWidget","fromIndex","toIndex","idx","insertAdjacentElement","onAfterAttach","firstElementChild","onBeforeDetach","show","opacity","padding","high","low","middle","floor","currentIndex","NotebookFooter","setAttribute","innerText","handleEvent","onArrowUp","addEventListener","removeEventListener","NB_CELL_CLASS","EDIT_CLASS","COMMAND_CLASS","ACTIVE_CLASS","SELECTED_CLASS","DIRTY_CLASS","OTHER_SELECTED_CLASS","DRAG_IMAGE_CLASS","SINGLE_DRAG_IMAGE_CLASS","CELL_DRAG_CONTENT_CLASS","CELL_DRAG_PROMPT_CLASS","CELL_DRAG_MULTIPLE_BACK","SIDE_BY_SIDE_CLASS","requestIdleCallback","handler","now","didTimeout","timeRemaining","cancelIdleCallback","StaticNotebook","WindowedList","_e","_f","windowingActive","windowingMode","defaultNotebookConfig","overscanCount","renderer","defaultRenderer","scrollbar","_cellCollapsed","_cellInViewportChanged","_renderingLayoutChanged","cellsArray","_idleCallBack","_editorConfig","defaultEditorConfig","_notebookConfig","_mimetype","_notebookModel","_modelChanged","_modelContentChanged","rendermime","contentFactory","_updateNotebookConfig","_mimetypeService","mimeTypeService","cellCollapsed","cellInViewportChanged","renderingLayoutChanged","_onModelChanged","onModelChanged","viewModel","itemsList","_updateEditorConfig","_renderingLayout","from","to","boundedTo","dirtyState","oldCell","k","oldCodeCell","isDirty","moveCells","view","renderCellOutputs","requestAnimationFrame","addHeader","removeHeader","onModelContentChanged","onMetadataChanged","_updateMimetype","onCellInserted","onCellRemoved","onUpdateRequest","_runOnIdleTime","_removeCell","_insertCell","_updateDataWindowedListIndex","_createCodeCell","_createMarkdownCell","_createRawCell","_onCellInViewportChanged","_scheduleCellRenderOnIdle","inputHistoryScope","maxNumberOutputs","createCodeCell","syncCollapse","syncEditable","syncScrolled","inputRequested","stdin","_onInputRequested","showEditorForReadOnlyMarkdown","createMarkdownCell","headingCollapsedChanged","_onCellCollapsed","createRawCell","getMimeTypeByLanguage","inputEl","querySelector","ElementExt","scrollIntoViewIfNeeded","deadline","globalIndex","updateEditorConfig","remainingTime","_updateForDeferMode","getBoundingClientRect","clientHeight","toggleClass","scrollPastEnd","showHiddenCellsButton","showEditorForReadOnly","lineWrap","matchBrackets","tabFocusable","sideBySideLeftMarginOverride","sideBySideRightMarginOverride","sideBySideOutputRatio","ContentFactory","Cell","initializeState","RawCell","ScrollbarItem","_element","_createElement","_updateActive","_updateSelection","_model","_updatePrompt","_updateState","trimmedSource","substring","_source","_updateDirty","hasError","_executionIndicator","li","wasActive","wasSelected","some","executionIndicator","append","Notebook","createOuter","createViewport","el","createScrollbar","createScrollbarViewportIndicator","createScrollbarItem","_index","_activeCellIndex","_mode","_drag","_dragData","_selectData","_mouseMode","_selectionChanged","_checkCacheOnNextResize","_lastClipboardInteraction","_selectedCells","_updateSelectedCells","jumped","addFooter","newActiveCellIndex","getId","setMode","setFocus","_ensureFocus","deselect","cellChanged","_trimSelections","isSelected","selectedProperty","head","anchor","getContiguousSelection","findLastIndex","activeIndex","align","r","_parseFragment","fragment","cleanedFragment","parts","kind","setFragment","parsedFragment","_findHeading","_findCellById","element","widgetBox","elementBox","top","bottom","scrollIntoView","block","eventPhase","Event","CAPTURING_PHASE","_evtContextMenuCapture","_evtMouseDownCapture","defaultPrevented","_evtMouseDown","currentTarget","_evtDocumentMouseup","_evtDocumentMousemove","_evtDblClick","_evtFocusIn","_evtFocusOut","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","onBeforeAttach","onAfterShow","onResize","cache","_cellLayoutStateCache","onBeforeHide","onActivateRequest","removeClass","count","tabIndex","edgeRequested","_onEdgeRequest","scrollRequested","_emitter","scrollRequest","scroller","scrollWithinCell","location","lastLine","lineCount","force","hasFocus","_findCell","_findEventTargetAndCell","elementFromPoint","clientX","clientY","queryId","heading","headings","HeadingType","HTML","Markdown","mdHeading","TableOfContentsUtils","getHeadingId","markdownParser","sanitizer","CSS","escape","shiftKey","preventDefault","targetArea","promptNode","hasSelection","getSelection","tagName","pressX","pressY","e","startedOnActiveCell","startingCellIndex","shouldPreventDefault","stopPropagation","dx","abs","dy","_startDrag","mimeData","elements","getElementsByClassName","dropAction","proposedAction","toMove","nextParent","firstIndexOf","countString","dragImage","createDragImage","Drag","MimeData","supportedActions","action","_updateReadWrite","inReadWrite","DOMUtils","hasActiveEditableElement","toggle","relatedTarget","localName","uuid","AttachedProperty","NotebookPanelLayout","promptNumber","cellContent","VirtualDOM","realize","h","div","span","NotebookPanel","DocumentWidget","_autorestarting","toolbar","_onKernelChanged","_onSessionStatusChanged","saveState","_onSave","revealed","setConfig","kernelPreference","shutdownOnDispose","kernelShutdown","autoStartDefault","Printing","symbol","printURL","PageConfig","getNBConvertURL","format","download","isParentHidden","onBeforeShow","_updateLanguage","_updateSpec","createNotebook","IContentFactory","Token","RunningStatus","NotebookSearchProvider","SearchProvider","_textSelection","_currentProviderIndex","_delayedActiveCellChangeHandler","_onSelection","_selectedLines","_query","_searchProviders","_editorSelectionsObservable","_selectionSearchMode","_selectionLock","_searchActive","_handleHighlightsAfterActiveCellChange","_onCellSelectionChanged","_onNotebookStateChanged","_observeActiveCell","_filtersChanged","_setEnginesSelectionSearchMode","closest","_updateSelectionMode","isApplicable","domain","currentMatchIndex","agg","found","provider","localMatch","matchesCount","reduce","sum","isReadOnly","replaceOptionsSupport","preserveCase","getSelectionState","cellMode","selectedCount","_stopObservingLastCell","endQuery","getFilters","description","disabledDescription","default","supportReplace","selection","getInitialQuery","clearHighlight","highlightNext","loop","match","_stepNext","highlightPrevious","startQuery","query","filters","_filters","currentProviderIndex","cellSearchProvider","createCellSearchProvider","setIsActive","setSearchSelection","scroll","replaceCurrentMatch","newText","replaceOccurred","unrenderMarkdownCell","searchEngine","replaceAllMatches","validateFilter","_addCellProvider","_removeCellProvider","activateNewMatch","revealPosition","getPositionAt","getCurrentMatch","atEndOfCurrentCell","startIndex","delayedActiveCellChangeHandlerReady","previousProviderCell","_updateCellSelection","_ensureCurrentMatch","_setSelectedLines","newLines","textMode","isCurrent","setProtectSelection","firstSelectedCellIndex","NotebookToCModel","TableOfContentsModel","parser","configuration","configMetadataMap","numberHeaders","numberingH1","baseNumbering","_runningCells","_errorCells","_cellToHeadingIndex","setConfiguration","onExecutionScheduled","onExecuted","onOutputCleared","headingsChanged","onHeadingsChanged","documentType","isAlwaysActive","supportedOptions","getCellHeadings","headingIndex","candidate","cellRef","metadataConfig","loadConfigurationFromMetadata","toggleCollapse","updateRunningStatus","getHeadings","documentLevels","syncCollapseState","includeOutput","filterHeadings","isRunning","Idle","cellHeadings","minLevel","isHeadingEqual","heading1","heading2","option","negate","keyPath","p","activeHeading","setActiveHeading","Running","Scheduled","maxIsRunning","getMaxIsRunning","collapsedLevel","NotebookToCFactory","TableOfContentsFactory","_scrollToTop","scrollToTop","_createNew","headingToElement","onActiveHeadingChanged","onCellInViewport","debug","findHeadingElement","elementId","getIdForHeading","selector","outputIndex","addPrefix","prefix","clearNumbering","onHeadingCollapsed","collapseState","onCellCollapsed","onCellInViewportChanged","activeHeadingChanged","collapseChanged","INotebookWidgetFactory","INotebookTools","INotebookTracker","INotebookCellExecutor","NotebookTracker","WidgetTracker","onCurrentChanged","NotebookTrustComponent","allCellsTrusted","trustedIcon","stylesheet","notTrustedIcon","NotebookTrustStatus","newTitle","trustedCells","totalCells","activeCellTrusted","cellTrust","_trustedCells","_totalCells","_activeCellTrusted","_getAllState","total","_deriveCellTrustState","NotebookWidgetFactory","ABCWidgetFactory","createNewWidget","nbOptions","clone","resolver","urlResolver"],"sourceRoot":""}