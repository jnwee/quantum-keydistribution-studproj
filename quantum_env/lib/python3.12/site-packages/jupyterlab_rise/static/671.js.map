{"version":3,"file":"671.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/handler.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/reconciliator.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/default/contextprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/default/kernelprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/ghost.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/inline.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/manager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/icons.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/completer/lib/default/inlinehistoryprovider.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The type of completion request.\n */\nexport var CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoked\"] = 1] = \"Invoked\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 3] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\n/**\n * Describes how an inline completion provider was triggered.\n * @alpha\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\n/**\n * Token allowing to override (or disable) inline completer widget factory.\n */\nexport const IInlineCompleterFactory = new Token('@jupyterlab/completer:IInlineCompleterFactory', 'A factory of inline completer widgets.');\n/**\n * The exported token used to register new provider.\n */\nexport const ICompletionProviderManager = new Token('@jupyterlab/completer:ICompletionProviderManager', 'A service for the completion providers management.');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { COMPLETER_ACTIVE_CLASS, COMPLETER_ENABLED_CLASS, COMPLETER_LINE_BEGINNING_CLASS } from '@jupyterlab/codeeditor';\nimport { Text } from '@jupyterlab/coreutils';\nimport { Message, MessageLoop } from '@lumino/messaging';\nimport { Signal } from '@lumino/signaling';\nimport { CompletionTriggerKind, InlineCompletionTriggerKind } from './tokens';\n/**\n * A completion handler for editors.\n */\nexport class CompletionHandler {\n    /**\n     * Construct a new completion handler for a widget.\n     */\n    constructor(options) {\n        this._fetchingInline = 0;\n        this._editor = null;\n        this._enabled = false;\n        this._isDisposed = false;\n        this._autoCompletion = false;\n        this._continuousInline = true;\n        this._tabCompleterActive = false;\n        this.completer = options.completer;\n        this.inlineCompleter = options.inlineCompleter;\n        this.completer.selected.connect(this.onCompletionSelected, this);\n        this.completer.visibilityChanged.connect(this.onVisibilityChanged, this);\n        this._reconciliator = options.reconciliator;\n    }\n    set reconciliator(reconciliator) {\n        this._reconciliator = reconciliator;\n    }\n    /**\n     * The editor used by the completion handler.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        if (newValue === this._editor) {\n            return;\n        }\n        let editor = this._editor;\n        // Clean up and disconnect from old editor.\n        if (editor && !editor.isDisposed) {\n            const model = editor.model;\n            editor.host.classList.remove(COMPLETER_ENABLED_CLASS);\n            editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);\n            model.selections.changed.disconnect(this.onSelectionsChanged, this);\n            model.sharedModel.changed.disconnect(this._onSharedModelChanged, this);\n        }\n        // Reset completer state.\n        this.completer.reset();\n        this.completer.editor = newValue;\n        // Update the editor and signal connections.\n        editor = this._editor = newValue;\n        if (editor) {\n            const model = editor.model;\n            this._enabled = false;\n            model.selections.changed.connect(this.onSelectionsChanged, this);\n            // We expect the model to be an editor, a file editor, or a cell.\n            const sharedModel = model.sharedModel;\n            // For cells and files the `changed` signal is not limited to text,\n            // but also fires on changes to metadata, outputs, execution count,\n            // and state changes, hence we need to filter the change type.\n            sharedModel.changed.connect(this._onSharedModelChanged, this);\n            // On initial load, manually check the cursor position.\n            this.onSelectionsChanged();\n            if (this.inlineCompleter) {\n                this.inlineCompleter.editor = editor;\n            }\n        }\n    }\n    /**\n     * Get whether the completion handler is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Enable/disable continuous hinting mode.\n     */\n    set autoCompletion(value) {\n        this._autoCompletion = value;\n    }\n    get autoCompletion() {\n        return this._autoCompletion;\n    }\n    /**\n     * Dispose of the resources used by the handler.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Invoke the inline completer on explicit user request.\n     */\n    invokeInline() {\n        const editor = this._editor;\n        if (editor) {\n            this._makeInlineRequest(editor.getCursorPosition(), InlineCompletionTriggerKind.Invoke).catch(reason => {\n                console.warn('Inline invoke request bailed', reason);\n            });\n        }\n    }\n    /**\n     * Invoke the handler and launch a completer.\n     */\n    invoke() {\n        MessageLoop.sendMessage(this, CompletionHandler.Msg.InvokeRequest);\n    }\n    /**\n     * Process a message sent to the completion handler.\n     */\n    processMessage(msg) {\n        switch (msg.type) {\n            case CompletionHandler.Msg.InvokeRequest.type:\n                this.onInvokeRequest(msg);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Get the state of the text editor at the given position.\n     */\n    getState(editor, position) {\n        return {\n            text: editor.model.sharedModel.getSource(),\n            line: position.line,\n            column: position.column\n        };\n    }\n    /**\n     * Handle a completion selected signal from the completion widget.\n     */\n    onCompletionSelected(completer, val) {\n        const model = completer.model;\n        const editor = this._editor;\n        if (!editor || !model) {\n            return;\n        }\n        const patch = model.createPatch(val);\n        if (!patch) {\n            return;\n        }\n        const { start, end, value } = patch;\n        const cursorBeforeChange = editor.getOffsetAt(editor.getCursorPosition());\n        // Update the document and the cursor position in the same transaction\n        // to ensure consistency in listeners to document changes.\n        // Note: it also ensures a single change is stored by the undo manager.\n        const transactions = {\n            changes: { from: start, to: end, insert: value }\n        };\n        if (cursorBeforeChange <= end && cursorBeforeChange >= start) {\n            transactions.selection = { anchor: start + value.length };\n        }\n        editor.editor.dispatch(transactions);\n    }\n    /**\n     * Handle `invoke-request` messages.\n     */\n    onInvokeRequest(msg) {\n        // If there is no completer model, bail.\n        if (!this.completer.model) {\n            return;\n        }\n        // If a completer session is already active, bail.\n        if (this.completer.model.original) {\n            return;\n        }\n        const editor = this._editor;\n        if (editor) {\n            this._makeRequest(editor.getCursorPosition(), CompletionTriggerKind.Invoked).catch(reason => {\n                console.warn('Invoke request bailed', reason);\n            });\n        }\n    }\n    /**\n     * Handle selection changed signal from an editor.\n     *\n     * #### Notes\n     * If a sub-class reimplements this method, then that class must either call\n     * its super method or it must take responsibility for adding and removing\n     * the completer completable class to the editor host node.\n     *\n     * Despite the fact that the editor widget adds a class whenever there is a\n     * primary selection, this method checks independently for two reasons:\n     *\n     * 1. The editor widget connects to the same signal to add that class, so\n     *    there is no guarantee that the class will be added before this method\n     *    is invoked so simply checking for the CSS class's existence is not an\n     *    option. Secondarily, checking the editor state should be faster than\n     *    querying the DOM in either case.\n     * 2. Because this method adds a class that indicates whether completer\n     *    functionality ought to be enabled, relying on the behavior of the\n     *    `jp-mod-has-primary-selection` to filter out any editors that have\n     *    a selection means the semantic meaning of `jp-mod-completer-enabled`\n     *    is obscured because there may be cases where the enabled class is added\n     *    even though the completer is not available.\n     */\n    onSelectionsChanged() {\n        var _a;\n        const model = this.completer.model;\n        const editor = this._editor;\n        if (!editor) {\n            return;\n        }\n        const inlineModel = (_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.model;\n        if (inlineModel) {\n            // Dispatch selection change.\n            inlineModel.handleSelectionChange(editor.getSelection());\n        }\n        const host = editor.host;\n        // If there is no model, return.\n        if (!model) {\n            this._enabled = false;\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        // If we are currently performing a subset match,\n        // return without resetting the completer.\n        if (model.subsetMatch) {\n            return;\n        }\n        const position = editor.getCursorPosition();\n        const line = editor.getLine(position.line);\n        const { start, end } = editor.getSelection();\n        // If there is a text selection, return.\n        if (start.column !== end.column || start.line !== end.line) {\n            this._enabled = false;\n            model.reset(true);\n            host.classList.remove(COMPLETER_ENABLED_CLASS);\n            return;\n        }\n        // If line is empty or the cursor doesn't have any characters before\n        // it besides whitespace, add line beginning class\n        // so that completer can stay enabled, but tab\n        // in codemirror can still be triggered.\n        if (!line || end.column === 0) {\n            host.classList.add(COMPLETER_LINE_BEGINNING_CLASS);\n        }\n        else if (line && line.slice(0, position.column).match(/^\\s*$/)) {\n            host.classList.add(COMPLETER_LINE_BEGINNING_CLASS);\n        }\n        else {\n            host.classList.remove(COMPLETER_LINE_BEGINNING_CLASS);\n        }\n        // Enable completion.\n        if (!this._enabled) {\n            this._enabled = true;\n            host.classList.add(COMPLETER_ENABLED_CLASS);\n        }\n        // Dispatch the cursor change.\n        model.handleCursorChange(this.getState(editor, editor.getCursorPosition()));\n    }\n    /**\n     * Handle a text changed signal from an editor.\n     */\n    async onTextChanged(str, changed) {\n        var _a;\n        if (!this._enabled) {\n            return;\n        }\n        const model = this.completer.model;\n        const editor = this.editor;\n        if (!editor) {\n            return;\n        }\n        if (model &&\n            this._autoCompletion &&\n            this._reconciliator.shouldShowContinuousHint &&\n            (await this._reconciliator.shouldShowContinuousHint(this.completer.isVisible, changed))) {\n            void this._makeRequest(editor.getCursorPosition(), CompletionTriggerKind.TriggerCharacter);\n        }\n        const inlineModel = (_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.model;\n        if (inlineModel) {\n            // Dispatch the text change to inline completer\n            // (this happens before request is sent)\n            inlineModel.handleTextChange(changed);\n            if (this._continuousInline) {\n                void this._makeInlineRequest(editor.getCursorPosition(), InlineCompletionTriggerKind.Automatic);\n            }\n        }\n        if (model) {\n            // If there is a text selection, no completion is allowed.\n            const { start, end } = editor.getSelection();\n            if (start.column !== end.column || start.line !== end.line) {\n                return;\n            }\n            // Dispatch the text change.\n            model.handleTextChange(this.getState(editor, editor.getCursorPosition()));\n        }\n    }\n    /**\n     * Handle a visibility change signal from a completer widget.\n     */\n    onVisibilityChanged(completer) {\n        var _a;\n        // Completer is not active.\n        if (completer.isDisposed || completer.isHidden) {\n            this._tabCompleterActive = false;\n            if (this._editor) {\n                this._editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);\n                this._editor.focus();\n            }\n            return;\n        }\n        // Completer is active.\n        this._tabCompleterActive = true;\n        (_a = this._editor) === null || _a === void 0 ? void 0 : _a.host.classList.add(COMPLETER_ACTIVE_CLASS);\n    }\n    /**\n     * Handle a text shared model change signal from an editor.\n     */\n    async _onSharedModelChanged(str, changed) {\n        if (changed.sourceChange) {\n            await this.onTextChanged(str, changed);\n        }\n    }\n    /**\n     * Make a completion request.\n     */\n    _makeRequest(position, trigger) {\n        const editor = this.editor;\n        if (!editor) {\n            return Promise.reject(new Error('No active editor'));\n        }\n        const request = this._composeRequest(editor, position);\n        const state = this.getState(editor, position);\n        return this._reconciliator\n            .fetch(request, trigger)\n            .then(reply => {\n            var _a;\n            if (!reply) {\n                return;\n            }\n            const model = this._updateModel(state, reply.start, reply.end);\n            if (!model) {\n                return;\n            }\n            if (this.completer.suppressIfInlineCompleterActive &&\n                ((_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.isActive)) {\n                return;\n            }\n            if (model.setCompletionItems) {\n                model.setCompletionItems(reply.items);\n            }\n        })\n            .catch(p => {\n            /* Fails silently. */\n        });\n    }\n    async _makeInlineRequest(position, trigger) {\n        const editor = this.editor;\n        if (!editor) {\n            return Promise.reject(new Error('No active editor'));\n        }\n        if (!this.inlineCompleter) {\n            return Promise.reject(new Error('No inline completer'));\n        }\n        const line = editor.getLine(position.line);\n        if (trigger === InlineCompletionTriggerKind.Automatic &&\n            (typeof line === 'undefined' ||\n                position.column < line.length ||\n                line.slice(0, position.column).match(/^\\s*$/))) {\n            // In Automatic mode we only auto-trigger on the end of line (and not on the beginning).\n            // Increase the counter to avoid out-of date replies when pressing Backspace quickly.\n            this._fetchingInline += 1;\n            return;\n        }\n        const request = this._composeRequest(editor, position);\n        const model = this.inlineCompleter.model;\n        if (!model) {\n            return;\n        }\n        model.cursor = position;\n        const current = ++this._fetchingInline;\n        const promises = this._reconciliator.fetchInline(request, trigger);\n        let cancelled = false;\n        const completed = new Set();\n        for (const promise of promises) {\n            promise\n                .then(result => {\n                var _a;\n                if (cancelled || !result || !result.items) {\n                    return;\n                }\n                if (current !== this._fetchingInline) {\n                    return;\n                }\n                completed.add(promise);\n                if (completed.size === 1) {\n                    if (((_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.suppressIfTabCompleterActive) &&\n                        this._tabCompleterActive) {\n                        cancelled = true;\n                        return;\n                    }\n                    model.setCompletions(result);\n                }\n                else {\n                    model.appendCompletions(result);\n                }\n            })\n                .catch(e => {\n                // Emit warning for debugging.\n                console.warn(e);\n            })\n                .finally(() => {\n                // Mark the provider promise as completed.\n                completed.add(promise);\n                // Let the model know that we are awaiting for fewer providers now.\n                const remaining = promises.length - completed.size;\n                model.notifyProgress({\n                    pendingProviders: remaining,\n                    totalProviders: promises.length\n                });\n            });\n        }\n    }\n    _composeRequest(editor, position) {\n        const text = editor.model.sharedModel.getSource();\n        const mimeType = editor.model.mimeType;\n        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);\n        return { text, offset, mimeType };\n    }\n    /**\n     * Updates model with text state and current cursor position.\n     */\n    _updateModel(state, start, end) {\n        const model = this.completer.model;\n        const text = state.text;\n        if (!model) {\n            return null;\n        }\n        // Update the original request.\n        model.original = state;\n        // Update the cursor.\n        model.cursor = {\n            start: Text.charIndexToJsIndex(start, text),\n            end: Text.charIndexToJsIndex(end, text)\n        };\n        return model;\n    }\n}\n/**\n * A namespace for cell completion handler statics.\n */\n(function (CompletionHandler) {\n    /**\n     * Stream event type.\n     */\n    let StraemEvent;\n    (function (StraemEvent) {\n        StraemEvent[StraemEvent[\"opened\"] = 0] = \"opened\";\n        StraemEvent[StraemEvent[\"update\"] = 1] = \"update\";\n        StraemEvent[StraemEvent[\"closed\"] = 2] = \"closed\";\n    })(StraemEvent = CompletionHandler.StraemEvent || (CompletionHandler.StraemEvent = {}));\n    /**\n     * A namespace for completion handler messages.\n     */\n    let Msg;\n    (function (Msg) {\n        /**\n         * A singleton `'invoke-request'` message.\n         */\n        Msg.InvokeRequest = new Message('invoke-request');\n    })(Msg = CompletionHandler.Msg || (CompletionHandler.Msg = {}));\n})(CompletionHandler || (CompletionHandler = {}));\n//# sourceMappingURL=handler.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { StringExt } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\n/**\n * Escape HTML by native means of the browser.\n */\nfunction escapeHTML(text) {\n    const node = document.createElement('span');\n    node.textContent = text;\n    return node.innerHTML;\n}\n/**\n * An implementation of a completer model.\n */\nexport class CompleterModel {\n    constructor() {\n        this.processedItemsCache = null;\n        this._current = null;\n        this._cursor = null;\n        this._isDisposed = false;\n        this._completionItems = [];\n        this._original = null;\n        this._query = '';\n        this._subsetMatch = false;\n        this._typeMap = {};\n        this._orderedTypes = [];\n        this._stateChanged = new Signal(this);\n        this._queryChanged = new Signal(this);\n        /**\n         * The weak map between a processed completion item with the original item.\n         * It's used to keep track of original completion item in case of displaying\n         * the completer with query.\n         */\n        this._processedToOriginalItem = null;\n        /**\n         * A counter to cancel ongoing `resolveItem` call.\n         */\n        this._resolvingItem = 0;\n    }\n    /**\n     * A signal emitted when state of the completer menu changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when query string changes (at invocation, or as user types).\n     */\n    get queryChanged() {\n        return this._queryChanged;\n    }\n    /**\n     * The original completion request details.\n     */\n    get original() {\n        return this._original;\n    }\n    set original(newValue) {\n        const unchanged = this._original === newValue ||\n            (this._original &&\n                newValue &&\n                JSONExt.deepEqual(newValue, this._original));\n        if (unchanged) {\n            return;\n        }\n        this._reset();\n        // Set both the current and original to the same value when original is set.\n        this._current = this._original = newValue;\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The current text change details.\n     */\n    get current() {\n        return this._current;\n    }\n    set current(newValue) {\n        const unchanged = this._current === newValue ||\n            (this._current && newValue && JSONExt.deepEqual(newValue, this._current));\n        if (unchanged) {\n            return;\n        }\n        const original = this._original;\n        // Original request must always be set before a text change. If it isn't\n        // the model fails silently.\n        if (!original) {\n            return;\n        }\n        const cursor = this._cursor;\n        // Cursor must always be set before a text change. This happens\n        // automatically in the completer handler, but since `current` is a public\n        // attribute, this defensive check is necessary.\n        if (!cursor) {\n            return;\n        }\n        const current = (this._current = newValue);\n        if (!current) {\n            this._stateChanged.emit(undefined);\n            return;\n        }\n        const originalLine = original.text.split('\\n')[original.line];\n        const currentLine = current.text.split('\\n')[current.line];\n        // If the text change means that the original start point has been preceded,\n        // then the completion is no longer valid and should be reset.\n        if (!this._subsetMatch && currentLine.length < originalLine.length) {\n            this.reset(true);\n            return;\n        }\n        const { start, end } = cursor;\n        // Clip the front of the current line.\n        let query = current.text.substring(start);\n        // Clip the back of the current line by calculating the end of the original.\n        const ending = original.text.substring(end);\n        query = query.substring(0, query.lastIndexOf(ending));\n        this._query = query;\n        this.processedItemsCache = null;\n        this._processedToOriginalItem = null;\n        this._queryChanged.emit({ newValue: this._query, origin: 'editorUpdate' });\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The cursor details that the API has used to return matching options.\n     */\n    get cursor() {\n        return this._cursor;\n    }\n    set cursor(newValue) {\n        // Original request must always be set before a cursor change. If it isn't\n        // the model fails silently.\n        if (!this.original) {\n            return;\n        }\n        this._cursor = newValue;\n    }\n    /**\n     * The query against which items are filtered.\n     */\n    get query() {\n        return this._query;\n    }\n    set query(newValue) {\n        this._query = newValue;\n        this.processedItemsCache = null;\n        this._processedToOriginalItem = null;\n        this._queryChanged.emit({ newValue: this._query, origin: 'setter' });\n    }\n    /**\n     * A flag that is true when the model value was modified by a subset match.\n     */\n    get subsetMatch() {\n        return this._subsetMatch;\n    }\n    set subsetMatch(newValue) {\n        this._subsetMatch = newValue;\n    }\n    /**\n     * Get whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * The list of visible items in the completer menu.\n     *\n     * #### Notes\n     * This is a read-only property.\n     * When overriding it is recommended to cache results in `processedItemsCache`\n     * property which will be automatically nullified when needed.\n     */\n    completionItems() {\n        if (!this.processedItemsCache) {\n            let query = this._query;\n            if (query) {\n                const markedItems = this._markup(query);\n                this.processedItemsCache = markedItems.map(it => it.processedItem);\n                this._processedToOriginalItem = new WeakMap(markedItems.map(it => [it.processedItem, it.originalItem]));\n            }\n            else {\n                this.processedItemsCache = this._completionItems.map(item => {\n                    return this._escapeItemLabel(item);\n                });\n                this._processedToOriginalItem = null;\n            }\n        }\n        return this.processedItemsCache;\n    }\n    /**\n     * Set the list of visible items in the completer menu, and append any\n     * new types to KNOWN_TYPES.\n     */\n    setCompletionItems(newValue) {\n        if (JSONExt.deepEqual(newValue, this._completionItems)) {\n            return;\n        }\n        this._completionItems = newValue;\n        this._orderedTypes = Private.findOrderedCompletionItemTypes(this._completionItems);\n        this.processedItemsCache = null;\n        this._processedToOriginalItem = null;\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * The map from identifiers (a.b) to types (function, module, class, instance,\n     * etc.).\n     *\n     * #### Notes\n     * A type map is currently only provided by the latest IPython kernel using\n     * the completer reply metadata field `_jupyter_types_experimental`. The\n     * values are completely up to the kernel.\n     *\n     */\n    typeMap() {\n        return this._typeMap;\n    }\n    /**\n     * An ordered list of all the known types in the typeMap.\n     *\n     * #### Notes\n     * To visually encode the types of the completer matches, we assemble an\n     * ordered list. This list begins with:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * and then has any remaining types listed alphabetically. This will give\n     * reliable visual encoding for these known types, but allow kernels to\n     * provide new types.\n     */\n    orderedTypes() {\n        return this._orderedTypes;\n    }\n    /**\n     * Handle a cursor change.\n     */\n    handleCursorChange(change) {\n        // If there is no active completion, return.\n        if (!this._original) {\n            return;\n        }\n        const { column, line } = change;\n        const { current, original } = this;\n        if (!original) {\n            return;\n        }\n        // If a cursor change results in a the cursor being on a different line\n        // than the original request, cancel.\n        if (line !== original.line) {\n            this.reset(true);\n            return;\n        }\n        // If a cursor change results in the cursor being set to a position that\n        // precedes the original column, cancel.\n        if (column < original.column) {\n            this.reset(true);\n            return;\n        }\n        const { cursor } = this;\n        if (!cursor || !current) {\n            return;\n        }\n        // If a cursor change results in the cursor being set to a position beyond\n        // the end of the area that would be affected by completion, cancel.\n        const cursorDelta = cursor.end - cursor.start;\n        const originalLine = original.text.split('\\n')[original.line];\n        const currentLine = current.text.split('\\n')[current.line];\n        const inputDelta = currentLine.length - originalLine.length;\n        if (column > original.column + cursorDelta + inputDelta) {\n            this.reset(true);\n            return;\n        }\n    }\n    /**\n     * Handle a text change.\n     */\n    handleTextChange(change) {\n        const original = this._original;\n        // If there is no active completion, return.\n        if (!original) {\n            return;\n        }\n        const { text, column, line } = change;\n        const last = text.split('\\n')[line][column - 1];\n        // If last character entered is not whitespace or if the change column is\n        // greater than or equal to the original column, update completion.\n        if ((last && last.match(/\\S/)) || change.column >= original.column) {\n            this.current = change;\n            return;\n        }\n        // If final character is whitespace, reset completion.\n        this.reset(false);\n    }\n    /**\n     * Create a resolved patch between the original state and a patch string.\n     *\n     * @param patch - The patch string to apply to the original value.\n     *\n     * @returns A patched text change or undefined if original value did not exist.\n     */\n    createPatch(patch) {\n        const original = this._original;\n        const cursor = this._cursor;\n        const current = this._current;\n        if (!original || !cursor || !current) {\n            return undefined;\n        }\n        let { start, end } = cursor;\n        // Also include any filtering/additional-typing that has occurred\n        // since the completion request in the patched length.\n        end = end + (current.text.length - original.text.length);\n        return { start, end, value: patch };\n    }\n    /**\n     * Reset the state of the model and emit a state change signal.\n     *\n     * @param hard - Reset even if a subset match is in progress.\n     */\n    reset(hard = false) {\n        // When the completer detects a common subset prefix for all options,\n        // it updates the model and sets the model source to that value, triggering\n        // a reset. Unless explicitly a hard reset, this should be ignored.\n        if (!hard && this._subsetMatch) {\n            return;\n        }\n        this._reset();\n        this._stateChanged.emit(undefined);\n    }\n    /**\n     * Check if CompletionItem matches against query.\n     * Highlight matching prefix by adding <mark> tags.\n     */\n    _markup(query) {\n        var _a;\n        const items = this._completionItems;\n        let results = [];\n        for (const originalItem of items) {\n            // See if label matches query string\n            // With ICompletionItems, the label may include parameters,\n            // so we exclude them from the matcher.\n            // e.g. Given label `foo(b, a, r)` and query `bar`,\n            // don't count parameters, `b`, `a`, and `r` as matches.\n            const index = originalItem.label.indexOf('(');\n            const text = index > -1\n                ? originalItem.label.substring(0, index)\n                : originalItem.label;\n            const match = StringExt.matchSumOfSquares(escapeHTML(text), query);\n            // Filter non-matching items.\n            if (match) {\n                // Highlight label text if there's a match\n                let marked = StringExt.highlight(escapeHTML(originalItem.label), match.indices, Private.mark);\n                // Use `Object.assign` to evaluate getters.\n                const highlightedItem = Object.assign({}, originalItem);\n                highlightedItem.label = marked.join('');\n                highlightedItem.insertText =\n                    (_a = originalItem.insertText) !== null && _a !== void 0 ? _a : originalItem.label;\n                results.push({\n                    item: highlightedItem,\n                    score: match.score,\n                    originalItem\n                });\n            }\n        }\n        results.sort(Private.scoreCmp);\n        // Extract only the item (dropping the extra score attribute to not leak\n        // implementation details to JavaScript callers.\n        return results.map(match => ({\n            processedItem: match.item,\n            originalItem: match.originalItem\n        }));\n    }\n    /**\n     * Lazy load missing data of an item.\n     * @param indexOrValue - the item or its index\n     * @remarks\n     * Resolving item by index will be deprecated in\n     * the JupyterLab 5.0 and removed in JupyterLab 6.0.\n     *\n     * @return Return `undefined` if the completion item with `activeIndex` index can not be found.\n     *  Return a promise of `null` if another `resolveItem` is called. Otherwise return the\n     * promise of resolved completion item.\n     */\n    resolveItem(indexOrValue) {\n        let processedItem;\n        if (typeof indexOrValue === 'number') {\n            const completionItems = this.completionItems();\n            if (!completionItems || !completionItems[indexOrValue]) {\n                return undefined;\n            }\n            processedItem = completionItems[indexOrValue];\n        }\n        else {\n            processedItem = indexOrValue;\n        }\n        if (!processedItem) {\n            return undefined;\n        }\n        let originalItem;\n        if (this._processedToOriginalItem) {\n            originalItem = this._processedToOriginalItem.get(processedItem);\n        }\n        else {\n            originalItem = processedItem;\n        }\n        if (!originalItem) {\n            return undefined;\n        }\n        return this._resolveItemByValue(originalItem);\n    }\n    /**\n     * Lazy load missing data of a completion item.\n     *\n     * @param  completionItem - the item to be resolved\n     * @return See `resolveItem` method\n     */\n    _resolveItemByValue(completionItem) {\n        const current = ++this._resolvingItem;\n        let resolvedItem;\n        if (completionItem.resolve) {\n            let patch;\n            if (completionItem.insertText) {\n                patch = this.createPatch(completionItem.insertText);\n            }\n            resolvedItem = completionItem.resolve(patch);\n        }\n        else {\n            resolvedItem = Promise.resolve(completionItem);\n        }\n        return resolvedItem\n            .then(activeItem => {\n            // Escape the label it in place\n            this._escapeItemLabel(activeItem, true);\n            Object.keys(activeItem).forEach((key) => {\n                completionItem[key] = activeItem[key];\n            });\n            completionItem.resolve = undefined;\n            if (current !== this._resolvingItem) {\n                return Promise.resolve(null);\n            }\n            return activeItem;\n        })\n            .catch(e => {\n            console.error(e);\n            // Failed to resolve missing data, return the original item.\n            return Promise.resolve(completionItem);\n        });\n    }\n    /**\n     * Escape item label, storing the original label and adding `insertText` if needed.\n     * If escaping changes label creates a new item unless `inplace` is true.\n     */\n    _escapeItemLabel(item, inplace = false) {\n        var _a;\n        const escapedLabel = escapeHTML(item.label);\n        // If there was no insert text, use the original (unescaped) label.\n        if (escapedLabel !== item.label) {\n            const newItem = inplace ? item : Object.assign({}, item);\n            newItem.insertText = (_a = item.insertText) !== null && _a !== void 0 ? _a : item.label;\n            newItem.label = escapedLabel;\n            return newItem;\n        }\n        return item;\n    }\n    /**\n     * Reset the state of the model.\n     */\n    _reset() {\n        const hadQuery = this._query;\n        this._current = null;\n        this._cursor = null;\n        this._completionItems = [];\n        this._original = null;\n        this._query = '';\n        this.processedItemsCache = null;\n        this._processedToOriginalItem = null;\n        this._subsetMatch = false;\n        this._typeMap = {};\n        this._orderedTypes = [];\n        if (hadQuery) {\n            this._queryChanged.emit({ newValue: this._query, origin: 'reset' });\n        }\n    }\n}\n/**\n * A namespace for completer model private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The list of known type annotations of completer matches.\n     */\n    const KNOWN_TYPES = ['function', 'instance', 'class', 'module', 'keyword'];\n    /**\n     * The map of known type annotations of completer matches.\n     */\n    const KNOWN_MAP = KNOWN_TYPES.reduce((acc, type) => {\n        acc[type] = null;\n        return acc;\n    }, {});\n    /**\n     * Mark a highlighted chunk of text.\n     */\n    function mark(value) {\n        return `<mark>${value}</mark>`;\n    }\n    Private.mark = mark;\n    /**\n     * A sort comparison function for item match scores.\n     *\n     * #### Notes\n     * This orders the items first based on score (lower is better), then\n     * by locale order of the item text.\n     */\n    function scoreCmp(a, b) {\n        var _a, _b, _c;\n        const delta = a.score - b.score;\n        if (delta !== 0) {\n            return delta;\n        }\n        return (_c = (_a = a.item.insertText) === null || _a === void 0 ? void 0 : _a.localeCompare((_b = b.item.insertText) !== null && _b !== void 0 ? _b : '')) !== null && _c !== void 0 ? _c : 0;\n    }\n    Private.scoreCmp = scoreCmp;\n    /**\n     * Compute a reliably ordered list of types for ICompletionItems.\n     *\n     * #### Notes\n     * The resulting list always begins with the known types:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * followed by other types in alphabetical order.\n     *\n     */\n    function findOrderedCompletionItemTypes(items) {\n        const newTypeSet = new Set();\n        items.forEach(item => {\n            if (item.type &&\n                !KNOWN_TYPES.includes(item.type) &&\n                !newTypeSet.has(item.type)) {\n                newTypeSet.add(item.type);\n            }\n        });\n        const newTypes = Array.from(newTypeSet);\n        newTypes.sort((a, b) => a.localeCompare(b));\n        return KNOWN_TYPES.concat(newTypes);\n    }\n    Private.findOrderedCompletionItemTypes = findOrderedCompletionItemTypes;\n    /**\n     * Compute a reliably ordered list of types.\n     *\n     * #### Notes\n     * The resulting list always begins with the known types:\n     * ```\n     * ['function', 'instance', 'class', 'module', 'keyword']\n     * ```\n     * followed by other types in alphabetical order.\n     */\n    function findOrderedTypes(typeMap) {\n        const filtered = Object.keys(typeMap)\n            .map(key => typeMap[key])\n            .filter((value) => !!value && !(value in KNOWN_MAP))\n            .sort((a, b) => a.localeCompare(b));\n        return KNOWN_TYPES.concat(filtered);\n    }\n    Private.findOrderedTypes = findOrderedTypes;\n})(Private || (Private = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Sanitizer } from '@jupyterlab/apputils';\nimport { renderText } from '@jupyterlab/rendermime';\nimport { HoverBox } from '@jupyterlab/ui-components';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\n/**\n * The class name added to completer menu items.\n */\nconst ITEM_CLASS = 'jp-Completer-item';\n/**\n * The class name added to an active completer menu item.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class used by item listing which determines the height of the completer.\n */\nconst LIST_CLASS = 'jp-Completer-list';\n/**\n * Class of the documentation panel.\n */\nconst DOC_PANEL_CLASS = 'jp-Completer-docpanel';\n/**\n * A flag to indicate that event handlers are caught in the capture phase.\n */\nconst USE_CAPTURE = true;\n/**\n * The number of colors defined for the completer type annotations.\n * These are listed in completer/style/index.css#102-152.\n */\nconst N_COLORS = 10;\n/**\n * A widget that enables text completion.\n *\n * #### Notes\n * The completer is intended to be absolutely positioned on the\n * page and hover over any other content, so it should be attached directly\n * to `document.body`, or a node that is the full size of `document.body`.\n * Attaching it to other nodes may incorrectly locate the completer.\n */\nexport class Completer extends Widget {\n    /**\n     * Construct a text completer menu widget.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super({ node: document.createElement('div') });\n        this._activeIndex = 0;\n        this._editor = null;\n        this._model = null;\n        this._selected = new Signal(this);\n        this._visibilityChanged = new Signal(this);\n        this._indexChanged = new Signal(this);\n        this._lastSubsetMatch = '';\n        this._geometryLock = false;\n        /**\n         * Increasing this counter invalidates previous request to save geometry cache in animation callback.\n         */\n        this._geometryCounter = 0;\n        this._docPanelExpanded = false;\n        this._renderCounter = 0;\n        this.sanitizer = (_a = options.sanitizer) !== null && _a !== void 0 ? _a : new Sanitizer();\n        this._defaultRenderer = Completer.getDefaultRenderer(this.sanitizer);\n        this._renderer = (_b = options.renderer) !== null && _b !== void 0 ? _b : this._defaultRenderer;\n        this._docPanel = this._createDocPanelNode();\n        this.model = (_c = options.model) !== null && _c !== void 0 ? _c : null;\n        this.editor = (_d = options.editor) !== null && _d !== void 0 ? _d : null;\n        this.addClass('jp-Completer');\n        this.addClass('jp-ThemedContainer');\n        this._updateConstraints();\n    }\n    /**\n     * Cache style constraints from CSS.\n     */\n    _updateConstraints() {\n        const tempNode = document.createElement('div');\n        tempNode.classList.add(LIST_CLASS);\n        tempNode.style.visibility = 'hidden';\n        tempNode.style.overflowY = 'scroll';\n        document.body.appendChild(tempNode);\n        const computedStyle = window.getComputedStyle(tempNode);\n        this._maxHeight = parseInt(computedStyle.maxHeight, 10);\n        this._minHeight = parseInt(computedStyle.minHeight, 10);\n        this._scrollbarWidth = tempNode.offsetWidth - tempNode.clientWidth;\n        document.body.removeChild(tempNode);\n        const tempDocPanel = this._createDocPanelNode();\n        this._docPanelWidth = Private.measureSize(tempDocPanel, 'inline-block').width;\n    }\n    /**\n     * The active index.\n     */\n    get activeIndex() {\n        return this._activeIndex;\n    }\n    /**\n     * The editor used by the completion widget.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        this._editor = newValue;\n    }\n    /**\n     * A signal emitted when a selection is made from the completer menu.\n     */\n    get selected() {\n        return this._selected;\n    }\n    /**\n     * A signal emitted when the completer widget's visibility changes.\n     *\n     * #### Notes\n     * This signal is useful when there are multiple floating widgets that may\n     * contend with the same space and ought to be mutually exclusive.\n     */\n    get visibilityChanged() {\n        return this._visibilityChanged;\n    }\n    /**\n     * A signal emitted when the active index changes.\n     */\n    get indexChanged() {\n        return this._indexChanged;\n    }\n    /**\n     * The model used by the completer widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        if ((!model && !this._model) || model === this._model) {\n            return;\n        }\n        if (this._model) {\n            this._model.stateChanged.disconnect(this.onModelStateChanged, this);\n            this._model.queryChanged.disconnect(this.onModelQueryChanged, this);\n        }\n        this._model = model;\n        if (this._model) {\n            this._model.stateChanged.connect(this.onModelStateChanged, this);\n            this._model.queryChanged.connect(this.onModelQueryChanged, this);\n        }\n    }\n    /**\n     * The completer used by the completer widget.\n     */\n    get renderer() {\n        return this._renderer;\n    }\n    set renderer(renderer) {\n        this._renderer = renderer;\n    }\n    /**\n     * Enable/disable the document panel.\n     */\n    set showDocsPanel(showDoc) {\n        this._showDoc = showDoc;\n    }\n    get showDocsPanel() {\n        return this._showDoc;\n    }\n    /**\n     * Dispose of the resources held by the completer widget.\n     */\n    dispose() {\n        this._sizeCache = undefined;\n        this._model = null;\n        super.dispose();\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeydown(event);\n                break;\n            case 'pointerdown':\n                this._evtPointerdown(event);\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Reset the widget.\n     */\n    reset() {\n        this._activeIndex = 0;\n        this._lastSubsetMatch = '';\n        if (this._model) {\n            this._model.reset(true);\n        }\n        this._docPanel.style.display = 'none';\n        // Clear size cache.\n        this._sizeCache = undefined;\n        this.node.scrollTop = 0;\n    }\n    /**\n     * Emit the selected signal for the current active item and reset.\n     */\n    selectActive() {\n        const active = this.node.querySelector(`.${ACTIVE_CLASS}`);\n        if (!active) {\n            this.reset();\n            return;\n        }\n        this._selected.emit(active.getAttribute('data-value'));\n        this.reset();\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        document.addEventListener('keydown', this, USE_CAPTURE);\n        document.addEventListener('pointerdown', this, USE_CAPTURE);\n        document.addEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.removeEventListener('keydown', this, USE_CAPTURE);\n        document.removeEventListener('pointerdown', this, USE_CAPTURE);\n        document.removeEventListener('scroll', this, USE_CAPTURE);\n    }\n    /**\n     * Handle model state changes.\n     */\n    onModelStateChanged() {\n        if (this.isAttached) {\n            this._activeIndex = 0;\n            this._indexChanged.emit(this._activeIndex);\n            this.update();\n        }\n    }\n    /**\n     * Handle model query changes.\n     */\n    onModelQueryChanged(model, queryChange) {\n        // If query was changed by the user typing, the filtered down items\n        // may no longer reach/exceed the maxHeight of the completer widget,\n        // hence size needs to be recalculated.\n        if (this._sizeCache && queryChange.origin === 'editorUpdate') {\n            const newItems = model.completionItems();\n            const oldItems = this._sizeCache.items;\n            // Only reset size if the number of items changed, or the longest item changed.\n            const oldWidest = oldItems[this._findWidestItemIndex(oldItems)];\n            const newWidest = newItems[this._findWidestItemIndex(newItems)];\n            const heuristic = this._getPreferredItemWidthHeuristic();\n            if (newItems.length !== this._sizeCache.items.length ||\n                heuristic(oldWidest) !== heuristic(newWidest)) {\n                this._sizeCache = undefined;\n            }\n        }\n    }\n    /**\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        var _a;\n        const model = this._model;\n        if (!model) {\n            return;\n        }\n        // If this is the first time the current completer session has loaded,\n        // populate any initial subset match. This is being done before node\n        // gets rendered to avoid rendering it twice.\n        if (!model.query) {\n            this._populateSubset();\n        }\n        let items = model.completionItems();\n        // If there are no items, reset and bail.\n        if (!items.length) {\n            if (!this.isHidden) {\n                this.reset();\n                this.hide();\n                this._visibilityChanged.emit(undefined);\n            }\n            return;\n        }\n        // Update constraints before any DOM modifications\n        this._updateConstraints();\n        // Do not trigger any geometry updates from async code when in lock.\n        this._geometryLock = true;\n        const node = this._createCompleterNode(model, items);\n        let active = node.querySelectorAll(`.${ITEM_CLASS}`)[this._activeIndex];\n        active.classList.add(ACTIVE_CLASS);\n        const resolvedItem = (_a = this.model) === null || _a === void 0 ? void 0 : _a.resolveItem(items[this._activeIndex]);\n        // Add the documentation panel\n        if (this._showDoc) {\n            this._docPanel.innerText = '';\n            node.appendChild(this._docPanel);\n            this._docPanelExpanded = false;\n            this._docPanel.style.display = 'none';\n            this._updateDocPanel(resolvedItem, active);\n        }\n        if (this.isHidden) {\n            this.show();\n            this._setGeometry();\n            this._visibilityChanged.emit(undefined);\n        }\n        else {\n            this._setGeometry();\n        }\n        this._geometryLock = false;\n    }\n    /**\n     * Get cached dimensions of the completer box.\n     */\n    get sizeCache() {\n        if (!this._sizeCache) {\n            return;\n        }\n        return {\n            width: this._sizeCache.width + this._sizeCache.docPanelWidth,\n            height: Math.max(this._sizeCache.height, this._sizeCache.docPanelHeight)\n        };\n    }\n    _createDocPanelNode() {\n        const docPanel = document.createElement('div');\n        docPanel.className = DOC_PANEL_CLASS;\n        return docPanel;\n    }\n    _createCompleterNode(model, items) {\n        const current = ++this._renderCounter;\n        // Clear the node.\n        let node = this.node;\n        node.textContent = '';\n        // Compute an ordered list of all the types in the typeMap, this is computed\n        // once by the model each time new data arrives for efficiency.\n        let orderedTypes = model.orderedTypes();\n        // Populate the completer items.\n        let ul = document.createElement('ul');\n        ul.className = LIST_CLASS;\n        // Add first N items to fill the first \"page\" assuming that the completer\n        // would reach its maximum allowed height.\n        const first = this._renderer.createCompletionItemNode(items[0], orderedTypes);\n        const renderedItems = [first];\n        const firstItemSize = Private.measureSize(first, 'inline-grid');\n        const pageSize = Math.max(Math.ceil(this._maxHeight / firstItemSize.height), 5);\n        // We add one item in case if height heuristic is inaccurate.\n        const toRenderImmediately = Math.min(pageSize + 1, items.length);\n        const start = performance.now();\n        for (let i = 1; i < toRenderImmediately; i++) {\n            const li = this._renderer.createCompletionItemNode(items[i], orderedTypes);\n            renderedItems.push(li);\n        }\n        for (const li of renderedItems) {\n            ul.appendChild(li);\n        }\n        // Pre-calculate size:\n        //  - height will equal first element height times number of items,\n        //    or maximum allowed height if there are more items than fit on a page,\n        //  - width will be estimated from the widest item.\n        const widestItemIndex = this._findWidestItemIndex(items);\n        const widestItem = widestItemIndex < renderedItems.length\n            ? renderedItems[widestItemIndex]\n            : this._renderer.createCompletionItemNode(items[widestItemIndex], orderedTypes);\n        // The node needs to be cloned to avoid side-effect of detaching it.\n        const widestItemSize = Private.measureSize(widestItem.cloneNode(true), 'inline-grid');\n        this._sizeCache = {\n            height: Math.min(this._maxHeight, firstItemSize.height * items.length),\n            width: widestItemSize.width + this._scrollbarWidth,\n            items: items,\n            docPanelWidth: 0,\n            docPanelHeight: 0\n        };\n        if (toRenderImmediately < items.length) {\n            // Render remaining items on idle in subsequent animation frames,\n            // in chunks of size such that each frame would take about 16ms\n            // allowing for 4ms of overhead, but keep the chunks no smaller\n            // than 5 items at a time.\n            const timePerItem = (performance.now() - start) / toRenderImmediately;\n            const chunkSize = Math.max(5, Math.floor(12 / timePerItem));\n            let alreadyRendered = toRenderImmediately;\n            let previousChunkFinal = renderedItems[renderedItems.length - 1];\n            const renderChunk = () => {\n                if (alreadyRendered >= items.length) {\n                    return;\n                }\n                // Add a filler so that the list with partially rendered items has the total\n                // height equal to the (predicted) final height to avoid scrollbar jitter.\n                const predictedMissingHeight = firstItemSize.height * (items.length - alreadyRendered);\n                previousChunkFinal.style.marginBottom = `${predictedMissingHeight}px`;\n                requestAnimationFrame(() => {\n                    if (current != this._renderCounter) {\n                        // Bail if rendering afresh was requested in the meantime.\n                        return;\n                    }\n                    previousChunkFinal.style.marginBottom = '';\n                    const limit = Math.min(items.length, alreadyRendered + chunkSize);\n                    for (let i = alreadyRendered; i < limit; i++) {\n                        const li = this._renderer.createCompletionItemNode(items[i], orderedTypes);\n                        ul.appendChild(li);\n                        previousChunkFinal = li;\n                    }\n                    alreadyRendered = limit;\n                    renderChunk();\n                });\n            };\n            renderChunk();\n        }\n        node.appendChild(ul);\n        return node;\n    }\n    /**\n     * Use preferred heuristic to find the index of the widest item.\n     */\n    _findWidestItemIndex(items) {\n        const widthHeuristic = this._getPreferredItemWidthHeuristic();\n        const widthHeuristics = items.map(widthHeuristic);\n        return widthHeuristics.indexOf(Math.max(...widthHeuristics));\n    }\n    /**\n     * Get item width heuristic function from renderer if available,\n     * or the default one otherwise.\n     */\n    _getPreferredItemWidthHeuristic() {\n        return this._renderer.itemWidthHeuristic\n            ? this._renderer.itemWidthHeuristic.bind(this._renderer)\n            : this._defaultRenderer.itemWidthHeuristic.bind(this._defaultRenderer);\n    }\n    /**\n     * Cycle through the available completer items.\n     *\n     * #### Notes\n     * When the user cycles all the way `down` to the last index, subsequent\n     * `down` cycles will cycle to the first index. When the user cycles `up` to\n     * the first item, subsequent `up` cycles will cycle to the last index.\n     */\n    _cycle(direction) {\n        var _a, _b;\n        const items = this.node.querySelectorAll(`.${ITEM_CLASS}`);\n        const index = this._activeIndex;\n        const last = items.length - 1;\n        let active = this.node.querySelector(`.${ACTIVE_CLASS}`);\n        active.classList.remove(ACTIVE_CLASS);\n        switch (direction) {\n            case 'up':\n                this._activeIndex = index === 0 ? last : index - 1;\n                break;\n            case 'down':\n                this._activeIndex = index < last ? index + 1 : 0;\n                break;\n            case 'pageUp':\n            case 'pageDown': {\n                // Measure the number of items on a page and clamp to the list length.\n                const container = this.node.getBoundingClientRect();\n                const current = active.getBoundingClientRect();\n                const page = Math.floor(container.height / current.height);\n                const sign = direction === 'pageUp' ? -1 : 1;\n                this._activeIndex = Math.min(Math.max(0, index + sign * page), last);\n                break;\n            }\n        }\n        active = items[this._activeIndex];\n        active.classList.add(ACTIVE_CLASS);\n        let completionList = this.node.querySelector(`.${LIST_CLASS}`);\n        ElementExt.scrollIntoViewIfNeeded(completionList, active);\n        this._indexChanged.emit(this._activeIndex);\n        const visibleCompletionItems = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completionItems();\n        const activeCompletionItem = visibleCompletionItems === null || visibleCompletionItems === void 0 ? void 0 : visibleCompletionItems[this._activeIndex];\n        if (activeCompletionItem) {\n            const resolvedItem = (_b = this.model) === null || _b === void 0 ? void 0 : _b.resolveItem(activeCompletionItem);\n            if (this._showDoc) {\n                this._updateDocPanel(resolvedItem, active);\n            }\n        }\n    }\n    /**\n     * Handle keydown events for the widget.\n     */\n    _evtKeydown(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        if (!this._editor.host.contains(event.target)) {\n            this.reset();\n            return;\n        }\n        switch (event.keyCode) {\n            case 9: {\n                // Tab key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                const model = this._model;\n                if (!model) {\n                    return;\n                }\n                // Autoinsert single completions on manual request (tab)\n                const items = model.completionItems();\n                if (items && items.length === 1) {\n                    this._selected.emit(items[0].insertText || items[0].label);\n                    this.reset();\n                    return;\n                }\n                const populated = this._populateSubset();\n                // If the common subset was found and set on `query`,\n                // or if there is a `query` in the initialization options,\n                // then emit a completion signal with that `query` (=subset match),\n                // but only if the query has actually changed.\n                // See: https://github.com/jupyterlab/jupyterlab/issues/10439#issuecomment-875189540\n                if (model.query && model.query !== this._lastSubsetMatch) {\n                    model.subsetMatch = true;\n                    this._selected.emit(model.query);\n                    model.subsetMatch = false;\n                    this._lastSubsetMatch = model.query;\n                }\n                // If the query changed, update rendering of the options.\n                if (populated) {\n                    this.update();\n                }\n                this._cycle(event.shiftKey ? 'up' : 'down');\n                return;\n            }\n            case 27: // Esc key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                this.reset();\n                return;\n            case 33: // PageUp\n            case 34: // PageDown\n            case 38: // Up arrow key\n            case 40: {\n                // Down arrow key\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                const cycle = Private.keyCodeMap[event.keyCode];\n                this._cycle(cycle);\n                return;\n            }\n            default:\n                return;\n        }\n    }\n    /**\n     * Handle mousedown events for the widget.\n     */\n    _evtPointerdown(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        if (Private.nonstandardClick(event)) {\n            this.reset();\n            return;\n        }\n        let target = event.target;\n        while (target !== document.documentElement) {\n            // If the user has made a selection, emit its value and reset the widget.\n            if (target.classList.contains(ITEM_CLASS)) {\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                this._selected.emit(target.getAttribute('data-value'));\n                this.reset();\n                return;\n            }\n            // If the mouse event happened anywhere else in the widget, bail.\n            if (target === this.node) {\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                return;\n            }\n            target = target.parentElement;\n        }\n        this.reset();\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        const { node } = this;\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (node.contains(event.target)) {\n            return;\n        }\n        // Set the geometry of the node asynchronously.\n        requestAnimationFrame(() => {\n            this._setGeometry();\n        });\n    }\n    /**\n     * Populate the completer up to the longest initial subset of items.\n     *\n     * @returns `true` if a subset match was found and populated.\n     */\n    _populateSubset() {\n        const { model } = this;\n        if (!model) {\n            return false;\n        }\n        const items = model.completionItems();\n        const subset = Private.commonSubset(items.map(item => item.insertText || item.label));\n        const { query } = model;\n        // If a common subset exists and it is not the current query, highlight it.\n        if (subset && subset !== query && subset.indexOf(query) === 0) {\n            model.query = subset;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Set the visible dimensions of the widget.\n     */\n    _setGeometry() {\n        const { node } = this;\n        const model = this._model;\n        const editor = this._editor;\n        // This is an overly defensive test: `cursor` will always exist if\n        // `original` exists, except in contrived tests. But since it is possible\n        // to generate a runtime error, the check occurs here.\n        if (!editor || !model || !model.original || !model.cursor) {\n            return;\n        }\n        const start = model.cursor.start;\n        const position = editor.getPositionAt(start);\n        const anchor = editor.getCoordinateForPosition(position);\n        if (!anchor) {\n            return;\n        }\n        const style = window.getComputedStyle(node);\n        const borderLeft = parseInt(style.borderLeftWidth, 10) || 0;\n        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;\n        // When the editor is attached to the main area, contain the completer hover box\n        // to the full area available (rather than to the editor itself); the available\n        // area excludes the toolbar, hence the first Widget child between MainAreaWidget\n        // and editor is preferred. The difference is negligible in File Editor, but\n        // substantial for Notebooks.\n        const host = editor.host.closest('.jp-MainAreaWidget > .lm-Widget') ||\n            editor.host;\n        const items = model.completionItems();\n        // Fast cache invalidation (only checks for length rather than length + width)\n        if (this._sizeCache && this._sizeCache.items.length !== items.length) {\n            this._sizeCache = undefined;\n        }\n        // Calculate the geometry of the completer.\n        HoverBox.setGeometry({\n            anchor,\n            host: host,\n            maxHeight: this._maxHeight,\n            minHeight: this._minHeight,\n            node: node,\n            size: this.sizeCache,\n            offset: { horizontal: borderLeft + paddingLeft },\n            privilege: 'below',\n            style: style,\n            outOfViewDisplay: {\n                top: 'stick-inside',\n                bottom: 'stick-inside',\n                left: 'stick-inside',\n                right: 'stick-outside'\n            }\n        });\n        const current = ++this._geometryCounter;\n        if (!this._sizeCache) {\n            // If size was not pre-calculated using heuristics, save the actual\n            // size into cache once rendered.\n            requestAnimationFrame(() => {\n                if (current != this._geometryCounter) {\n                    // Do not set size to cache if it may already be outdated.\n                    return;\n                }\n                let rect = node.getBoundingClientRect();\n                let panel = this._docPanel.getBoundingClientRect();\n                this._sizeCache = {\n                    width: rect.width - panel.width,\n                    height: rect.height,\n                    items: items,\n                    docPanelWidth: panel.width,\n                    docPanelHeight: panel.height\n                };\n            });\n        }\n    }\n    /**\n     * Update the display-state and contents of the documentation panel\n     */\n    _updateDocPanel(resolvedItem, activeNode) {\n        var _a, _b, _c;\n        let docPanel = this._docPanel;\n        if (!resolvedItem) {\n            this._toggleDocPanel(false);\n            return;\n        }\n        const loadingIndicator = (_c = (_b = (_a = this._renderer).createLoadingDocsIndicator) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : this._defaultRenderer.createLoadingDocsIndicator();\n        activeNode.appendChild(loadingIndicator);\n        resolvedItem\n            .then(activeItem => {\n            var _a, _b, _c;\n            if (!activeItem) {\n                return;\n            }\n            if (!docPanel) {\n                return;\n            }\n            if (activeItem.documentation) {\n                const node = (_c = (_b = (_a = this._renderer).createDocumentationNode) === null || _b === void 0 ? void 0 : _b.call(_a, activeItem)) !== null && _c !== void 0 ? _c : this._defaultRenderer.createDocumentationNode(activeItem);\n                docPanel.textContent = '';\n                docPanel.appendChild(node);\n                this._toggleDocPanel(true);\n            }\n            else {\n                this._toggleDocPanel(false);\n            }\n        })\n            .catch(e => console.error(e))\n            .finally(() => {\n            activeNode.removeChild(loadingIndicator);\n        });\n    }\n    _toggleDocPanel(show) {\n        let docPanel = this._docPanel;\n        if (show) {\n            if (this._docPanelExpanded) {\n                return;\n            }\n            docPanel.style.display = '';\n            this._docPanelExpanded = true;\n        }\n        else {\n            if (!this._docPanelExpanded) {\n                return;\n            }\n            docPanel.style.display = 'none';\n            this._docPanelExpanded = false;\n        }\n        const sizeCache = this._sizeCache;\n        if (sizeCache) {\n            sizeCache.docPanelHeight = show ? this._maxHeight : 0;\n            sizeCache.docPanelWidth = show ? this._docPanelWidth : 0;\n            if (!this._geometryLock) {\n                this._setGeometry();\n            }\n        }\n    }\n}\n(function (Completer) {\n    /**\n     * The default implementation of an `IRenderer`.\n     */\n    class Renderer {\n        constructor(options) {\n            this.sanitizer = (options === null || options === void 0 ? void 0 : options.sanitizer) || new Sanitizer();\n        }\n        /**\n         * Create an item node from an ICompletionItem for a text completer menu.\n         */\n        createCompletionItemNode(item, orderedTypes) {\n            let wrapperNode = this._createWrapperNode(item.insertText || item.label);\n            if (item.deprecated) {\n                wrapperNode.classList.add('jp-Completer-deprecated');\n            }\n            return this._constructNode(wrapperNode, this._createLabelNode(item.label), !!item.type, item.type, orderedTypes, item.icon);\n        }\n        /**\n         * Create a documentation node for documentation panel.\n         */\n        createDocumentationNode(activeItem) {\n            const host = document.createElement('div');\n            host.classList.add('jp-RenderedText');\n            const sanitizer = this.sanitizer;\n            const source = activeItem.documentation || '';\n            renderText({ host, sanitizer, source }).catch(console.error);\n            return host;\n        }\n        /**\n         * Get a heuristic for the width of an item.\n         */\n        itemWidthHeuristic(item) {\n            var _a;\n            // Get the label text without HTML markup (`<mark>` is the only markup\n            // that is allowed in processed items, everything else gets escaped).\n            const labelText = item.label.replace(/<(\\/)?mark>/g, '');\n            return labelText.length + (((_a = item.type) === null || _a === void 0 ? void 0 : _a.length) || 0);\n        }\n        /**\n         * Create a loading bar for the documentation panel.\n         */\n        createLoadingDocsIndicator() {\n            const loadingContainer = document.createElement('div');\n            loadingContainer.classList.add('jp-Completer-loading-bar-container');\n            const loadingBar = document.createElement('div');\n            loadingBar.classList.add('jp-Completer-loading-bar');\n            loadingContainer.append(loadingBar);\n            return loadingContainer;\n        }\n        /**\n         * Create base node with the value to be inserted.\n         */\n        _createWrapperNode(value) {\n            const li = document.createElement('li');\n            li.className = ITEM_CLASS;\n            // Set the raw, un-marked up value as a data attribute.\n            li.setAttribute('data-value', value);\n            return li;\n        }\n        /**\n         * Create match node to highlight potential prefix match within result.\n         */\n        _createLabelNode(result) {\n            const matchNode = document.createElement('code');\n            matchNode.className = 'jp-Completer-match';\n            // Use innerHTML because search results include <mark> tags.\n            matchNode.innerHTML = result;\n            return matchNode;\n        }\n        /**\n         * Attaches type and match nodes to base node.\n         */\n        _constructNode(li, matchNode, typesExist, type, orderedTypes, icon) {\n            // Add the icon or type monogram\n            if (icon) {\n                const iconNode = icon.element({\n                    className: 'jp-Completer-type jp-Completer-icon'\n                });\n                li.appendChild(iconNode);\n            }\n            else if (typesExist) {\n                const typeNode = document.createElement('span');\n                typeNode.textContent = (type[0] || '').toLowerCase();\n                const colorIndex = (orderedTypes.indexOf(type) % N_COLORS) + 1;\n                typeNode.className = 'jp-Completer-type jp-Completer-monogram';\n                typeNode.setAttribute(`data-color-index`, colorIndex.toString());\n                li.appendChild(typeNode);\n            }\n            else {\n                // Create empty span to ensure consistent list styling.\n                // Otherwise, in a list of two items,\n                // if one item has an icon, but the other has type,\n                // the icon grows out of its bounds.\n                const dummyNode = document.createElement('span');\n                dummyNode.className = 'jp-Completer-monogram';\n                li.appendChild(dummyNode);\n            }\n            li.appendChild(matchNode);\n            // If there is a type, add the type extension and title\n            if (typesExist) {\n                li.title = type;\n                const typeExtendedNode = document.createElement('code');\n                typeExtendedNode.className = 'jp-Completer-typeExtended';\n                typeExtendedNode.textContent = type.toLocaleLowerCase();\n                li.appendChild(typeExtendedNode);\n            }\n            else {\n                // If no type is present on the right,\n                // the highlighting of the completion item\n                // doesn't cover the entire row.\n                const dummyTypeExtendedNode = document.createElement('span');\n                dummyTypeExtendedNode.className = 'jp-Completer-typeExtended';\n                li.appendChild(dummyTypeExtendedNode);\n            }\n            return li;\n        }\n    }\n    Completer.Renderer = Renderer;\n    /**\n     * Default renderer\n     */\n    let _defaultRenderer;\n    /**\n     * The default `IRenderer` instance.\n     */\n    function getDefaultRenderer(sanitizer) {\n        if (!_defaultRenderer ||\n            (sanitizer && _defaultRenderer.sanitizer !== sanitizer)) {\n            _defaultRenderer = new Renderer({ sanitizer: sanitizer });\n        }\n        return _defaultRenderer;\n    }\n    Completer.getDefaultRenderer = getDefaultRenderer;\n})(Completer || (Completer = {}));\n/**\n * A namespace for completer widget private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Mapping from keyCodes to scrollTypes.\n     */\n    Private.keyCodeMap = {\n        38: 'up',\n        40: 'down',\n        33: 'pageUp',\n        34: 'pageDown'\n    };\n    /**\n     * Returns the common subset string that a list of strings shares.\n     */\n    function commonSubset(values) {\n        const len = values.length;\n        let subset = '';\n        if (len < 2) {\n            return subset;\n        }\n        const strlen = values[0].length;\n        for (let i = 0; i < strlen; i++) {\n            const ch = values[0][i];\n            for (let j = 1; j < len; j++) {\n                if (values[j][i] !== ch) {\n                    return subset;\n                }\n            }\n            subset += ch;\n        }\n        return subset;\n    }\n    Private.commonSubset = commonSubset;\n    /**\n     * Returns true for any modified click event (i.e., not a left-click).\n     */\n    function nonstandardClick(event) {\n        return (event.button !== 0 ||\n            event.altKey ||\n            event.ctrlKey ||\n            event.shiftKey ||\n            event.metaKey);\n    }\n    Private.nonstandardClick = nonstandardClick;\n    /**\n     * Measure size of provided HTML element without painting it.\n     *\n     * #### Notes\n     * The provided element has to be detached (not connected to DOM),\n     * or a side-effect of detaching it will occur.\n     */\n    function measureSize(element, display) {\n        if (element.isConnected) {\n            console.warn('Measuring connected elements with `measureSize` has side-effects');\n        }\n        element.style.visibility = 'hidden';\n        element.style.display = display;\n        document.body.appendChild(element);\n        const size = element.getBoundingClientRect();\n        document.body.removeChild(element);\n        element.removeAttribute('style');\n        return size;\n    }\n    Private.measureSize = measureSize;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CompletionHandler } from './handler';\nimport { InlineCompletionTriggerKind } from './tokens';\nimport { Signal } from '@lumino/signaling';\n/**\n * The reconciliator which is used to fetch and merge responses from multiple completion providers.\n */\nexport class ProviderReconciliator {\n    /**\n     * Creates an instance of ProviderReconciliator.\n     */\n    constructor(options) {\n        var _a, _b;\n        this._resolveFactory = (provider, el) => provider.resolve\n            ? (patch) => provider.resolve(el, this._context, patch)\n            : undefined;\n        /**\n         * Counter to reject current provider response if a new fetch request is created.\n         */\n        this._fetching = 0;\n        /**\n         * Counter to reject current inline provider response if a new `inlineFetch` request is created.\n         */\n        this._inlineFetching = 0;\n        this._providers = options.providers;\n        this._inlineProviders = (_a = options.inlineProviders) !== null && _a !== void 0 ? _a : [];\n        this._inlineProvidersSettings = (_b = options.inlineProvidersSettings) !== null && _b !== void 0 ? _b : {};\n        this._context = options.context;\n        this._timeout = options.timeout;\n    }\n    /**\n     * Check for the providers which are applicable with the current context\n     *\n     * @return  List of applicable providers\n     */\n    async applicableProviders() {\n        const isApplicablePromises = this._providers.map(p => p.isApplicable(this._context));\n        const applicableProviders = await Promise.all(isApplicablePromises);\n        return this._providers.filter((_, idx) => applicableProviders[idx]);\n    }\n    fetchInline(request, trigger) {\n        let promises = [];\n        const current = ++this._inlineFetching;\n        for (const provider of this._inlineProviders) {\n            const settings = this._inlineProvidersSettings[provider.identifier];\n            let delay = 0;\n            if (trigger === InlineCompletionTriggerKind.Automatic) {\n                delay = settings.debouncerDelay;\n            }\n            const fetch = () => {\n                const promise = provider\n                    .fetch(request, { ...this._context, triggerKind: trigger })\n                    .then(completionList => {\n                    return {\n                        ...completionList,\n                        items: completionList.items.map(item => {\n                            const newItem = item;\n                            newItem.stream = new Signal(newItem);\n                            newItem.provider = provider;\n                            void this._stream(newItem, provider);\n                            return newItem;\n                        })\n                    };\n                });\n                const timeoutPromise = new Promise(resolve => {\n                    return setTimeout(() => resolve(null), delay + settings.timeout);\n                });\n                return Promise.race([promise, timeoutPromise]);\n            };\n            const promise = delay === 0\n                ? fetch()\n                : new Promise((resolve, reject) => {\n                    return setTimeout(() => {\n                        if (current != this._inlineFetching) {\n                            // User pressed another key or explicitly requested completions since.\n                            return reject(null);\n                        }\n                        else {\n                            return resolve(fetch());\n                        }\n                    }, delay);\n                });\n            // Wrap promise and return error in case of failure.\n            promises.push(promise.catch(p => p));\n        }\n        return promises;\n    }\n    async _stream(item, provider) {\n        if (!item.isIncomplete || !provider.stream || !item.token) {\n            return;\n        }\n        const streamed = item.stream;\n        const token = item.token;\n        item.token = undefined;\n        // Notify that streaming started.\n        item.streaming = true;\n        streamed.emit(CompletionHandler.StraemEvent.opened);\n        for await (const reply of provider.stream(token)) {\n            const updated = reply.response;\n            const addition = updated.insertText.substring(item.insertText.length);\n            // Stream an update.\n            item.insertText = updated.insertText;\n            item.lastStreamed = addition;\n            item.error = reply.response.error;\n            streamed.emit(CompletionHandler.StraemEvent.update);\n        }\n        // Notify that streaming is no longer in progress.\n        item.isIncomplete = false;\n        item.lastStreamed = undefined;\n        item.streaming = false;\n        streamed.emit(CompletionHandler.StraemEvent.closed);\n    }\n    /**\n     * Fetch response from multiple providers, If a provider can not return\n     * the response for a completer request before timeout,\n     * the result of this provider will be ignored.\n     *\n     * @param {CompletionHandler.IRequest} request - The completion request.\n     */\n    async fetch(request, trigger) {\n        const current = ++this._fetching;\n        let promises = [];\n        const applicableProviders = await this.applicableProviders();\n        for (const provider of applicableProviders) {\n            let promise;\n            promise = provider.fetch(request, this._context, trigger).then(reply => {\n                if (current !== this._fetching) {\n                    return Promise.reject(void 0);\n                }\n                const items = reply.items.map(el => ({\n                    ...el,\n                    resolve: this._resolveFactory(provider, el)\n                }));\n                return { ...reply, items };\n            });\n            const timeoutPromise = new Promise(resolve => {\n                return setTimeout(() => resolve(null), this._timeout);\n            });\n            promise = Promise.race([promise, timeoutPromise]);\n            // Wrap promise and return error in case of failure.\n            promises.push(promise.catch(p => p));\n        }\n        // TODO: maybe use `Promise.allSettled` once library is at es2020 instead of adding a catch.\n        const combinedPromise = Promise.all(promises);\n        return this._mergeCompletions(combinedPromise);\n    }\n    /**\n     * Check if completer should make request to fetch completion responses\n     * on user typing. If the provider with highest rank does not have\n     * `shouldShowContinuousHint` method, a default one will be used.\n     *\n     * @param completerIsVisible - The visible status of completer widget.\n     * @param changed - CodeMirror changed argument.\n     */\n    async shouldShowContinuousHint(completerIsVisible, changed) {\n        const applicableProviders = await this.applicableProviders();\n        if (applicableProviders.length === 0) {\n            return false;\n        }\n        if (applicableProviders[0].shouldShowContinuousHint) {\n            return applicableProviders[0].shouldShowContinuousHint(completerIsVisible, changed, this._context);\n        }\n        return this._defaultShouldShowContinuousHint(completerIsVisible, changed);\n    }\n    _alignPrefixes(replies, minStart, maxStart) {\n        if (minStart != maxStart) {\n            const editor = this._context.editor;\n            if (!editor) {\n                return replies;\n            }\n            const cursor = editor.getCursorPosition();\n            const line = editor.getLine(cursor.line);\n            if (!line) {\n                return replies;\n            }\n            const lineOffset = editor.getOffsetAt({ line: cursor.line, column: 0 });\n            return replies.map(reply => {\n                const prefixStart = Math.max(reply.start - lineOffset, 0);\n                const prefixEnd = Math.max(maxStart - lineOffset, 0);\n                // No prefix to strip, return as-is.\n                if (prefixStart == prefixEnd) {\n                    return reply;\n                }\n                const prefix = line.substring(prefixStart, prefixEnd);\n                return {\n                    ...reply,\n                    items: reply.items.map(item => {\n                        let insertText = item.insertText || item.label;\n                        item.insertText = insertText.startsWith(prefix)\n                            ? insertText.slice(prefix.length)\n                            : insertText;\n                        return item;\n                    })\n                };\n            });\n        }\n        return replies;\n    }\n    async _mergeCompletions(promises) {\n        let replies = (await promises).filter(reply => {\n            // Ignore it errors out.\n            if (!reply || reply instanceof Error) {\n                return false;\n            }\n            // Ignore if no matches.\n            if (!reply.items.length) {\n                return false;\n            }\n            // Otherwise keep.\n            return true;\n        });\n        // Fast path for a single reply or no replies.\n        if (replies.length == 0) {\n            return null;\n        }\n        else if (replies.length == 1) {\n            return replies[0];\n        }\n        const minEnd = Math.min(...replies.map(reply => reply.end));\n        // If any of the replies uses a wider range, we need to align them\n        // so that all responses use the same range.\n        const starts = replies.map(reply => reply.start);\n        const minStart = Math.min(...starts);\n        const maxStart = Math.max(...starts);\n        replies = this._alignPrefixes(replies, minStart, maxStart);\n        const insertTextSet = new Set();\n        const mergedItems = new Array();\n        for (const reply of replies) {\n            reply.items.forEach(item => {\n                // IPython returns 'import' and 'import '; while the latter is more useful,\n                // user should not see two suggestions with identical labels and nearly-identical\n                // behaviour as they could not distinguish the two either way.\n                let text = (item.insertText || item.label).trim();\n                if (insertTextSet.has(text)) {\n                    return;\n                }\n                insertTextSet.add(text);\n                mergedItems.push(item);\n            });\n        }\n        return {\n            start: maxStart,\n            end: minEnd,\n            items: mergedItems\n        };\n    }\n    _defaultShouldShowContinuousHint(completerIsVisible, changed) {\n        return (!completerIsVisible &&\n            (changed.sourceChange == null ||\n                changed.sourceChange.some(delta => delta.insert != null && delta.insert.length > 0)));\n    }\n}\n//# sourceMappingURL=reconciliator.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nexport const CONTEXT_PROVIDER_ID = 'CompletionProvider:context';\n/**\n * A context connector for completion handlers.\n */\nexport class ContextCompleterProvider {\n    constructor() {\n        this.identifier = CONTEXT_PROVIDER_ID;\n        this.rank = 500;\n        this.renderer = null;\n    }\n    /**\n     * The context completion provider is applicable on all cases.\n     * @param context - additional information about context of completion request\n     */\n    async isApplicable(context) {\n        return true;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     */\n    fetch(request, context) {\n        const editor = context.editor;\n        if (!editor) {\n            return Promise.reject('No editor');\n        }\n        return new Promise(resolve => {\n            resolve(Private.contextHint(editor));\n        });\n    }\n}\n/**\n * A namespace for Private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get a list of completion hints from a tokenization\n     * of the editor.\n     */\n    function contextHint(editor) {\n        // Find the token at the cursor\n        const token = editor.getTokenAtCursor();\n        // Get the list of matching tokens.\n        const tokenList = getCompletionTokens(token, editor);\n        // Only choose the ones that have a non-empty type\n        // field, which are likely to be of interest.\n        const completionList = tokenList.filter(t => t.type).map(t => t.value);\n        // Remove duplicate completions from the list\n        const matches = new Set(completionList);\n        const items = new Array();\n        matches.forEach(label => items.push({ label }));\n        return {\n            start: token.offset,\n            end: token.offset + token.value.length,\n            items\n        };\n    }\n    Private.contextHint = contextHint;\n    /**\n     * Get a list of tokens that match the completion request,\n     * but are not identical to the completion request.\n     */\n    function getCompletionTokens(token, editor) {\n        const candidates = editor.getTokens();\n        // Only get the tokens that have a common start, but\n        // are not identical.\n        return candidates.filter(t => t.value.indexOf(token.value) === 0 && t.value !== token.value);\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=contextprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Text } from '@jupyterlab/coreutils';\nexport const KERNEL_PROVIDER_ID = 'CompletionProvider:kernel';\n/**\n * A kernel connector for completion handlers.\n */\nexport class KernelCompleterProvider {\n    constructor() {\n        this.identifier = KERNEL_PROVIDER_ID;\n        this.rank = 550;\n        this.renderer = null;\n    }\n    /**\n     * The kernel completion provider is applicable only if the kernel is available.\n     * @param context - additional information about context of completion request\n     */\n    async isApplicable(context) {\n        var _a;\n        const hasKernel = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!hasKernel) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     */\n    async fetch(request, context) {\n        var _a;\n        const kernel = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            throw new Error('No kernel for completion request.');\n        }\n        const contents = {\n            code: request.text,\n            cursor_pos: request.offset\n        };\n        const msg = await kernel.requestComplete(contents);\n        const response = msg.content;\n        if (response.status !== 'ok') {\n            throw new Error('Completion fetch failed to return successfully.');\n        }\n        const items = new Array();\n        const metadata = response.metadata._jupyter_types_experimental;\n        response.matches.forEach((label, index) => {\n            if (metadata && metadata[index]) {\n                items.push({\n                    label,\n                    type: metadata[index].type,\n                    insertText: metadata[index].text\n                });\n            }\n            else {\n                items.push({ label });\n            }\n        });\n        return {\n            start: response.cursor_start,\n            end: response.cursor_end,\n            items\n        };\n    }\n    /**\n     * Kernel provider will use the inspect request to lazy-load the content\n     * for document panel.\n     */\n    async resolve(item, context, patch) {\n        const { editor, session } = context;\n        if (session && editor) {\n            let code = editor.model.sharedModel.getSource();\n            const position = editor.getCursorPosition();\n            let offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), code);\n            const kernel = session.kernel;\n            if (!code || !kernel) {\n                return Promise.resolve(item);\n            }\n            if (patch) {\n                const { start, value } = patch;\n                code = code.substring(0, start) + value;\n                offset = offset + value.length;\n            }\n            const contents = {\n                code,\n                cursor_pos: offset,\n                detail_level: 0\n            };\n            const msg = await kernel.requestInspect(contents);\n            const value = msg.content;\n            if (value.status !== 'ok' || !value.found) {\n                return item;\n            }\n            item.documentation = value.data['text/plain'];\n            return item;\n        }\n        return item;\n    }\n    /**\n     * Kernel provider will activate the completer in continuous mode after\n     * the `.` character.\n     */\n    shouldShowContinuousHint(visible, changed) {\n        const sourceChange = changed.sourceChange;\n        if (sourceChange == null) {\n            return true;\n        }\n        if (sourceChange.some(delta => delta.delete != null)) {\n            return false;\n        }\n        return sourceChange.some(delta => delta.insert != null &&\n            (delta.insert === '.' || (!visible && delta.insert.trim().length > 0)));\n    }\n}\n//# sourceMappingURL=kernelprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Decoration, EditorView, WidgetType } from '@codemirror/view';\nimport { StateEffect, StateField } from '@codemirror/state';\nconst TRANSIENT_LINE_SPACER_CLASS = 'jp-GhostText-lineSpacer';\nconst TRANSIENT_LETTER_SPACER_CLASS = 'jp-GhostText-letterSpacer';\nconst GHOST_TEXT_CLASS = 'jp-GhostText';\nconst STREAMED_TOKEN_CLASS = 'jp-GhostText-streamedToken';\nconst STREAMING_INDICATOR_CLASS = 'jp-GhostText-streamingIndicator';\nconst ERROR_INDICATOR_CLASS = 'jp-GhostText-errorIndicator';\nconst HIDDEN_LINES_CLASS = 'jp-GhostText-hiddenLines';\nexport class GhostTextManager {\n    constructor(options) {\n        this.options = options;\n        // no-op\n    }\n    /**\n     * Place ghost text in an editor.\n     */\n    placeGhost(view, text) {\n        const effects = [Private.addMark.of(text)];\n        if (!view.state.field(Private.markField, false)) {\n            effects.push(StateEffect.appendConfig.of([Private.markField]));\n            effects.push(StateEffect.appendConfig.of([\n                EditorView.domEventHandlers({\n                    blur: (event) => {\n                        if (this.options.onBlur(event) === false) {\n                            return true;\n                        }\n                        const effects = [\n                            Private.removeMark.of(null)\n                        ];\n                        // Only execute it after editor update has completed.\n                        setTimeout(() => {\n                            view.dispatch({ effects });\n                        }, 0);\n                    }\n                })\n            ]));\n        }\n        view.dispatch({ effects });\n    }\n    /**\n     * Clear all ghost texts from the editor.\n     */\n    clearGhosts(view) {\n        const effects = [Private.removeMark.of(null)];\n        view.dispatch({ effects });\n    }\n}\n/**\n * Typing animation.\n */\nGhostTextManager.streamingAnimation = 'uncover';\n/**\n * Delay for removal of line spacer.\n */\nGhostTextManager.spacerRemovalDelay = 700;\n/**\n * Duration for line spacer removal.\n */\nGhostTextManager.spacerRemovalDuration = 300;\nclass GhostTextWidget extends WidgetType {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.isSpacer = false;\n        this._clearErrorTimeout = null;\n    }\n    eq(other) {\n        return (other.content == this.content &&\n            other.options.streaming === this.options.streaming &&\n            other.options.error === this.options.error);\n    }\n    get lineBreaks() {\n        return (this.content.match(/\\n/g) || '').length;\n    }\n    updateDOM(dom, _view) {\n        this._updateDOM(dom);\n        return true;\n    }\n    get content() {\n        return this.options.content;\n    }\n    toDOM() {\n        let wrap = document.createElement('span');\n        if (this.options.onPointerOver) {\n            wrap.addEventListener('pointerover', this.options.onPointerOver);\n        }\n        if (this.options.onPointerLeave) {\n            wrap.addEventListener('pointerleave', this.options.onPointerLeave);\n        }\n        wrap.classList.add(GHOST_TEXT_CLASS);\n        wrap.dataset.animation = GhostTextManager.streamingAnimation;\n        wrap.dataset.providedBy = this.options.providerId;\n        this._updateDOM(wrap);\n        return wrap;\n    }\n    _removeErrorAnimation(dom) {\n        const elementsToRemove = dom.querySelectorAll(`.${ERROR_INDICATOR_CLASS}`);\n        elementsToRemove.forEach(element => {\n            element.remove();\n        });\n    }\n    /**\n     * Mount the error animation DOM and remove the streaming indicator if any.\n     */\n    _mountErrorAnimation(dom) {\n        const errorIndicator = document.createElement('span');\n        errorIndicator.className = ERROR_INDICATOR_CLASS;\n        const error = this.options.error;\n        if (error === null || error === void 0 ? void 0 : error.message) {\n            errorIndicator.title = error === null || error === void 0 ? void 0 : error.message;\n        }\n        // Delete stream and previous error animation\n        const elementsToRemove = dom.querySelectorAll(`.${STREAMING_INDICATOR_CLASS}, .${ERROR_INDICATOR_CLASS}`);\n        elementsToRemove.forEach(element => {\n            element.remove();\n        });\n        dom.appendChild(errorIndicator);\n    }\n    _updateDOM(dom) {\n        var _a, _b;\n        if (this.options.error) {\n            this._mountErrorAnimation(dom);\n            this._clearErrorTimeout = setTimeout(() => {\n                this._removeErrorAnimation(dom);\n                this._clearErrorTimeout = null;\n            }, 5000);\n            return;\n        }\n        // If not in an error anymore, clear the error indicator\n        if (this._clearErrorTimeout !== null) {\n            clearTimeout(this._clearErrorTimeout);\n            this._removeErrorAnimation(dom);\n            this._clearErrorTimeout = null;\n        }\n        let content = this.content;\n        let hiddenContent = '';\n        let addition = this.options.addedPart;\n        if (addition) {\n            if (addition.startsWith('\\n')) {\n                // Show the new line straight away to ensure proper positioning.\n                addition = addition.substring(1);\n            }\n            content = content.substring(0, content.length - addition.length);\n        }\n        if (this.options.maxLines) {\n            // Split into content to show immediately and the hidden part\n            const lines = content.split('\\n');\n            content = lines.slice(0, this.options.maxLines).join('\\n');\n            hiddenContent = lines.slice(this.options.maxLines).join('\\n');\n        }\n        const minLines = Math.min((_a = this.options.minLines) !== null && _a !== void 0 ? _a : 0, (_b = this.options.maxLines) !== null && _b !== void 0 ? _b : Infinity);\n        const linesToAdd = Math.max(0, minLines - content.split('\\n').length + 1);\n        const placeHolderLines = new Array(linesToAdd).fill('').join('\\n');\n        if (this.isSpacer) {\n            dom.innerText = content + placeHolderLines;\n            return;\n        }\n        dom.innerText = content;\n        let streamedTokenHost = dom;\n        if (hiddenContent.length > 0) {\n            const hiddenWrapper = document.createElement('span');\n            hiddenWrapper.className = 'jp-GhostText-hiddenWrapper';\n            dom.appendChild(hiddenWrapper);\n            const expandOnHover = document.createElement('span');\n            expandOnHover.className = 'jp-GhostText-expandHidden';\n            expandOnHover.innerText = '';\n            const hiddenPart = document.createElement('span');\n            hiddenWrapper.appendChild(expandOnHover);\n            hiddenPart.className = HIDDEN_LINES_CLASS;\n            hiddenPart.innerText = '\\n' + hiddenContent;\n            hiddenWrapper.appendChild(hiddenPart);\n            streamedTokenHost = hiddenPart;\n        }\n        if (addition) {\n            const addedPart = document.createElement('span');\n            addedPart.className = STREAMED_TOKEN_CLASS;\n            addedPart.innerText = addition;\n            streamedTokenHost.appendChild(addedPart);\n        }\n        // Add \"streaming-in-progress\" indicator\n        if (this.options.streaming) {\n            const streamingIndicator = document.createElement('span');\n            streamingIndicator.className = STREAMING_INDICATOR_CLASS;\n            streamedTokenHost.appendChild(streamingIndicator);\n        }\n        if (placeHolderLines.length > 0) {\n            const placeholderLinesNode = document.createTextNode(placeHolderLines);\n            streamedTokenHost.appendChild(placeholderLinesNode);\n        }\n    }\n    destroy(dom) {\n        if (this.options.onPointerOver) {\n            dom.removeEventListener('pointerover', this.options.onPointerOver);\n        }\n        if (this.options.onPointerLeave) {\n            dom.removeEventListener('pointerleave', this.options.onPointerLeave);\n        }\n        super.destroy(dom);\n    }\n}\n/**\n * Spacers are used to reduce height jitter in the transition between multi-line inline suggestions.\n * In particular, when user removes a letter they will often get a new suggestion in split-second,\n * but without spacer they would see the editor collapse in height and then elongate again.\n */\nclass TransientSpacerWidget extends GhostTextWidget {\n    constructor() {\n        super(...arguments);\n        this.isSpacer = true;\n    }\n}\nclass TransientLineSpacerWidget extends TransientSpacerWidget {\n    toDOM() {\n        const wrap = super.toDOM();\n        wrap.classList.add(TRANSIENT_LINE_SPACER_CLASS);\n        wrap.style.animationDelay = GhostTextManager.spacerRemovalDelay + 'ms';\n        wrap.style.animationDuration =\n            GhostTextManager.spacerRemovalDuration + 'ms';\n        return wrap;\n    }\n}\nclass TransientLetterSpacerWidget extends TransientSpacerWidget {\n    get content() {\n        return this.options.content[0];\n    }\n    toDOM() {\n        const wrap = super.toDOM();\n        wrap.classList.add(TRANSIENT_LETTER_SPACER_CLASS);\n        return wrap;\n    }\n}\nvar Private;\n(function (Private) {\n    let GhostAction;\n    (function (GhostAction) {\n        GhostAction[GhostAction[\"Set\"] = 0] = \"Set\";\n        GhostAction[GhostAction[\"Remove\"] = 1] = \"Remove\";\n        GhostAction[GhostAction[\"FilterAndUpdate\"] = 2] = \"FilterAndUpdate\";\n    })(GhostAction || (GhostAction = {}));\n    Private.addMark = StateEffect.define({\n        map: (old, change) => ({\n            ...old,\n            from: change.mapPos(old.from),\n            to: change.mapPos(old.from + old.content.length)\n        })\n    });\n    Private.removeMark = StateEffect.define();\n    /**\n     * Decide what should be done for transaction effects.\n     */\n    function chooseAction(tr) {\n        // This function can short-circuit because at any time there is no more than one ghost text.\n        for (let e of tr.effects) {\n            if (e.is(Private.addMark)) {\n                return {\n                    action: GhostAction.Set,\n                    spec: e.value\n                };\n            }\n            else if (e.is(Private.removeMark)) {\n                return {\n                    action: GhostAction.Remove\n                };\n            }\n        }\n        if (tr.docChanged || tr.selection) {\n            return {\n                action: GhostAction.FilterAndUpdate\n            };\n        }\n        return null;\n    }\n    function createWidget(spec, tr) {\n        const ghost = Decoration.widget({\n            widget: new GhostTextWidget(spec),\n            side: 1,\n            ghostSpec: spec\n        });\n        // Widget decorations can only have zero-length ranges\n        return ghost.range(Math.min(spec.from, tr.newDoc.length), Math.min(spec.from, tr.newDoc.length));\n    }\n    function createSpacer(spec, tr, timeout = 1000) {\n        // no spacer needed if content is only one character long.\n        if (spec.content.length < 2) {\n            return [];\n        }\n        const timeoutInfo = {\n            elapsed: false\n        };\n        setTimeout(() => {\n            timeoutInfo.elapsed = true;\n        }, timeout);\n        const characterSpacer = Decoration.widget({\n            widget: new TransientLetterSpacerWidget(spec),\n            side: 1,\n            timeoutInfo\n        });\n        const lineSpacer = Decoration.widget({\n            widget: new TransientLineSpacerWidget(spec),\n            side: 1,\n            timeoutInfo\n        });\n        // We add two different spacers: one to temporarily preserve height of as many lines\n        // as there were in the content, and the other (character spacer) to ensure that\n        // cursor is not malformed by the presence of the line spacer.\n        return [\n            characterSpacer.range(Math.min(spec.from, tr.newDoc.length), Math.min(spec.from, tr.newDoc.length)),\n            lineSpacer.range(Math.min(spec.from, tr.newDoc.length), Math.min(spec.from, tr.newDoc.length))\n        ];\n    }\n    Private.markField = StateField.define({\n        create() {\n            return Decoration.none;\n        },\n        update(marks, tr) {\n            const data = chooseAction(tr);\n            // remove spacers after timeout\n            marks = marks.update({\n                filter: (_from, _to, value) => {\n                    if (value.spec.widget instanceof TransientSpacerWidget) {\n                        return !value.spec.timeoutInfo.elapsed;\n                    }\n                    return true;\n                }\n            });\n            if (!data) {\n                return marks.map(tr.changes);\n            }\n            switch (data.action) {\n                case GhostAction.Set: {\n                    const spec = data.spec;\n                    const newWidget = createWidget(spec, tr);\n                    return marks.update({\n                        add: [newWidget],\n                        filter: (_from, _to, value) => value === newWidget.value\n                    });\n                }\n                case GhostAction.Remove:\n                    return marks.update({\n                        filter: () => false\n                    });\n                case GhostAction.FilterAndUpdate: {\n                    let cursor = marks.iter();\n                    // skip over spacer if any\n                    while (cursor.value &&\n                        cursor.value.spec.widget instanceof TransientSpacerWidget) {\n                        cursor.next();\n                    }\n                    if (!cursor.value) {\n                        // short-circuit if no widgets are present, or if only spacer was present\n                        return marks.map(tr.changes);\n                    }\n                    const originalSpec = cursor.value.spec.ghostSpec;\n                    const spec = { ...originalSpec };\n                    let shouldRemoveGhost = false;\n                    tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {\n                        if (shouldRemoveGhost) {\n                            return;\n                        }\n                        if (fromA === toA && fromB !== toB) {\n                            // text was inserted without modifying old text\n                            for (let lineNumber = 0; lineNumber < inserted.lines; lineNumber++) {\n                                const lineContent = inserted.lineAt(lineNumber).text;\n                                const line = lineNumber > 0 ? '\\n' + lineContent : lineContent;\n                                if (spec.content.startsWith(line)) {\n                                    spec.content = spec.content.slice(line.length);\n                                    spec.from += line.length;\n                                }\n                                else {\n                                    shouldRemoveGhost = true;\n                                    break;\n                                }\n                            }\n                        }\n                        else if (fromB === toB && fromA !== toA) {\n                            // text was removed\n                            shouldRemoveGhost = true;\n                        }\n                        else {\n                            // text was replaced\n                            shouldRemoveGhost = true;\n                            // TODO: could check if the previous spec matches\n                        }\n                    });\n                    // removing multi-line widget would cause the code cell to jump; instead\n                    // we add a temporary spacer widget(s) which will be removed in a future update\n                    // allowing a slight delay between getting a new suggestion and reducing cell height\n                    const newWidgets = shouldRemoveGhost\n                        ? createSpacer(originalSpec, tr)\n                        : [createWidget(spec, tr)];\n                    const newValues = newWidgets.map(widget => widget.value);\n                    marks = marks.update({\n                        add: newWidgets,\n                        filter: (_from, _to, value) => newValues.includes(value)\n                    });\n                    if (shouldRemoveGhost) {\n                        // TODO this can error out when deleting text, ideally a clean solution would be used.\n                        try {\n                            marks = marks.map(tr.changes);\n                        }\n                        catch (e) {\n                            console.warn(e);\n                            return Decoration.none;\n                        }\n                    }\n                    return marks;\n                }\n            }\n        },\n        provide: f => EditorView.decorations.from(f)\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=ghost.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { HoverBox, kernelIcon, Toolbar } from '@jupyterlab/ui-components';\nimport { Signal } from '@lumino/signaling';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { GhostTextManager } from './ghost';\nconst INLINE_COMPLETER_CLASS = 'jp-InlineCompleter';\nconst INLINE_COMPLETER_ACTIVE_CLASS = 'jp-mod-inline-completer-active';\nconst HOVER_CLASS = 'jp-InlineCompleter-hover';\nconst PROGRESS_BAR_CLASS = 'jp-InlineCompleter-progressBar';\n/**\n * Widget enabling user to choose among inline completions,\n * typically by pressing next/previous buttons, and showing\n * additional metadata about active completion, such as\n * inline completion provider name.\n */\nexport class InlineCompleter extends Widget {\n    constructor(options) {\n        var _a, _b;\n        super({ node: document.createElement('div') });\n        this._clearHoverTimeout = null;\n        this._current = 0;\n        this._editor = null;\n        this._lastItem = null;\n        this._model = null;\n        this._providerWidget = new Widget();\n        this._showShortcuts = InlineCompleter.defaultSettings.showShortcuts;\n        this._showWidget = InlineCompleter.defaultSettings.showWidget;\n        this._suggestionsCounter = new Widget();\n        this._toolbar = new Toolbar();\n        this.model = (_a = options.model) !== null && _a !== void 0 ? _a : null;\n        this.editor = (_b = options.editor) !== null && _b !== void 0 ? _b : null;\n        this.addClass(INLINE_COMPLETER_CLASS);\n        this.addClass('jp-ThemedContainer');\n        this._ghostManager = new GhostTextManager({\n            onBlur: this._onEditorBlur.bind(this)\n        });\n        this._trans = options.trans;\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(this._suggestionsCounter);\n        layout.addWidget(this.toolbar);\n        layout.addWidget(this._providerWidget);\n        this._progressBar = document.createElement('div');\n        this._progressBar.className = PROGRESS_BAR_CLASS;\n        this.node.appendChild(this._progressBar);\n        this._updateShortcutsVisibility();\n        this._updateDisplay();\n        // Allow the node to receive focus, which prevents removing the ghost text\n        // when user mis-clicks on the tooltip instead of the button in the tooltip.\n        this.node.tabIndex = 0;\n    }\n    /**\n     * Toolbar with buttons such as previous/next/accept.\n     */\n    get toolbar() {\n        return this._toolbar;\n    }\n    /**\n     * The editor used by the completion widget.\n     */\n    get editor() {\n        return this._editor;\n    }\n    set editor(newValue) {\n        var _a;\n        (_a = this.model) === null || _a === void 0 ? void 0 : _a.reset();\n        this._editor = newValue;\n    }\n    /**\n     * The model used by the completer widget.\n     */\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        if ((!model && !this._model) || model === this._model) {\n            return;\n        }\n        if (this._model) {\n            this._model.suggestionsChanged.disconnect(this._onModelSuggestionsChanged, this);\n            this._model.filterTextChanged.disconnect(this._onModelFilterTextChanged, this);\n            this._model.provisionProgress.disconnect(this._onProvisionProgress, this);\n        }\n        this._model = model;\n        if (this._model) {\n            this._model.suggestionsChanged.connect(this._onModelSuggestionsChanged, this);\n            this._model.filterTextChanged.connect(this._onModelFilterTextChanged, this);\n            this._model.provisionProgress.connect(this._onProvisionProgress, this);\n        }\n    }\n    cycle(direction) {\n        var _a, _b;\n        const items = (_b = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions) === null || _b === void 0 ? void 0 : _b.items;\n        if (!items) {\n            return;\n        }\n        if (direction === 'next') {\n            const proposed = this._current + 1;\n            this._current = proposed === items.length ? 0 : proposed;\n        }\n        else {\n            const proposed = this._current - 1;\n            this._current = proposed === -1 ? items.length - 1 : proposed;\n        }\n        this._updateStreamTracking();\n        this._render();\n    }\n    accept() {\n        const model = this.model;\n        const candidate = this.current;\n        const editor = this._editor;\n        if (!editor || !model || !candidate) {\n            return;\n        }\n        const position = model.cursor;\n        const value = candidate.insertText;\n        const cursorBeforeChange = editor.getOffsetAt(editor.getCursorPosition());\n        const requestPosition = editor.getOffsetAt(position);\n        const start = requestPosition;\n        const end = cursorBeforeChange;\n        const transactions = {\n            changes: { from: start, to: end, insert: value }\n        };\n        if (cursorBeforeChange <= end && cursorBeforeChange >= start) {\n            transactions.selection = { anchor: start + value.length };\n        }\n        editor.editor.dispatch(transactions);\n        model.reset();\n        this.update();\n    }\n    get current() {\n        var _a;\n        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;\n        if (!completions) {\n            return null;\n        }\n        return completions.items[this._current];\n    }\n    _updateStreamTracking() {\n        if (this._lastItem) {\n            this._lastItem.stream.disconnect(this._onStream, this);\n        }\n        const current = this.current;\n        if (current) {\n            current.stream.connect(this._onStream, this);\n        }\n        this._lastItem = current;\n    }\n    _onStream(_emitter, _change) {\n        var _a;\n        // TODO handle stuck streams, i.e. if we connected and received 'opened'\n        // but then did not receive 'closed' for a long time we should disconnect\n        // and update widget with an 'timed out' status.\n        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;\n        if (!completions || !completions.items || completions.items.length === 0) {\n            return;\n        }\n        if (this.isHidden) {\n            return;\n        }\n        const candidate = completions.items[this._current];\n        this._setText(candidate);\n    }\n    /**\n     * Change user-configurable settings.\n     */\n    configure(settings) {\n        this._showWidget = settings.showWidget;\n        this._updateDisplay();\n        if (settings.showShortcuts !== this._showShortcuts) {\n            this._showShortcuts = settings.showShortcuts;\n            this._updateShortcutsVisibility();\n        }\n        GhostTextManager.streamingAnimation = settings.streamingAnimation;\n        GhostTextManager.spacerRemovalDelay = Math.max(0, settings.editorResizeDelay - 300);\n        GhostTextManager.spacerRemovalDuration = Math.max(0, Math.min(300, settings.editorResizeDelay - 300));\n        this._minLines = settings.minLines;\n        this._maxLines = settings.maxLines;\n        this._reserveSpaceForLongest = settings.reserveSpaceForLongest;\n        this._suppressIfTabCompleterActive = settings.suppressIfTabCompleterActive;\n    }\n    /**\n     * Whether to suppress the inline completer when tab completer is active.\n     */\n    get suppressIfTabCompleterActive() {\n        return this._suppressIfTabCompleterActive;\n    }\n    /**\n     * Whether the inline completer is active.\n     */\n    get isActive() {\n        var _a;\n        return !!((_a = this.editor) === null || _a === void 0 ? void 0 : _a.host.classList.contains(INLINE_COMPLETER_ACTIVE_CLASS));\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the dock panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        switch (event.type) {\n            case 'pointerdown':\n                this._evtPointerdown(event);\n                break;\n            case 'scroll':\n                this._evtScroll(event);\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle `update-request` messages.\n     */\n    onUpdateRequest(msg) {\n        super.onUpdateRequest(msg);\n        const model = this._model;\n        if (!model) {\n            return;\n        }\n        let reply = model.completions;\n        // If there are no items, hide.\n        if (!reply || !reply.items || reply.items.length === 0) {\n            if (!this.isHidden) {\n                this.hide();\n            }\n            return;\n        }\n        if (this.isHidden) {\n            this.show();\n            this._setGeometry();\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        document.addEventListener('scroll', this, true);\n        document.addEventListener('pointerdown', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        document.removeEventListener('scroll', this, true);\n        document.removeEventListener('pointerdown', this, true);\n    }\n    /**\n     * Handle pointerdown events for the widget.\n     */\n    _evtPointerdown(event) {\n        var _a;\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        const target = event.target;\n        if (this.node.contains(target)) {\n            return true;\n        }\n        this.hide();\n        (_a = this.model) === null || _a === void 0 ? void 0 : _a.reset();\n    }\n    /**\n     * Handle scroll events for the widget\n     */\n    _evtScroll(event) {\n        if (this.isHidden || !this._editor) {\n            return;\n        }\n        const { node } = this;\n        // All scrolls except scrolls in the actual hover box node may cause the\n        // referent editor that anchors the node to move, so the only scroll events\n        // that can safely be ignored are ones that happen inside the hovering node.\n        if (node.contains(event.target)) {\n            return;\n        }\n        // Set the geometry of the node asynchronously.\n        requestAnimationFrame(() => {\n            this._setGeometry();\n        });\n    }\n    _onEditorBlur(event) {\n        var _a;\n        if (this.node.contains(event.relatedTarget)) {\n            // Cancel removing ghost text if our node is receiving focus\n            return false;\n        }\n        // The ghost text will be removed, so nothing to accept\n        (_a = this._editor) === null || _a === void 0 ? void 0 : _a.host.classList.remove(INLINE_COMPLETER_ACTIVE_CLASS);\n        // Hide the widget if editor was blurred.\n        this.hide();\n    }\n    _onModelSuggestionsChanged(_emitter, args) {\n        var _a;\n        if (!this.isAttached) {\n            this.update();\n            return;\n        }\n        if (args.event === 'set') {\n            this._current = (_a = args.indexMap.get(this._current)) !== null && _a !== void 0 ? _a : 0;\n        }\n        else if (args.event === 'clear') {\n            const editor = this.editor;\n            if (editor) {\n                this._ghostManager.clearGhosts(editor.editor);\n                editor.host.classList.remove(INLINE_COMPLETER_ACTIVE_CLASS);\n            }\n        }\n        this._updateStreamTracking();\n        this.update();\n        this._render();\n    }\n    _onModelFilterTextChanged(_emitter, mapping) {\n        var _a, _b;\n        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;\n        if (!completions || !completions.items || completions.items.length === 0) {\n            return;\n        }\n        this._current = (_b = mapping.get(this._current)) !== null && _b !== void 0 ? _b : 0;\n        this._updateStreamTracking();\n        // Because the signal will be emitted during `EditorView.update` we want to\n        // wait for the update to complete before calling `this._render()`. As there\n        // is no API to check if update is done, we instead defer to next engine tick.\n        setTimeout(() => {\n            this._render();\n            // (reading layout to get coordinate to position hoverbox is not allowed either)\n            this._setGeometry();\n        }, 0);\n    }\n    _onProvisionProgress(_emitter, progress) {\n        requestAnimationFrame(() => {\n            if (progress.pendingProviders === 0) {\n                this._progressBar.style.display = 'none';\n            }\n            else {\n                this._progressBar.style.display = '';\n                this._progressBar.style.width =\n                    (100 * progress.pendingProviders) / progress.totalProviders + '%';\n            }\n        });\n    }\n    _render() {\n        var _a, _b;\n        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;\n        if (!completions || !completions.items || completions.items.length === 0) {\n            return;\n        }\n        const candidate = completions.items[this._current];\n        this._setText(candidate);\n        if (this._showWidget === 'never') {\n            return;\n        }\n        this._suggestionsCounter.node.innerText = this._trans.__('%1/%2', this._current + 1, completions.items.length);\n        this._providerWidget.node.title = this._trans.__('Provider: %1', candidate.provider.name);\n        const icon = (_b = candidate.provider.icon) !== null && _b !== void 0 ? _b : kernelIcon;\n        icon.render(this._providerWidget.node);\n    }\n    _setText(item) {\n        var _a, _b, _c;\n        const text = item.insertText;\n        const editor = this._editor;\n        const model = this._model;\n        if (!model || !editor) {\n            return;\n        }\n        const view = editor.editor;\n        let minLines;\n        if (this._reserveSpaceForLongest) {\n            const items = (_c = (_b = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions) === null || _b === void 0 ? void 0 : _b.items) !== null && _c !== void 0 ? _c : [];\n            const longest = Math.max(...items.map(i => i.insertText.split('\\n').length));\n            minLines = Math.max(this._minLines, longest);\n        }\n        else {\n            minLines = this._minLines;\n        }\n        this._ghostManager.placeGhost(view, {\n            from: editor.getOffsetAt(model.cursor),\n            content: text,\n            providerId: item.provider.identifier,\n            addedPart: item.lastStreamed,\n            streaming: item.streaming,\n            minLines: minLines,\n            maxLines: this._maxLines,\n            onPointerOver: this._onPointerOverGhost.bind(this),\n            onPointerLeave: this._onPointerLeaveGhost.bind(this),\n            error: item.error\n        });\n        editor.host.classList.add(INLINE_COMPLETER_ACTIVE_CLASS);\n    }\n    _onPointerOverGhost() {\n        if (this._clearHoverTimeout !== null) {\n            window.clearTimeout(this._clearHoverTimeout);\n            this._clearHoverTimeout = null;\n        }\n        this.node.classList.add(HOVER_CLASS);\n    }\n    _onPointerLeaveGhost() {\n        // Remove after a small delay to avoid flicker when moving cursor\n        // between the lines or around the edges of the ghost text.\n        this._clearHoverTimeout = window.setTimeout(() => this.node.classList.remove(HOVER_CLASS), 500);\n    }\n    _setGeometry() {\n        const { node } = this;\n        const model = this._model;\n        const editor = this._editor;\n        if (!editor || !model || !model.cursor) {\n            return;\n        }\n        const host = editor.host.closest('.jp-MainAreaWidget > .lm-Widget') ||\n            editor.host;\n        let anchor;\n        try {\n            const maybeAnchor = editor.getCoordinateForPosition(model.cursor);\n            if (!maybeAnchor) {\n                throw Error('No coordinates for cursor position');\n            }\n            anchor = maybeAnchor;\n        }\n        catch (_a) {\n            // if coordinate is no longer in editor (e.g. after deleting a line), hide widget\n            this.hide();\n            return;\n        }\n        HoverBox.setGeometry({\n            anchor,\n            host: host,\n            maxHeight: 40,\n            minHeight: 20,\n            node: node,\n            privilege: 'forceAbove',\n            outOfViewDisplay: {\n                top: 'stick-outside',\n                bottom: 'stick-inside',\n                left: 'stick-inside',\n                right: 'stick-outside'\n            }\n        });\n    }\n    _updateShortcutsVisibility() {\n        this.node.dataset.showShortcuts = this._showShortcuts + '';\n    }\n    _updateDisplay() {\n        this.node.dataset.display = this._showWidget;\n    }\n}\n/**\n * A namespace for inline completer statics.\n */\n(function (InlineCompleter) {\n    /**\n     * Defaults for runtime user-configurable settings.\n     */\n    InlineCompleter.defaultSettings = {\n        showWidget: 'onHover',\n        showShortcuts: true,\n        streamingAnimation: 'uncover',\n        providers: {},\n        minLines: 2,\n        maxLines: 4,\n        editorResizeDelay: 1000,\n        reserveSpaceForLongest: false,\n        suppressIfTabCompleterActive: true\n    };\n    /**\n     * Model for inline completions.\n     */\n    class Model {\n        constructor() {\n            this.suggestionsChanged = new Signal(this);\n            this.filterTextChanged = new Signal(this);\n            this.provisionProgress = new Signal(this);\n            this._isDisposed = false;\n            this._completions = null;\n        }\n        setCompletions(reply) {\n            var _a, _b;\n            const previousPositions = new Map((_b = (_a = this._completions) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.map((item, index) => [item.insertText, index]));\n            this._completions = reply;\n            const indexMap = new Map(reply.items.map((item, newIndex) => [\n                previousPositions.get(item.insertText),\n                newIndex\n            ]));\n            this.suggestionsChanged.emit({\n                event: 'set',\n                indexMap\n            });\n        }\n        appendCompletions(reply) {\n            if (!this._completions || !this._completions.items) {\n                console.warn('No completions to append to');\n                return;\n            }\n            this._completions.items.push(...reply.items);\n            this.suggestionsChanged.emit({ event: 'append' });\n        }\n        notifyProgress(progress) {\n            this.provisionProgress.emit(progress);\n        }\n        get cursor() {\n            return this._cursor;\n        }\n        set cursor(value) {\n            this._cursor = value;\n        }\n        get completions() {\n            return this._completions;\n        }\n        reset() {\n            this._completions = null;\n            this.suggestionsChanged.emit({ event: 'clear' });\n        }\n        /**\n         * Get whether the model is disposed.\n         */\n        get isDisposed() {\n            return this._isDisposed;\n        }\n        handleTextChange(sourceChange) {\n            var _a;\n            const completions = this._completions;\n            if (!completions ||\n                !completions.items ||\n                completions.items.length === 0) {\n                return;\n            }\n            const originalPositions = new Map(completions.items.map((item, index) => [item, index]));\n            for (let change of (_a = sourceChange.sourceChange) !== null && _a !== void 0 ? _a : []) {\n                const insert = change.insert;\n                if (insert) {\n                    const items = completions.items.filter(item => {\n                        var _a;\n                        const filterText = (_a = item.filterText) !== null && _a !== void 0 ? _a : item.insertText;\n                        if (!filterText.startsWith(insert)) {\n                            return false;\n                        }\n                        item.filterText = filterText.substring(insert.length);\n                        item.insertText = item.insertText.substring(insert.length);\n                        return true;\n                    });\n                    if (items.length === 0) {\n                        // all items from this provider were filtered out\n                        this._completions = null;\n                    }\n                    completions.items = items;\n                }\n                else {\n                    if (!change.retain) {\n                        this._completions = null;\n                    }\n                }\n            }\n            const indexMap = new Map(completions.items.map((item, newIndex) => [\n                originalPositions.get(item),\n                newIndex\n            ]));\n            this.filterTextChanged.emit(indexMap);\n        }\n        handleSelectionChange(range) {\n            const initialCursor = this.cursor;\n            if (!initialCursor) {\n                return;\n            }\n            const { start, end } = range;\n            if (start.column !== end.column || start.line !== end.line) {\n                // Cancel if user started selecting text.\n                this.reset();\n            }\n            if (start.line !== initialCursor.line ||\n                start.column < initialCursor.column) {\n                // Cancel if user moved cursor to next line or receded to before the origin\n                this.reset();\n            }\n        }\n        /**\n         * Dispose of the resources held by the model.\n         */\n        dispose() {\n            // Do nothing if already disposed.\n            if (this._isDisposed) {\n                return;\n            }\n            this._isDisposed = true;\n            Signal.clearData(this);\n        }\n    }\n    InlineCompleter.Model = Model;\n})(InlineCompleter || (InlineCompleter = {}));\n//# sourceMappingURL=inline.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nimport { ProviderReconciliator } from './reconciliator';\nimport { CONTEXT_PROVIDER_ID } from './default/contextprovider';\nimport { KERNEL_PROVIDER_ID } from './default/kernelprovider';\nimport { CompletionHandler } from './handler';\nimport { CompleterModel } from './model';\nimport { InlineCompleter } from './inline';\nimport { Completer } from './widget';\n/**\n * A manager for completion providers.\n */\nexport class CompletionProviderManager {\n    /**\n     * Construct a new completer manager.\n     */\n    constructor() {\n        /**\n         * The set of activated providers\n         */\n        this._activeProviders = new Set([KERNEL_PROVIDER_ID, CONTEXT_PROVIDER_ID]);\n        this._inlineCompleterSettings = InlineCompleter.defaultSettings;\n        this._providers = new Map();\n        this._inlineProviders = new Map();\n        this._panelHandlers = new Map();\n        this._mostRecentContext = new Map();\n        this._activeProvidersChanged = new Signal(this);\n        this._selected = new Signal(this);\n        this._inlineCompleterFactory = null;\n    }\n    /**\n     * Signal emitted when active providers list is changed.\n     */\n    get activeProvidersChanged() {\n        return this._activeProvidersChanged;\n    }\n    /**\n     * Signal emitted when a selection is made from a completer menu.\n     */\n    get selected() {\n        return this._selected;\n    }\n    /**\n     * Set provider timeout.\n     *\n     * @param {number} timeout - value of timeout in millisecond.\n     */\n    setTimeout(timeout) {\n        this._timeout = timeout;\n    }\n    /**\n     * Enable/disable the document panel.\n     */\n    setShowDocumentationPanel(showDoc) {\n        this._panelHandlers.forEach(handler => (handler.completer.showDocsPanel = showDoc));\n        this._showDoc = showDoc;\n    }\n    /**\n     * Whether to suppress the tab completer when inline completions are presented.\n     */\n    setSuppressIfInlineCompleterActive(suppress) {\n        this._panelHandlers.forEach(handler => (handler.completer.suppressIfInlineCompleterActive = suppress));\n        this._suppressIfInlineCompleterActive = suppress;\n    }\n    /**\n     * Enable/disable continuous hinting mode.\n     */\n    setContinuousHinting(value) {\n        this._panelHandlers.forEach(handler => (handler.autoCompletion = value));\n        this._autoCompletion = value;\n    }\n    /**\n     * Register a completer provider with the manager.\n     *\n     * @param {ICompletionProvider} provider - the provider to be registered.\n     */\n    registerProvider(provider) {\n        const identifier = provider.identifier;\n        if (this._providers.has(identifier)) {\n            console.warn(`Completion provider with identifier ${identifier} is already registered`);\n        }\n        else {\n            this._providers.set(identifier, provider);\n            this._panelHandlers.forEach((handler, id) => {\n                void this.updateCompleter(this._mostRecentContext.get(id));\n            });\n        }\n    }\n    registerInlineProvider(provider) {\n        const identifier = provider.identifier;\n        if (this._inlineProviders.has(identifier)) {\n            console.warn(`Completion provider with identifier ${identifier} is already registered`);\n        }\n        else {\n            this._inlineProviders.set(identifier, provider);\n            this._panelHandlers.forEach((handler, id) => {\n                void this.updateCompleter(this._mostRecentContext.get(id));\n            });\n        }\n    }\n    /**\n     *\n     * Return the map of providers.\n     */\n    getProviders() {\n        return this._providers;\n    }\n    /**\n     * Activate the providers by id, the list of ids is populated from user setting.\n     * The non-existing providers will be discarded.\n     *\n     * @param {Array<string>} providerIds - Array of strings with ids of provider\n     */\n    activateProvider(providerIds) {\n        this._activeProviders = new Set([]);\n        providerIds.forEach(providerId => {\n            if (this._providers.has(providerId)) {\n                this._activeProviders.add(providerId);\n            }\n        });\n        if (this._activeProviders.size === 0) {\n            this._activeProviders.add(KERNEL_PROVIDER_ID);\n            this._activeProviders.add(CONTEXT_PROVIDER_ID);\n        }\n        this._activeProvidersChanged.emit();\n    }\n    /**\n     * Create or update completer handler of a widget with new context.\n     *\n     * @param newCompleterContext - The completion context.\n     */\n    async updateCompleter(newCompleterContext) {\n        var _a, _b;\n        const { widget, editor, sanitizer } = newCompleterContext;\n        const id = widget.id;\n        const handler = this._panelHandlers.get(id);\n        const firstProvider = [...this._activeProviders][0];\n        const provider = this._providers.get(firstProvider);\n        let renderer = (_a = provider === null || provider === void 0 ? void 0 : provider.renderer) !== null && _a !== void 0 ? _a : Completer.getDefaultRenderer(sanitizer);\n        const modelFactory = provider === null || provider === void 0 ? void 0 : provider.modelFactory;\n        let model;\n        if (modelFactory) {\n            model = await modelFactory.call(provider, newCompleterContext);\n        }\n        else {\n            model = new CompleterModel();\n        }\n        this._mostRecentContext.set(widget.id, newCompleterContext);\n        const options = {\n            model,\n            editor,\n            renderer,\n            sanitizer,\n            showDoc: this._showDoc\n        };\n        if (!handler) {\n            // Create a new handler.\n            const handler = await this._generateHandler(newCompleterContext, options);\n            this._panelHandlers.set(widget.id, handler);\n            handler.completer.selected.connect((completer, insertText) => this._selected.emit({ insertText }));\n            widget.disposed.connect(old => {\n                this.disposeHandler(old.id, handler);\n                this._mostRecentContext.delete(id);\n            });\n        }\n        else {\n            // Update existing completer.\n            const completer = handler.completer;\n            (_b = completer.model) === null || _b === void 0 ? void 0 : _b.dispose();\n            completer.model = options.model;\n            completer.renderer = options.renderer;\n            completer.showDocsPanel = options.showDoc;\n            completer.suppressIfInlineCompleterActive =\n                this._suppressIfInlineCompleterActive;\n            // Update other handler attributes.\n            handler.autoCompletion = this._autoCompletion;\n            if (editor) {\n                handler.editor = editor;\n                handler.reconciliator =\n                    await this.generateReconciliator(newCompleterContext);\n            }\n        }\n    }\n    /**\n     * Invoke the completer in the widget with provided id.\n     *\n     * @param id - the id of notebook panel, console panel or code editor.\n     */\n    invoke(id) {\n        const handler = this._panelHandlers.get(id);\n        if (handler) {\n            handler.invoke();\n        }\n    }\n    /**\n     * Activate `select` command in the widget with provided id.\n     *\n     * @param {string} id - the id of notebook panel, console panel or code editor.\n     */\n    select(id) {\n        const handler = this._panelHandlers.get(id);\n        if (handler) {\n            handler.completer.selectActive();\n        }\n    }\n    /**\n     * Set inline completer factory.\n     */\n    setInlineCompleterFactory(factory) {\n        this._inlineCompleterFactory = factory;\n        this._panelHandlers.forEach((handler, id) => {\n            void this.updateCompleter(this._mostRecentContext.get(id));\n        });\n        if (this.inline) {\n            return;\n        }\n        this.inline = {\n            invoke: (id) => {\n                const handler = this._panelHandlers.get(id);\n                if (handler && handler.inlineCompleter) {\n                    handler.invokeInline();\n                }\n            },\n            isActive: (id) => {\n                const handler = this._panelHandlers.get(id);\n                if (handler && handler.inlineCompleter) {\n                    return handler.inlineCompleter.isActive;\n                }\n                return false;\n            },\n            cycle: (id, direction) => {\n                const handler = this._panelHandlers.get(id);\n                if (handler && handler.inlineCompleter) {\n                    handler.inlineCompleter.cycle(direction);\n                }\n            },\n            accept: (id) => {\n                const handler = this._panelHandlers.get(id);\n                if (handler && handler.inlineCompleter) {\n                    handler.inlineCompleter.accept();\n                }\n            },\n            configure: (settings) => {\n                this._inlineCompleterSettings = settings;\n                for (const [providerId, provider] of this._inlineProviders.entries()) {\n                    if (provider.configure) {\n                        provider.configure(settings.providers[providerId]);\n                    }\n                }\n                this._panelHandlers.forEach((handler, handlerId) => {\n                    if (handler.inlineCompleter) {\n                        handler.inlineCompleter.configure(settings);\n                    }\n                    // trigger update to regenerate reconciliator\n                    void this.updateCompleter(this._mostRecentContext.get(handlerId));\n                });\n            }\n        };\n    }\n    /**\n     * Inline providers information.\n     */\n    get inlineProviders() {\n        return [...this._inlineProviders.values()];\n    }\n    /**\n     * Helper function to generate a `ProviderReconciliator` with provided context.\n     * The `isApplicable` method of provider is used to filter out the providers\n     * which can not be used with provided context.\n     *\n     * @param {ICompletionContext} completerContext - the current completer context\n     */\n    async generateReconciliator(completerContext) {\n        const enabledProviders = [];\n        for (const [id, providerSettings] of Object.entries(this._inlineCompleterSettings.providers)) {\n            if (providerSettings.enabled === true) {\n                enabledProviders.push(id);\n            }\n        }\n        const inlineProviders = [...this._inlineProviders.values()].filter(provider => enabledProviders.includes(provider.identifier));\n        const providers = [];\n        for (const id of this._activeProviders) {\n            const provider = this._providers.get(id);\n            if (provider) {\n                providers.push(provider);\n            }\n        }\n        return new ProviderReconciliator({\n            context: completerContext,\n            providers,\n            inlineProviders,\n            inlineProvidersSettings: this._inlineCompleterSettings.providers,\n            timeout: this._timeout\n        });\n    }\n    /**\n     * Helper to dispose the completer handler on widget disposed event.\n     *\n     * @param {string} id - id of the widget\n     * @param {CompletionHandler} handler - the handler to be disposed.\n     */\n    disposeHandler(id, handler) {\n        var _a, _b, _c, _d;\n        (_a = handler.completer.model) === null || _a === void 0 ? void 0 : _a.dispose();\n        handler.completer.dispose();\n        (_c = (_b = handler.inlineCompleter) === null || _b === void 0 ? void 0 : _b.model) === null || _c === void 0 ? void 0 : _c.dispose();\n        (_d = handler.inlineCompleter) === null || _d === void 0 ? void 0 : _d.dispose();\n        handler.dispose();\n        this._panelHandlers.delete(id);\n    }\n    /**\n     * Helper to generate a completer handler from provided context.\n     */\n    async _generateHandler(completerContext, options) {\n        const completer = new Completer(options);\n        const inlineCompleter = this._inlineCompleterFactory\n            ? this._inlineCompleterFactory.factory({\n                ...options,\n                model: new InlineCompleter.Model()\n            })\n            : undefined;\n        completer.hide();\n        Widget.attach(completer, document.body);\n        if (inlineCompleter) {\n            Widget.attach(inlineCompleter, document.body);\n            inlineCompleter.hide();\n            inlineCompleter.configure(this._inlineCompleterSettings);\n        }\n        const reconciliator = await this.generateReconciliator(completerContext);\n        const handler = new CompletionHandler({\n            completer,\n            inlineCompleter,\n            reconciliator: reconciliator\n        });\n        handler.editor = completerContext.editor;\n        return handler;\n    }\n}\n//# sourceMappingURL=manager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport inlineSvgStr from '../style/icons/inline.svg';\nimport widgetSvgStr from '../style/icons/widget.svg';\nexport const inlineCompleterIcon = new LabIcon({\n    name: 'completer:inline',\n    svgstr: inlineSvgStr\n});\nexport const completerWidgetIcon = new LabIcon({\n    name: 'completer:widget',\n    svgstr: widgetSvgStr\n});\n//# sourceMappingURL=icons.js.map","import { nullTranslator } from '@jupyterlab/translation';\nimport { historyIcon } from '@jupyterlab/ui-components';\n/**\n * An example inline completion provider using history to populate suggestions.\n */\nexport class HistoryInlineCompletionProvider {\n    constructor(options) {\n        this.options = options;\n        this.identifier = '@jupyterlab/inline-completer:history';\n        this._maxSuggestions = 100;\n        const translator = options.translator || nullTranslator;\n        this._trans = translator.load('jupyterlab');\n    }\n    get name() {\n        return this._trans.__('History');\n    }\n    get icon() {\n        return historyIcon;\n    }\n    get schema() {\n        return {\n            properties: {\n                maxSuggestions: {\n                    title: this._trans.__('Maximum number of suggestions'),\n                    description: this._trans.__('The maximum number of suggestions to retrieve from history.'),\n                    type: 'number'\n                }\n            },\n            default: {\n                // make this provider opt-in\n                enabled: false,\n                maxSuggestions: 100\n            }\n        };\n    }\n    configure(settings) {\n        var _a;\n        this._maxSuggestions = (_a = settings.maxSuggestions) !== null && _a !== void 0 ? _a : 100;\n    }\n    async fetch(request, context, trigger) {\n        var _a;\n        const kernel = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            throw new Error('No kernel for completion request.');\n        }\n        const multiLinePrefix = request.text.slice(0, request.offset);\n        const linePrefix = multiLinePrefix.split('\\n').slice(-1)[0];\n        let historyRequest;\n        const items = [];\n        if (linePrefix === '') {\n            historyRequest = {\n                output: false,\n                raw: true,\n                hist_access_type: 'tail',\n                n: this._maxSuggestions\n            };\n            const reply = await kernel.requestHistory(historyRequest);\n            if (reply.content.status === 'ok') {\n                let history = reply.content.history;\n                const historyFrequencyMap = new Map();\n                // Count the frequency of each element\n                for (const entry of history.reverse()) {\n                    const sourceLines = entry[2];\n                    historyFrequencyMap.set(sourceLines, (historyFrequencyMap.get(sourceLines) || 0) + 1);\n                }\n                const frequencyHistory = Array.from(historyFrequencyMap.entries());\n                const sortedFrequencyHistory = frequencyHistory.sort((a, b) => {\n                    if (a[1] > b[1]) {\n                        return -1;\n                    }\n                    else if (a[1] < b[1]) {\n                        return 1;\n                    }\n                    else {\n                        return 0;\n                    }\n                });\n                for (const entry of sortedFrequencyHistory) {\n                    items.push({\n                        insertText: entry[0]\n                    });\n                }\n            }\n        }\n        else {\n            historyRequest = {\n                output: false,\n                raw: true,\n                hist_access_type: 'search',\n                pattern: linePrefix + '*',\n                unique: true,\n                n: this._maxSuggestions\n            };\n            const reply = await kernel.requestHistory(historyRequest);\n            if (reply.content.status === 'ok') {\n                for (const entry of reply.content.history) {\n                    const sourceLines = entry[2].split('\\n');\n                    for (let i = 0; i < sourceLines.length; i++) {\n                        const line = sourceLines[i];\n                        if (line.startsWith(linePrefix)) {\n                            const followingLines = line.slice(linePrefix.length, line.length) +\n                                '\\n' +\n                                sourceLines.slice(i + 1).join('\\n');\n                            items.push({\n                                insertText: followingLines\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return { items };\n    }\n}\n//# sourceMappingURL=inlinehistoryprovider.js.map"],"names":["CompletionTriggerKind","InlineCompletionTriggerKind","IInlineCompleterFactory","Token","ICompletionProviderManager","CompletionHandler","constructor","options","this","_fetchingInline","_editor","_enabled","_isDisposed","_autoCompletion","_continuousInline","_tabCompleterActive","completer","inlineCompleter","selected","connect","onCompletionSelected","visibilityChanged","onVisibilityChanged","_reconciliator","reconciliator","editor","newValue","isDisposed","model","host","classList","remove","COMPLETER_ENABLED_CLASS","COMPLETER_ACTIVE_CLASS","selections","changed","disconnect","onSelectionsChanged","sharedModel","_onSharedModelChanged","reset","autoCompletion","value","dispose","Signal","clearData","invokeInline","_makeInlineRequest","getCursorPosition","Invoke","catch","reason","console","warn","invoke","MessageLoop","sendMessage","Msg","InvokeRequest","processMessage","msg","type","onInvokeRequest","getState","position","text","getSource","line","column","val","patch","createPatch","start","end","cursorBeforeChange","getOffsetAt","transactions","changes","from","to","insert","selection","anchor","length","dispatch","original","_makeRequest","Invoked","_a","inlineModel","handleSelectionChange","getSelection","subsetMatch","getLine","slice","match","add","COMPLETER_LINE_BEGINNING_CLASS","handleCursorChange","onTextChanged","str","shouldShowContinuousHint","isVisible","TriggerCharacter","handleTextChange","Automatic","isHidden","focus","sourceChange","trigger","Promise","reject","Error","request","_composeRequest","state","fetch","then","reply","_updateModel","suppressIfInlineCompleterActive","isActive","setCompletionItems","items","p","cursor","current","promises","fetchInline","cancelled","completed","Set","promise","result","size","suppressIfTabCompleterActive","setCompletions","appendCompletions","e","finally","remaining","notifyProgress","pendingProviders","totalProviders","mimeType","offset","Text","jsIndexToCharIndex","charIndexToJsIndex","StraemEvent","Message","Private","escapeHTML","node","document","createElement","textContent","innerHTML","CompleterModel","processedItemsCache","_current","_cursor","_completionItems","_original","_query","_subsetMatch","_typeMap","_orderedTypes","_stateChanged","_queryChanged","_processedToOriginalItem","_resolvingItem","stateChanged","queryChanged","JSONExt","deepEqual","_reset","emit","undefined","originalLine","split","currentLine","query","substring","ending","lastIndexOf","origin","completionItems","markedItems","_markup","map","it","processedItem","WeakMap","originalItem","item","_escapeItemLabel","findOrderedCompletionItemTypes","typeMap","orderedTypes","change","cursorDelta","inputDelta","last","hard","results","index","label","indexOf","StringExt","matchSumOfSquares","marked","highlight","indices","mark","highlightedItem","Object","assign","join","insertText","push","score","sort","scoreCmp","resolveItem","indexOrValue","get","_resolveItemByValue","completionItem","resolvedItem","resolve","activeItem","keys","forEach","key","error","inplace","escapedLabel","newItem","hadQuery","KNOWN_TYPES","KNOWN_MAP","reduce","acc","a","b","_b","_c","delta","localeCompare","newTypeSet","includes","has","newTypes","Array","concat","findOrderedTypes","filtered","filter","ITEM_CLASS","ACTIVE_CLASS","LIST_CLASS","USE_CAPTURE","Completer","Widget","_d","super","_activeIndex","_model","_selected","_visibilityChanged","_indexChanged","_lastSubsetMatch","_geometryLock","_geometryCounter","_docPanelExpanded","_renderCounter","sanitizer","Sanitizer","_defaultRenderer","getDefaultRenderer","_renderer","renderer","_docPanel","_createDocPanelNode","addClass","_updateConstraints","tempNode","style","visibility","overflowY","body","appendChild","computedStyle","window","getComputedStyle","_maxHeight","parseInt","maxHeight","_minHeight","minHeight","_scrollbarWidth","offsetWidth","clientWidth","removeChild","tempDocPanel","_docPanelWidth","measureSize","width","activeIndex","indexChanged","onModelStateChanged","onModelQueryChanged","showDocsPanel","showDoc","_showDoc","_sizeCache","handleEvent","event","_evtKeydown","_evtPointerdown","_evtScroll","display","scrollTop","selectActive","active","querySelector","getAttribute","onAfterAttach","addEventListener","onBeforeDetach","removeEventListener","isAttached","update","queryChange","newItems","oldItems","oldWidest","_findWidestItemIndex","newWidest","heuristic","_getPreferredItemWidthHeuristic","onUpdateRequest","_populateSubset","hide","_createCompleterNode","querySelectorAll","innerText","_updateDocPanel","show","_setGeometry","sizeCache","docPanelWidth","height","Math","max","docPanelHeight","docPanel","className","ul","first","createCompletionItemNode","renderedItems","firstItemSize","pageSize","ceil","toRenderImmediately","min","performance","now","i","li","widestItemIndex","widestItem","widestItemSize","cloneNode","timePerItem","chunkSize","floor","alreadyRendered","previousChunkFinal","renderChunk","predictedMissingHeight","marginBottom","requestAnimationFrame","limit","widthHeuristic","widthHeuristics","itemWidthHeuristic","bind","_cycle","direction","container","getBoundingClientRect","page","sign","completionList","ElementExt","scrollIntoViewIfNeeded","visibleCompletionItems","activeCompletionItem","contains","target","keyCode","preventDefault","stopPropagation","stopImmediatePropagation","populated","shiftKey","cycle","keyCodeMap","nonstandardClick","documentElement","parentElement","subset","commonSubset","getPositionAt","getCoordinateForPosition","borderLeft","borderLeftWidth","paddingLeft","closest","HoverBox","setGeometry","horizontal","privilege","outOfViewDisplay","top","bottom","left","right","rect","panel","activeNode","_toggleDocPanel","loadingIndicator","createLoadingDocsIndicator","call","documentation","createDocumentationNode","Renderer","wrapperNode","_createWrapperNode","deprecated","_constructNode","_createLabelNode","icon","source","renderText","replace","loadingContainer","loadingBar","append","setAttribute","matchNode","typesExist","iconNode","element","typeNode","toLowerCase","colorIndex","toString","dummyNode","title","typeExtendedNode","toLocaleLowerCase","dummyTypeExtendedNode","values","len","strlen","ch","j","button","altKey","ctrlKey","metaKey","isConnected","removeAttribute","ProviderReconciliator","_resolveFactory","provider","el","_context","_fetching","_inlineFetching","_providers","providers","_inlineProviders","inlineProviders","_inlineProvidersSettings","inlineProvidersSettings","context","_timeout","timeout","applicableProviders","isApplicablePromises","isApplicable","all","_","idx","settings","identifier","delay","debouncerDelay","triggerKind","stream","_stream","timeoutPromise","setTimeout","race","isIncomplete","token","streamed","streaming","opened","updated","response","addition","lastStreamed","closed","combinedPromise","_mergeCompletions","completerIsVisible","_defaultShouldShowContinuousHint","_alignPrefixes","replies","minStart","maxStart","lineOffset","prefixStart","prefixEnd","prefix","startsWith","minEnd","starts","insertTextSet","mergedItems","trim","some","CONTEXT_PROVIDER_ID","ContextCompleterProvider","rank","contextHint","getTokenAtCursor","getTokens","t","getCompletionTokens","matches","KERNEL_PROVIDER_ID","KernelCompleterProvider","session","kernel","contents","code","cursor_pos","requestComplete","content","status","metadata","_jupyter_types_experimental","cursor_start","cursor_end","detail_level","requestInspect","found","data","visible","delete","STREAMING_INDICATOR_CLASS","ERROR_INDICATOR_CLASS","GhostTextManager","placeGhost","view","effects","addMark","of","field","markField","StateEffect","appendConfig","EditorView","domEventHandlers","blur","onBlur","removeMark","clearGhosts","streamingAnimation","spacerRemovalDelay","spacerRemovalDuration","GhostTextWidget","WidgetType","isSpacer","_clearErrorTimeout","eq","other","lineBreaks","updateDOM","dom","_view","_updateDOM","toDOM","wrap","onPointerOver","onPointerLeave","dataset","animation","providedBy","providerId","_removeErrorAnimation","_mountErrorAnimation","errorIndicator","message","clearTimeout","hiddenContent","addedPart","maxLines","lines","minLines","Infinity","linesToAdd","placeHolderLines","fill","streamedTokenHost","hiddenWrapper","expandOnHover","hiddenPart","streamingIndicator","placeholderLinesNode","createTextNode","destroy","TransientSpacerWidget","arguments","TransientLineSpacerWidget","animationDelay","animationDuration","TransientLetterSpacerWidget","GhostAction","createWidget","spec","tr","Decoration","widget","side","ghostSpec","range","newDoc","define","old","mapPos","StateField","create","none","marks","is","action","Remove","docChanged","FilterAndUpdate","chooseAction","_from","_to","timeoutInfo","elapsed","newWidget","iter","next","originalSpec","shouldRemoveGhost","iterChanges","fromA","toA","fromB","toB","inserted","lineNumber","lineContent","lineAt","newWidgets","characterSpacer","lineSpacer","createSpacer","newValues","provide","f","decorations","INLINE_COMPLETER_ACTIVE_CLASS","HOVER_CLASS","InlineCompleter","_clearHoverTimeout","_lastItem","_providerWidget","_showShortcuts","defaultSettings","showShortcuts","_showWidget","showWidget","_suggestionsCounter","_toolbar","Toolbar","_ghostManager","_onEditorBlur","_trans","trans","layout","PanelLayout","addWidget","toolbar","_progressBar","_updateShortcutsVisibility","_updateDisplay","tabIndex","suggestionsChanged","_onModelSuggestionsChanged","filterTextChanged","_onModelFilterTextChanged","provisionProgress","_onProvisionProgress","completions","proposed","_updateStreamTracking","_render","accept","candidate","_onStream","_emitter","_change","_setText","configure","editorResizeDelay","_minLines","_maxLines","_reserveSpaceForLongest","reserveSpaceForLongest","_suppressIfTabCompleterActive","relatedTarget","args","indexMap","mapping","progress","__","name","kernelIcon","render","longest","_onPointerOverGhost","_onPointerLeaveGhost","maybeAnchor","Model","_completions","previousPositions","Map","newIndex","originalPositions","filterText","retain","initialCursor","CompletionProviderManager","_activeProviders","_inlineCompleterSettings","_panelHandlers","_mostRecentContext","_activeProvidersChanged","_inlineCompleterFactory","activeProvidersChanged","setShowDocumentationPanel","handler","setSuppressIfInlineCompleterActive","suppress","_suppressIfInlineCompleterActive","setContinuousHinting","registerProvider","set","id","updateCompleter","registerInlineProvider","getProviders","activateProvider","providerIds","newCompleterContext","firstProvider","modelFactory","generateReconciliator","_generateHandler","disposed","disposeHandler","select","setInlineCompleterFactory","factory","inline","entries","handlerId","completerContext","enabledProviders","providerSettings","enabled","attach","inlineCompleterIcon","LabIcon","svgstr","completerWidgetIcon","HistoryInlineCompletionProvider","_maxSuggestions","translator","nullTranslator","load","historyIcon","schema","properties","maxSuggestions","description","default","linePrefix","historyRequest","output","raw","hist_access_type","n","requestHistory","history","historyFrequencyMap","entry","reverse","sourceLines","sortedFrequencyHistory","pattern","unique","followingLines"],"sourceRoot":""}