{"version":3,"file":"1337.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/commands/dist/index.es6.js"],"sourcesContent":["import { ArrayExt } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Platform, Selector } from '@lumino/domutils';\nimport { getKeyboardLayout } from '@lumino/keyboard';\nimport { Signal } from '@lumino/signaling';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module commands\n */\n/**\n * An object which manages a collection of commands.\n *\n * #### Notes\n * A command registry can be used to populate a variety of action-based\n * widgets, such as command palettes, menus, and toolbars.\n */\nclass CommandRegistry {\n    constructor() {\n        this._timerID = 0;\n        this._timerModifierID = 0;\n        this._replaying = false;\n        this._keystrokes = [];\n        this._keydownEvents = [];\n        this._keyBindings = [];\n        this._exactKeyMatch = null;\n        this._commands = new Map();\n        this._commandChanged = new Signal(this);\n        this._commandExecuted = new Signal(this);\n        this._keyBindingChanged = new Signal(this);\n        this._holdKeyBindingPromises = new Map();\n    }\n    /**\n     * A signal emitted when a command has changed.\n     *\n     * #### Notes\n     * This signal is useful for visual representations of commands which\n     * need to refresh when the state of a relevant command has changed.\n     */\n    get commandChanged() {\n        return this._commandChanged;\n    }\n    /**\n     * A signal emitted when a command has executed.\n     *\n     * #### Notes\n     * Care should be taken when consuming this signal. The command system is used\n     * by many components for many user actions. Handlers registered with this\n     * signal must return quickly to ensure the overall application remains responsive.\n     */\n    get commandExecuted() {\n        return this._commandExecuted;\n    }\n    /**\n     * A signal emitted when a key binding is changed.\n     */\n    get keyBindingChanged() {\n        return this._keyBindingChanged;\n    }\n    /**\n     * A read-only array of the key bindings in the registry.\n     */\n    get keyBindings() {\n        return this._keyBindings;\n    }\n    /**\n     * List the ids of the registered commands.\n     *\n     * @returns A new array of the registered command ids.\n     */\n    listCommands() {\n        return Array.from(this._commands.keys());\n    }\n    /**\n     * Test whether a specific command is registered.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @returns `true` if the command is registered, `false` otherwise.\n     */\n    hasCommand(id) {\n        return this._commands.has(id);\n    }\n    /**\n     * Add a command to the registry.\n     *\n     * @param id - The unique id of the command.\n     *\n     * @param options - The options for the command.\n     *\n     * @returns A disposable which will remove the command.\n     *\n     * @throws An error if the given `id` is already registered.\n     */\n    addCommand(id, options) {\n        // Throw an error if the id is already registered.\n        if (this._commands.has(id)) {\n            throw new Error(`Command '${id}' already registered.`);\n        }\n        // Add the command to the registry.\n        this._commands.set(id, Private.createCommand(options));\n        // Emit the `commandChanged` signal.\n        this._commandChanged.emit({ id, type: 'added' });\n        // Return a disposable which will remove the command.\n        return new DisposableDelegate(() => {\n            // Remove the command from the registry.\n            this._commands.delete(id);\n            // Emit the `commandChanged` signal.\n            this._commandChanged.emit({ id, type: 'removed' });\n        });\n    }\n    /**\n     * Notify listeners that the state of a command has changed.\n     *\n     * @param id - The id of the command which has changed. If more than\n     *   one command has changed, this argument should be omitted.\n     *\n     * @throws An error if the given `id` is not registered.\n     *\n     * #### Notes\n     * This method should be called by the command author whenever the\n     * application state changes such that the results of the command\n     * metadata functions may have changed.\n     *\n     * This will cause the `commandChanged` signal to be emitted.\n     */\n    notifyCommandChanged(id) {\n        if (id !== undefined && !this._commands.has(id)) {\n            throw new Error(`Command '${id}' is not registered.`);\n        }\n        this._commandChanged.emit({ id, type: id ? 'changed' : 'many-changed' });\n    }\n    /**\n     * Get the description for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The description for the command.\n     */\n    describedBy(id, args = JSONExt.emptyObject) {\n        var _a;\n        let cmd = this._commands.get(id);\n        return Promise.resolve((_a = cmd === null || cmd === void 0 ? void 0 : cmd.describedBy.call(undefined, args)) !== null && _a !== void 0 ? _a : { args: null });\n    }\n    /**\n     * Get the display label for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The display label for the command, or an empty string\n     *   if the command is not registered.\n     */\n    label(id, args = JSONExt.emptyObject) {\n        var _a;\n        let cmd = this._commands.get(id);\n        return (_a = cmd === null || cmd === void 0 ? void 0 : cmd.label.call(undefined, args)) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Get the mnemonic index for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The mnemonic index for the command, or `-1` if the\n     *   command is not registered.\n     */\n    mnemonic(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.mnemonic.call(undefined, args) : -1;\n    }\n    /**\n     * Get the icon renderer for a specific command.\n     *\n     * DEPRECATED: if set to a string value, the .icon field will\n     * function as an alias for the .iconClass field, for backwards\n     * compatibility. In the future when this is removed, the default\n     * return type will become undefined.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon renderer for the command or `undefined`.\n     */\n    icon(id, args = JSONExt.emptyObject) {\n        var _a;\n        return (_a = this._commands.get(id)) === null || _a === void 0 ? void 0 : _a.icon.call(undefined, args);\n    }\n    /**\n     * Get the icon class for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon class for the command, or an empty string if\n     *   the command is not registered.\n     */\n    iconClass(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.iconClass.call(undefined, args) : '';\n    }\n    /**\n     * Get the icon label for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The icon label for the command, or an empty string if\n     *   the command is not registered.\n     */\n    iconLabel(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.iconLabel.call(undefined, args) : '';\n    }\n    /**\n     * Get the short form caption for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The caption for the command, or an empty string if the\n     *   command is not registered.\n     */\n    caption(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.caption.call(undefined, args) : '';\n    }\n    /**\n     * Get the usage help text for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The usage text for the command, or an empty string if\n     *   the command is not registered.\n     */\n    usage(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.usage.call(undefined, args) : '';\n    }\n    /**\n     * Get the extra class name for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The class name for the command, or an empty string if\n     *   the command is not registered.\n     */\n    className(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.className.call(undefined, args) : '';\n    }\n    /**\n     * Get the dataset for a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns The dataset for the command, or an empty dataset if\n     *   the command is not registered.\n     */\n    dataset(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.dataset.call(undefined, args) : {};\n    }\n    /**\n     * Test whether a specific command is enabled.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is enabled,\n     *   or `false` if the command is not registered.\n     */\n    isEnabled(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.isEnabled.call(undefined, args) : false;\n    }\n    /**\n     * Test whether a specific command is toggled.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is toggled,\n     *   or `false` if the command is not registered.\n     */\n    isToggled(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.isToggled.call(undefined, args) : false;\n    }\n    /**\n     * Test whether a specific command is toggleable.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is toggleable,\n     *   or `false` if the command is not registered.\n     */\n    isToggleable(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.isToggleable : false;\n    }\n    /**\n     * Test whether a specific command is visible.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A boolean indicating whether the command is visible,\n     *   or `false` if the command is not registered.\n     */\n    isVisible(id, args = JSONExt.emptyObject) {\n        let cmd = this._commands.get(id);\n        return cmd ? cmd.isVisible.call(undefined, args) : false;\n    }\n    /**\n     * Execute a specific command.\n     *\n     * @param id - The id of the command of interest.\n     *\n     * @param args - The arguments for the command.\n     *\n     * @returns A promise which resolves with the result of the command.\n     *\n     * #### Notes\n     * The promise will reject if the command throws an exception,\n     * or if the command is not registered.\n     */\n    execute(id, args = JSONExt.emptyObject) {\n        // Reject if the command is not registered.\n        let cmd = this._commands.get(id);\n        if (!cmd) {\n            return Promise.reject(new Error(`Command '${id}' not registered.`));\n        }\n        // Execute the command and reject if an exception is thrown.\n        let value;\n        try {\n            value = cmd.execute.call(undefined, args);\n        }\n        catch (err) {\n            value = Promise.reject(err);\n        }\n        // Create the return promise which resolves the result.\n        let result = Promise.resolve(value);\n        // Emit the command executed signal.\n        this._commandExecuted.emit({ id, args, result });\n        // Return the result promise to the caller.\n        return result;\n    }\n    /**\n     * Add a key binding to the registry.\n     *\n     * @param options - The options for creating the key binding.\n     *\n     * @returns A disposable which removes the added key binding.\n     *\n     * #### Notes\n     * If multiple key bindings are registered for the same sequence, the\n     * binding with the highest selector specificity is executed first. A\n     * tie is broken by using the most recently added key binding.\n     *\n     * Ambiguous key bindings are resolved with a timeout. As an example,\n     * suppose two key bindings are registered: one with the key sequence\n     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user\n     * presses `Ctrl D`, the first binding cannot be immediately executed\n     * since the user may intend to complete the chord with `Ctrl W`. For\n     * such cases, a timer is used to allow the chord to be completed. If\n     * the chord is not completed before the timeout, the first binding\n     * is executed.\n     */\n    addKeyBinding(options) {\n        // Create the binding for the given options.\n        let binding = Private.createKeyBinding(options);\n        // Add the key binding to the bindings array.\n        this._keyBindings.push(binding);\n        // Emit the `bindingChanged` signal.\n        this._keyBindingChanged.emit({ binding, type: 'added' });\n        // Return a disposable which will remove the binding.\n        return new DisposableDelegate(() => {\n            // Remove the binding from the array.\n            ArrayExt.removeFirstOf(this._keyBindings, binding);\n            // Emit the `bindingChanged` signal.\n            this._keyBindingChanged.emit({ binding, type: 'removed' });\n        });\n    }\n    /**\n     * Process a `'keydown'` event and invoke a matching key binding.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * #### Notes\n     * This should be called in response to a `'keydown'` event in order\n     * to invoke the command for the best matching key binding.\n     *\n     * The registry **does not** install its own listener for `'keydown'`\n     * events. This allows the application full control over the nodes\n     * and phase for which the registry processes `'keydown'` events.\n     *\n     * When the keydown event is processed, if the event target or any of its\n     * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown\n     * events will not invoke commands.\n     */\n    processKeydownEvent(event) {\n        // Bail immediately if playing back keystrokes.\n        if (event.defaultPrevented || this._replaying) {\n            return;\n        }\n        // Get the normalized keystroke for the event.\n        const keystroke = CommandRegistry.keystrokeForKeydownEvent(event);\n        // If the keystroke is not valid for the keyboard layout, replay\n        // any suppressed events and clear the pending state.\n        if (!keystroke) {\n            this._replayKeydownEvents();\n            this._clearPendingState();\n            return;\n        }\n        // Check that only mod key(s) have been pressed.\n        if (CommandRegistry.isModifierKeyPressed(event)) {\n            // Find the exact match for the modifier keys.\n            let { exact } = Private.matchKeyBinding(this._keyBindings, [keystroke], event);\n            if (exact) {\n                // If the mod keys match an exact shortcut, start a dedicated timer.\n                event.preventDefault();\n                event.stopPropagation();\n                this._startModifierTimer(exact);\n            }\n            else {\n                // Otherwise stop potential existing timer.\n                this._clearModifierTimer();\n            }\n            return;\n        }\n        // Add the keystroke to the current key sequence.\n        this._keystrokes.push(keystroke);\n        // Find the exact and partial matches for the key sequence.\n        const { exact, partial } = Private.matchKeyBinding(this._keyBindings, this._keystrokes, event);\n        // Whether there is any partial match.\n        const hasPartial = partial.length !== 0;\n        // If there is no exact match and no partial match, replay\n        // any suppressed events and clear the pending state.\n        if (!exact && !hasPartial) {\n            this._replayKeydownEvents();\n            this._clearPendingState();\n            return;\n        }\n        // Stop propagation of the event. If there is only a partial match,\n        // the event will be replayed if a final exact match never occurs.\n        if ((exact === null || exact === void 0 ? void 0 : exact.preventDefault) || partial.some(match => match.preventDefault)) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Store the event for possible playback in the future and for\n        // the use in execution hold check.\n        this._keydownEvents.push(event);\n        // If there is an exact match but no partial match, the exact match\n        // can be dispatched immediately. The pending state is cleared so\n        // the next key press starts from the default state.\n        if (exact && !hasPartial) {\n            this._executeKeyBinding(exact);\n            this._clearPendingState();\n            return;\n        }\n        // If there is both an exact match and a partial match, the exact\n        // match is stored for future dispatch in case the timer expires\n        // before a more specific match is triggered.\n        if (exact) {\n            this._exactKeyMatch = exact;\n        }\n        // (Re)start the timer to dispatch the most recent exact match\n        // in case the partial match fails to result in an exact match.\n        this._startTimer();\n    }\n    /**\n     * Delay the execution of any command matched against the given 'keydown' event\n     * until the `permission` to execute is granted.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     * @param permission - The promise with value indicating whether to proceed with the execution.\n     *\n     * ### Note\n     * This enables the caller of `processKeydownEvent` to asynchronously prevent the\n     * execution of the command based on external events.\n     */\n    holdKeyBindingExecution(event, permission) {\n        this._holdKeyBindingPromises.set(event, permission);\n    }\n    /**\n     * Process a ``keyup`` event to clear the timer on the modifier, if it exists.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     */\n    processKeyupEvent(event) {\n        this._clearModifierTimer();\n    }\n    /**\n     * Start or restart the timeout on the modifier keys.\n     *\n     * This timeout will end only if the keys are hold.\n     */\n    _startModifierTimer(exact) {\n        this._clearModifierTimer();\n        this._timerModifierID = window.setTimeout(() => {\n            this._executeKeyBinding(exact);\n        }, Private.modifierkeyTimeOut);\n    }\n    /**\n     * Clear the timeout on modifier keys.\n     */\n    _clearModifierTimer() {\n        if (this._timerModifierID !== 0) {\n            clearTimeout(this._timerModifierID);\n            this._timerModifierID = 0;\n        }\n    }\n    /**\n     * Start or restart the pending timeout.\n     */\n    _startTimer() {\n        this._clearTimer();\n        this._timerID = window.setTimeout(() => {\n            this._onPendingTimeout();\n        }, Private.CHORD_TIMEOUT);\n    }\n    /**\n     * Clear the pending timeout.\n     */\n    _clearTimer() {\n        if (this._timerID !== 0) {\n            clearTimeout(this._timerID);\n            this._timerID = 0;\n        }\n    }\n    /**\n     * Replay the keydown events which were suppressed.\n     */\n    _replayKeydownEvents() {\n        if (this._keydownEvents.length === 0) {\n            return;\n        }\n        this._replaying = true;\n        this._keydownEvents.forEach(Private.replayKeyEvent);\n        this._replaying = false;\n    }\n    /**\n     * Execute the command for the given key binding.\n     *\n     * If the command is missing or disabled, a warning will be logged.\n     *\n     * The execution will not proceed if any of the events leading to\n     * the keybinding matching were held with the permission resolving to false.\n     */\n    async _executeKeyBinding(binding) {\n        if (this._holdKeyBindingPromises.size !== 0) {\n            // Copy keydown events list to ensure it is available in async code.\n            const keydownEvents = [...this._keydownEvents];\n            // Wait until all hold requests on execution are lifted.\n            const executionAllowed = (await Promise.race([\n                Promise.all(keydownEvents.map(async (event) => { var _a; return (_a = this._holdKeyBindingPromises.get(event)) !== null && _a !== void 0 ? _a : Promise.resolve(true); })),\n                new Promise(resolve => {\n                    setTimeout(() => resolve([false]), Private.KEYBINDING_HOLD_TIMEOUT);\n                })\n            ])).every(Boolean);\n            // Clear the hold requests.\n            this._holdKeyBindingPromises.clear();\n            // Do not proceed with the execution if any of the hold requests did not get the permission to proceed.\n            if (!executionAllowed) {\n                return;\n            }\n        }\n        let { command, args } = binding;\n        let newArgs = {\n            _luminoEvent: { type: 'keybinding', keys: binding.keys },\n            ...args\n        };\n        if (!this.hasCommand(command) || !this.isEnabled(command, newArgs)) {\n            let word = this.hasCommand(command) ? 'enabled' : 'registered';\n            let keys = binding.keys.join(', ');\n            let msg1 = `Cannot execute key binding '${keys}':`;\n            let msg2 = `command '${command}' is not ${word}.`;\n            console.warn(`${msg1} ${msg2}`);\n            return;\n        }\n        await this.execute(command, newArgs);\n    }\n    /**\n     * Clear the internal pending state.\n     */\n    _clearPendingState() {\n        this._clearTimer();\n        this._clearModifierTimer();\n        this._exactKeyMatch = null;\n        this._keystrokes.length = 0;\n        this._keydownEvents.length = 0;\n    }\n    /**\n     * Handle the partial match timeout.\n     */\n    _onPendingTimeout() {\n        this._timerID = 0;\n        if (this._exactKeyMatch) {\n            this._executeKeyBinding(this._exactKeyMatch);\n        }\n        else {\n            this._replayKeydownEvents();\n        }\n        this._clearPendingState();\n    }\n}\n/**\n * The namespace for the `CommandRegistry` class statics.\n */\n(function (CommandRegistry) {\n    /**\n     * Parse a keystroke into its constituent components.\n     *\n     * @param keystroke - The keystroke of interest.\n     *\n     * @returns The parsed components of the keystroke.\n     *\n     * #### Notes\n     * The keystroke should be of the form:\n     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n     *\n     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n     * `Ctrl` on all other platforms.\n     *\n     * The parsing is tolerant and will not throw exceptions. Notably:\n     *   - Duplicate modifiers are ignored.\n     *   - Extra primary keys are ignored.\n     *   - The order of modifiers and primary key is irrelevant.\n     *   - The keystroke parts should be separated by whitespace.\n     *   - The keystroke is case sensitive.\n     */\n    function parseKeystroke(keystroke) {\n        let key = '';\n        let alt = false;\n        let cmd = false;\n        let ctrl = false;\n        let shift = false;\n        for (let token of keystroke.split(/\\s+/)) {\n            if (token === 'Accel') {\n                if (Platform.IS_MAC) {\n                    cmd = true;\n                }\n                else {\n                    ctrl = true;\n                }\n            }\n            else if (token === 'Alt') {\n                alt = true;\n            }\n            else if (token === 'Cmd') {\n                cmd = true;\n            }\n            else if (token === 'Ctrl') {\n                ctrl = true;\n            }\n            else if (token === 'Shift') {\n                shift = true;\n            }\n            else if (token.length > 0) {\n                key = token;\n            }\n        }\n        return { cmd, ctrl, alt, shift, key };\n    }\n    CommandRegistry.parseKeystroke = parseKeystroke;\n    /**\n     * Normalize a keystroke into a canonical representation.\n     *\n     * @param keystroke - The keystroke of interest.\n     *\n     * @returns The normalized representation of the keystroke.\n     *\n     * #### Notes\n     * This normalizes the keystroke by removing duplicate modifiers and\n     * extra primary keys, and assembling the parts in a canonical order.\n     *\n     * The `Cmd` modifier is ignored on non-Mac platforms.\n     */\n    function normalizeKeystroke(keystroke) {\n        let mods = '';\n        let parts = parseKeystroke(keystroke);\n        if (parts.ctrl) {\n            mods += 'Ctrl ';\n        }\n        if (parts.alt) {\n            mods += 'Alt ';\n        }\n        if (parts.shift) {\n            mods += 'Shift ';\n        }\n        if (parts.cmd && Platform.IS_MAC) {\n            mods += 'Cmd ';\n        }\n        if (!parts.key) {\n            return mods.trim();\n        }\n        return mods + parts.key;\n    }\n    CommandRegistry.normalizeKeystroke = normalizeKeystroke;\n    /**\n     * Get the platform-specific normalized keys for an options object.\n     *\n     * @param options - The options for the key binding.\n     *\n     * @returns Array of combined, normalized keys.\n     */\n    function normalizeKeys(options) {\n        let keys;\n        if (Platform.IS_WIN) {\n            keys = options.winKeys || options.keys;\n        }\n        else if (Platform.IS_MAC) {\n            keys = options.macKeys || options.keys;\n        }\n        else {\n            keys = options.linuxKeys || options.keys;\n        }\n        return keys.map(normalizeKeystroke);\n    }\n    CommandRegistry.normalizeKeys = normalizeKeys;\n    /**\n     * Format keystrokes for display on the local system.\n     *\n     * If a list of keystrokes is provided, it will be displayed as\n     * a comma-separated string\n     *\n     * @param keystroke The keystrokes to format\n     * @returns The keystrokes representation\n     */\n    function formatKeystroke(keystroke) {\n        return typeof keystroke === 'string'\n            ? formatSingleKey(keystroke)\n            : keystroke.map(formatSingleKey).join(', ');\n        function formatSingleKey(key) {\n            let mods = [];\n            let separator = Platform.IS_MAC ? ' ' : '+';\n            let parts = parseKeystroke(key);\n            if (parts.ctrl) {\n                mods.push('Ctrl');\n            }\n            if (parts.alt) {\n                mods.push('Alt');\n            }\n            if (parts.shift) {\n                mods.push('Shift');\n            }\n            if (Platform.IS_MAC && parts.cmd) {\n                mods.push('Cmd');\n            }\n            mods.push(parts.key);\n            return mods.map(Private.formatKey).join(separator);\n        }\n    }\n    CommandRegistry.formatKeystroke = formatKeystroke;\n    /**\n     * Check if `'keydown'` event is caused by pressing a modifier key that should be ignored.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * @returns `true` if modifier key was pressed, `false` otherwise.\n     */\n    function isModifierKeyPressed(event) {\n        let layout = getKeyboardLayout();\n        let key = layout.keyForKeydownEvent(event);\n        return layout.isModifierKey(key);\n    }\n    CommandRegistry.isModifierKeyPressed = isModifierKeyPressed;\n    /**\n     * Create a normalized keystroke for a `'keydown'` event.\n     *\n     * @param event - The event object for a `'keydown'` event.\n     *\n     * @returns A normalized keystroke, or an empty string if the event\n     *   does not represent a valid keystroke for the given layout.\n     */\n    function keystrokeForKeydownEvent(event) {\n        let layout = getKeyboardLayout();\n        let key = layout.keyForKeydownEvent(event);\n        let mods = [];\n        if (event.ctrlKey) {\n            mods.push('Ctrl');\n        }\n        if (event.altKey) {\n            mods.push('Alt');\n        }\n        if (event.shiftKey) {\n            mods.push('Shift');\n        }\n        if (event.metaKey && Platform.IS_MAC) {\n            mods.push('Cmd');\n        }\n        if (!layout.isModifierKey(key)) {\n            mods.push(key);\n        }\n        // for purely modifier key strings\n        return mods.join(' ');\n    }\n    CommandRegistry.keystrokeForKeydownEvent = keystrokeForKeydownEvent;\n})(CommandRegistry || (CommandRegistry = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The timeout in ms for triggering a key binding chord.\n     */\n    Private.CHORD_TIMEOUT = 1000;\n    /**\n     * The timeout in ms for stopping the hold on keybinding execution.\n     */\n    Private.KEYBINDING_HOLD_TIMEOUT = 1000;\n    /**\n     * The timeout in ms for triggering a modifer key binding.\n     */\n    Private.modifierkeyTimeOut = 500;\n    /**\n     * Create a normalized command from an options object.\n     */\n    function createCommand(options) {\n        return {\n            execute: options.execute,\n            describedBy: asFunc(typeof options.describedBy === 'function'\n                ? options.describedBy\n                : { args: null, ...options.describedBy }, () => {\n                return { args: null };\n            }),\n            label: asFunc(options.label, emptyStringFunc),\n            mnemonic: asFunc(options.mnemonic, negativeOneFunc),\n            icon: asFunc(options.icon, undefinedFunc),\n            iconClass: asFunc(options.iconClass, emptyStringFunc),\n            iconLabel: asFunc(options.iconLabel, emptyStringFunc),\n            caption: asFunc(options.caption, emptyStringFunc),\n            usage: asFunc(options.usage, emptyStringFunc),\n            className: asFunc(options.className, emptyStringFunc),\n            dataset: asFunc(options.dataset, emptyDatasetFunc),\n            isEnabled: options.isEnabled || trueFunc,\n            isToggled: options.isToggled || falseFunc,\n            isToggleable: options.isToggleable || !!options.isToggled,\n            isVisible: options.isVisible || trueFunc\n        };\n    }\n    Private.createCommand = createCommand;\n    /**\n     * Create a key binding object from key binding options.\n     */\n    function createKeyBinding(options) {\n        var _a;\n        return {\n            keys: CommandRegistry.normalizeKeys(options),\n            selector: validateSelector(options),\n            command: options.command,\n            args: options.args || JSONExt.emptyObject,\n            preventDefault: (_a = options.preventDefault) !== null && _a !== void 0 ? _a : true\n        };\n    }\n    Private.createKeyBinding = createKeyBinding;\n    /**\n     * Find the key bindings which match a key sequence.\n     *\n     * This returns a match result which contains the best exact matching\n     * binding, and a flag which indicates if there are partial matches.\n     */\n    function matchKeyBinding(bindings, keys, event) {\n        // The current best exact match.\n        let exact = null;\n        // Partial matches.\n        let partial = [];\n        // The match distance for the exact match.\n        let distance = Infinity;\n        // The specificity for the exact match.\n        let specificity = 0;\n        // Iterate over the bindings and search for the best match.\n        for (let i = 0, n = bindings.length; i < n; ++i) {\n            // Lookup the current binding.\n            let binding = bindings[i];\n            // Check whether the key binding sequence is a match.\n            let sqm = matchSequence(binding.keys, keys);\n            // If there is no match, the binding is ignored.\n            if (sqm === 0 /* SequenceMatch.None */) {\n                continue;\n            }\n            // If it is a partial match and no other partial match has been\n            // found, ensure the selector matches and set the partial flag.\n            if (sqm === 2 /* SequenceMatch.Partial */) {\n                if (targetDistance(binding.selector, event) !== -1) {\n                    partial.push(binding);\n                }\n                continue;\n            }\n            // Ignore the match if the selector doesn't match, or if the\n            // matched node is farther away than the current best match.\n            let td = targetDistance(binding.selector, event);\n            if (td === -1 || td > distance) {\n                continue;\n            }\n            // Get the specificity for the selector.\n            let sp = Selector.calculateSpecificity(binding.selector);\n            // Update the best match if this match is stronger.\n            if (!exact || td < distance || sp >= specificity) {\n                exact = binding;\n                distance = td;\n                specificity = sp;\n            }\n        }\n        // Return the match result.\n        return { exact, partial };\n    }\n    Private.matchKeyBinding = matchKeyBinding;\n    /**\n     * Replay a keyboard event.\n     *\n     * This synthetically dispatches a clone of the keyboard event.\n     */\n    function replayKeyEvent(event) {\n        event.target.dispatchEvent(cloneKeyboardEvent(event));\n    }\n    Private.replayKeyEvent = replayKeyEvent;\n    function formatKey(key) {\n        if (Platform.IS_MAC) {\n            return MAC_DISPLAY.hasOwnProperty(key) ? MAC_DISPLAY[key] : key;\n        }\n        else {\n            return WIN_DISPLAY.hasOwnProperty(key) ? WIN_DISPLAY[key] : key;\n        }\n    }\n    Private.formatKey = formatKey;\n    const MAC_DISPLAY = {\n        Backspace: '⌫',\n        Tab: '⇥',\n        Enter: '⏎',\n        Shift: '⇧',\n        Ctrl: '⌃',\n        Alt: '⌥',\n        Escape: '⎋',\n        PageUp: '⇞',\n        PageDown: '⇟',\n        End: '↘',\n        Home: '↖',\n        ArrowLeft: '←',\n        ArrowUp: '↑',\n        ArrowRight: '→',\n        ArrowDown: '↓',\n        Delete: '⌦',\n        Cmd: '⌘'\n    };\n    const WIN_DISPLAY = {\n        Escape: 'Esc',\n        PageUp: 'Page Up',\n        PageDown: 'Page Down',\n        ArrowLeft: 'Left',\n        ArrowUp: 'Up',\n        ArrowRight: 'Right',\n        ArrowDown: 'Down',\n        Delete: 'Del'\n    };\n    /**\n     * A singleton empty string function.\n     */\n    const emptyStringFunc = () => '';\n    /**\n     * A singleton `-1` number function\n     */\n    const negativeOneFunc = () => -1;\n    /**\n     * A singleton true boolean function.\n     */\n    const trueFunc = () => true;\n    /**\n     * A singleton false boolean function.\n     */\n    const falseFunc = () => false;\n    /**\n     * A singleton empty dataset function.\n     */\n    const emptyDatasetFunc = () => ({});\n    /**\n     * A singleton undefined function\n     */\n    const undefinedFunc = () => undefined;\n    /**\n     * Cast a value or command func to a command func.\n     */\n    function asFunc(value, dfault) {\n        if (value === undefined) {\n            return dfault;\n        }\n        if (typeof value === 'function') {\n            return value;\n        }\n        return () => value;\n    }\n    /**\n     * Validate the selector for an options object.\n     *\n     * This returns the validated selector, or throws if the selector is\n     * invalid or contains commas.\n     */\n    function validateSelector(options) {\n        if (options.selector.indexOf(',') !== -1) {\n            throw new Error(`Selector cannot contain commas: ${options.selector}`);\n        }\n        if (!Selector.isValid(options.selector)) {\n            throw new Error(`Invalid selector: ${options.selector}`);\n        }\n        return options.selector;\n    }\n    /**\n     * Test whether a key binding sequence matches a key sequence.\n     *\n     * Returns a `SequenceMatch` value indicating the type of match.\n     */\n    function matchSequence(bindKeys, userKeys) {\n        if (bindKeys.length < userKeys.length) {\n            return 0 /* SequenceMatch.None */;\n        }\n        for (let i = 0, n = userKeys.length; i < n; ++i) {\n            if (bindKeys[i] !== userKeys[i]) {\n                return 0 /* SequenceMatch.None */;\n            }\n        }\n        if (bindKeys.length > userKeys.length) {\n            return 2 /* SequenceMatch.Partial */;\n        }\n        return 1 /* SequenceMatch.Exact */;\n    }\n    /**\n     * Find the distance from the target node to the first matching node.\n     *\n     * This traverses the event path from `target` to `currentTarget` and\n     * computes the distance from `target` to the first node which matches\n     * the CSS selector. If no match is found, `-1` is returned.\n     */\n    function targetDistance(selector, event) {\n        let targ = event.target;\n        let curr = event.currentTarget;\n        for (let dist = 0; targ !== null; targ = targ.parentElement, ++dist) {\n            if (targ.hasAttribute('data-lm-suppress-shortcuts')) {\n                return -1;\n            }\n            if (Selector.matches(targ, selector)) {\n                return dist;\n            }\n            if (targ === curr) {\n                return -1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Clone a keyboard event.\n     */\n    function cloneKeyboardEvent(event) {\n        // A custom event is required because Chrome nulls out the\n        // `keyCode` field in user-generated `KeyboardEvent` types.\n        let clone = document.createEvent('Event');\n        let bubbles = event.bubbles || true;\n        let cancelable = event.cancelable || true;\n        clone.initEvent(event.type || 'keydown', bubbles, cancelable);\n        clone.key = event.key || '';\n        clone.keyCode = event.keyCode || 0;\n        clone.which = event.keyCode || 0;\n        clone.ctrlKey = event.ctrlKey || false;\n        clone.altKey = event.altKey || false;\n        clone.shiftKey = event.shiftKey || false;\n        clone.metaKey = event.metaKey || false;\n        clone.view = event.view || window;\n        return clone;\n    }\n})(Private || (Private = {}));\n\nexport { CommandRegistry };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Private","CommandRegistry","constructor","this","_timerID","_timerModifierID","_replaying","_keystrokes","_keydownEvents","_keyBindings","_exactKeyMatch","_commands","Map","_commandChanged","Signal","_commandExecuted","_keyBindingChanged","_holdKeyBindingPromises","commandChanged","commandExecuted","keyBindingChanged","keyBindings","listCommands","Array","from","keys","hasCommand","id","has","addCommand","options","Error","set","createCommand","emit","type","DisposableDelegate","delete","notifyCommandChanged","undefined","describedBy","args","JSONExt","emptyObject","_a","cmd","get","Promise","resolve","call","label","mnemonic","icon","iconClass","iconLabel","caption","usage","className","dataset","isEnabled","isToggled","isToggleable","isVisible","execute","value","reject","err","result","addKeyBinding","binding","createKeyBinding","push","ArrayExt","removeFirstOf","processKeydownEvent","event","defaultPrevented","keystroke","keystrokeForKeydownEvent","_replayKeydownEvents","_clearPendingState","isModifierKeyPressed","exact","matchKeyBinding","preventDefault","stopPropagation","_startModifierTimer","_clearModifierTimer","partial","hasPartial","length","some","match","_executeKeyBinding","_startTimer","holdKeyBindingExecution","permission","processKeyupEvent","window","setTimeout","modifierkeyTimeOut","clearTimeout","_clearTimer","_onPendingTimeout","CHORD_TIMEOUT","forEach","replayKeyEvent","size","keydownEvents","executionAllowed","race","all","map","async","KEYBINDING_HOLD_TIMEOUT","every","Boolean","clear","command","newArgs","_luminoEvent","word","msg1","join","msg2","console","warn","parseKeystroke","key","alt","ctrl","shift","token","split","Platform","IS_MAC","normalizeKeystroke","mods","parts","trim","normalizeKeys","IS_WIN","winKeys","macKeys","linuxKeys","formatKeystroke","formatSingleKey","separator","formatKey","layout","getKeyboardLayout","keyForKeydownEvent","isModifierKey","ctrlKey","altKey","shiftKey","metaKey","asFunc","emptyStringFunc","negativeOneFunc","undefinedFunc","emptyDatasetFunc","trueFunc","falseFunc","selector","validateSelector","bindings","distance","Infinity","specificity","i","n","sqm","matchSequence","targetDistance","td","sp","Selector","calculateSpecificity","target","dispatchEvent","clone","document","createEvent","bubbles","cancelable","initEvent","keyCode","which","view","cloneKeyboardEvent","MAC_DISPLAY","hasOwnProperty","WIN_DISPLAY","Backspace","Tab","Enter","Shift","Ctrl","Alt","Escape","PageUp","PageDown","End","Home","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Delete","Cmd","dfault","indexOf","isValid","bindKeys","userKeys","targ","curr","currentTarget","dist","parentElement","hasAttribute","matches"],"sourceRoot":""}