{"version":3,"file":"9632.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager-extension/lib/recents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/docmanager-extension/lib/index.js"],"sourcesContent":["/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { IRecentsManager, RecentsManager } from '@jupyterlab/docmanager';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\n/**\n * A namespace for command IDs.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.clearRecents = 'docmanager:clear-recents';\n})(CommandIDs || (CommandIDs = {}));\nvar PluginIDs;\n(function (PluginIDs) {\n    PluginIDs.recentsManager = '@jupyterlab/docmanager-extension:recents';\n    PluginIDs.reopenClosed = '@jupyterlab/docmanager-extension:reopen-recently-closed';\n    PluginIDs.mainPlugin = '@jupyterlab/docmanager-extension:plugin';\n})(PluginIDs || (PluginIDs = {}));\nexport const recentsManagerPlugin = {\n    id: PluginIDs.recentsManager,\n    description: 'Provides a manager of recently opened and closed documents.',\n    autoStart: true,\n    requires: [IStateDB],\n    optional: [ISettingRegistry, ITranslator],\n    provides: IRecentsManager,\n    activate: (app, stateDB, settingRegistry, translator) => {\n        const { serviceManager } = app;\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        // Create the manager\n        const recentsManager = new RecentsManager({\n            stateDB: stateDB,\n            contents: serviceManager.contents\n        });\n        const updateSettings = (settings) => {\n            recentsManager.maximalRecentsLength = settings.get('maxNumberRecents')\n                .composite;\n        };\n        if (settingRegistry) {\n            void Promise.all([\n                app.restored,\n                settingRegistry.load(PluginIDs.mainPlugin)\n            ]).then(([_, settings]) => {\n                settings.changed.connect(updateSettings);\n                updateSettings(settings);\n            });\n        }\n        app.commands.addCommand(CommandIDs.clearRecents, {\n            execute: () => {\n                recentsManager.clearRecents();\n            },\n            isEnabled: () => recentsManager.recentlyOpened.length != 0 ||\n                recentsManager.recentlyClosed.length != 0,\n            label: trans.__('Clear Recent Documents'),\n            caption: trans.__('Clear the list of recently opened items.')\n        });\n        return recentsManager;\n    }\n};\n//# sourceMappingURL=recents.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module docmanager-extension\n */\nimport { ILabShell, ILabStatus, JupyterLab } from '@jupyterlab/application';\nimport { addCommandToolbarButtonClass, CommandToolbarButtonComponent, Dialog, ICommandPalette, InputDialog, ISessionContextDialogs, Notification, ReactWidget, SessionContextDialogs, showDialog, showErrorMessage, UseSignal } from '@jupyterlab/apputils';\nimport { PathExt, Time } from '@jupyterlab/coreutils';\nimport { DocumentManager, IDocumentManager, IDocumentWidgetOpener, IRecentsManager, PathStatus, renameDialog, SavingStatus } from '@jupyterlab/docmanager';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IStatusBar } from '@jupyterlab/statusbar';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { saveIcon } from '@jupyterlab/ui-components';\nimport { some } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\nimport * as React from 'react';\nimport { recentsManagerPlugin } from './recents';\n/**\n * The command IDs used by the document manager plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.clone = 'docmanager:clone';\n    CommandIDs.deleteFile = 'docmanager:delete-file';\n    CommandIDs.newUntitled = 'docmanager:new-untitled';\n    CommandIDs.open = 'docmanager:open';\n    CommandIDs.openBrowserTab = 'docmanager:open-browser-tab';\n    CommandIDs.reload = 'docmanager:reload';\n    CommandIDs.rename = 'docmanager:rename';\n    CommandIDs.del = 'docmanager:delete';\n    CommandIDs.duplicate = 'docmanager:duplicate';\n    CommandIDs.restoreCheckpoint = 'docmanager:restore-checkpoint';\n    CommandIDs.save = 'docmanager:save';\n    CommandIDs.saveAll = 'docmanager:save-all';\n    CommandIDs.saveAs = 'docmanager:save-as';\n    CommandIDs.download = 'docmanager:download';\n    CommandIDs.toggleAutosave = 'docmanager:toggle-autosave';\n    CommandIDs.showInFileBrowser = 'docmanager:show-in-file-browser';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * The id of the document manager plugin.\n */\nconst docManagerPluginId = '@jupyterlab/docmanager-extension:plugin';\n/**\n * A plugin to open documents in the main area.\n *\n */\nconst openerPlugin = {\n    id: '@jupyterlab/docmanager-extension:opener',\n    description: 'Provides the widget opener.',\n    autoStart: true,\n    provides: IDocumentWidgetOpener,\n    activate: (app) => {\n        const { shell } = app;\n        return new (class {\n            constructor() {\n                this._opened = new Signal(this);\n            }\n            open(widget, options) {\n                if (!widget.id) {\n                    widget.id = `document-manager-${++Private.id}`;\n                }\n                widget.title.dataset = {\n                    type: 'document-title',\n                    ...widget.title.dataset\n                };\n                if (!widget.isAttached) {\n                    shell.add(widget, 'main', options || {});\n                }\n                shell.activateById(widget.id);\n                this._opened.emit(widget);\n            }\n            get opened() {\n                return this._opened;\n            }\n        })();\n    }\n};\n/**\n * A plugin to handle dirty states for open documents.\n */\nconst contextsPlugin = {\n    id: '@jupyterlab/docmanager-extension:contexts',\n    description: 'Adds the handling of opened documents dirty state.',\n    autoStart: true,\n    requires: [IDocumentManager, IDocumentWidgetOpener],\n    optional: [ILabStatus],\n    activate: (app, docManager, widgetOpener, status) => {\n        const contexts = new WeakSet();\n        widgetOpener.opened.connect((_, widget) => {\n            // Handle dirty state for open documents.\n            const context = docManager.contextForWidget(widget);\n            if (context && !contexts.has(context)) {\n                if (status) {\n                    handleContext(status, context);\n                }\n                contexts.add(context);\n            }\n        });\n    }\n};\n/**\n * A plugin providing the default document manager.\n */\nconst manager = {\n    id: '@jupyterlab/docmanager-extension:manager',\n    description: 'Provides the document manager.',\n    provides: IDocumentManager,\n    requires: [IDocumentWidgetOpener],\n    optional: [\n        ITranslator,\n        ILabStatus,\n        ISessionContextDialogs,\n        JupyterLab.IInfo,\n        IRecentsManager\n    ],\n    activate: (app, widgetOpener, translator_, status, sessionDialogs_, info, recentsManager) => {\n        var _a;\n        const { serviceManager: manager, docRegistry: registry } = app;\n        const translator = translator_ !== null && translator_ !== void 0 ? translator_ : nullTranslator;\n        const sessionDialogs = sessionDialogs_ !== null && sessionDialogs_ !== void 0 ? sessionDialogs_ : new SessionContextDialogs({ translator });\n        const when = app.restored.then(() => void 0);\n        const docManager = new DocumentManager({\n            registry,\n            manager,\n            opener: widgetOpener,\n            when,\n            setBusy: (_a = (status && (() => status.setBusy()))) !== null && _a !== void 0 ? _a : undefined,\n            sessionDialogs,\n            translator: translator !== null && translator !== void 0 ? translator : nullTranslator,\n            isConnectedCallback: () => {\n                if (info) {\n                    return info.isConnected;\n                }\n                return true;\n            },\n            recentsManager: recentsManager !== null && recentsManager !== void 0 ? recentsManager : undefined\n        });\n        return docManager;\n    }\n};\n/**\n * The default document manager provider commands and settings.\n */\nconst docManagerPlugin = {\n    id: docManagerPluginId,\n    description: 'Adds commands and settings to the document manager.',\n    autoStart: true,\n    requires: [IDocumentManager, IDocumentWidgetOpener, ISettingRegistry],\n    optional: [ITranslator, ICommandPalette, ILabShell],\n    activate: (app, docManager, widgetOpener, settingRegistry, translator, palette, labShell) => {\n        translator = translator !== null && translator !== void 0 ? translator : nullTranslator;\n        const trans = translator.load('jupyterlab');\n        const registry = app.docRegistry;\n        // Register the file operations commands.\n        addCommands(app, docManager, widgetOpener, settingRegistry, translator, labShell, palette);\n        // Keep up to date with the settings registry.\n        const onSettingsUpdated = (settings) => {\n            // Handle whether to autosave\n            const autosave = settings.get('autosave').composite;\n            docManager.autosave =\n                autosave === true || autosave === false ? autosave : true;\n            app.commands.notifyCommandChanged(CommandIDs.toggleAutosave);\n            const confirmClosingDocument = settings.get('confirmClosingDocument')\n                .composite;\n            docManager.confirmClosingDocument = confirmClosingDocument !== null && confirmClosingDocument !== void 0 ? confirmClosingDocument : true;\n            // Handle autosave interval\n            const autosaveInterval = settings.get('autosaveInterval').composite;\n            docManager.autosaveInterval = autosaveInterval || 120;\n            // Handle last modified timestamp check margin\n            const lastModifiedCheckMargin = settings.get('lastModifiedCheckMargin')\n                .composite;\n            docManager.lastModifiedCheckMargin = lastModifiedCheckMargin || 500;\n            const renameUntitledFile = settings.get('renameUntitledFileOnSave')\n                .composite;\n            docManager.renameUntitledFileOnSave = renameUntitledFile !== null && renameUntitledFile !== void 0 ? renameUntitledFile : true;\n            // Handle default widget factory overrides.\n            const defaultViewers = settings.get('defaultViewers').composite;\n            const overrides = {};\n            // Filter the defaultViewers and file types for existing ones.\n            Object.keys(defaultViewers).forEach(ft => {\n                if (!registry.getFileType(ft)) {\n                    console.warn(`File Type ${ft} not found`);\n                    return;\n                }\n                if (!registry.getWidgetFactory(defaultViewers[ft])) {\n                    console.warn(`Document viewer ${defaultViewers[ft]} not found`);\n                }\n                overrides[ft] = defaultViewers[ft];\n            });\n            // Set the default factory overrides. If not provided, this has the\n            // effect of unsetting any previous overrides.\n            for (const ft of registry.fileTypes()) {\n                try {\n                    registry.setDefaultWidgetFactory(ft.name, overrides[ft.name]);\n                }\n                catch (_a) {\n                    console.warn(`Failed to set default viewer ${overrides[ft.name]} for file type ${ft.name}`);\n                }\n            }\n        };\n        // Fetch the initial state of the settings.\n        Promise.all([settingRegistry.load(docManagerPluginId), app.restored])\n            .then(([settings]) => {\n            settings.changed.connect(onSettingsUpdated);\n            onSettingsUpdated(settings);\n            const onStateChanged = (sender, change) => {\n                if ([\n                    'autosave',\n                    'autosaveInterval',\n                    'confirmClosingDocument',\n                    'lastModifiedCheckMargin',\n                    'renameUntitledFileOnSave'\n                ].includes(change.name) &&\n                    settings.get(change.name).composite !== change.newValue) {\n                    settings.set(change.name, change.newValue).catch(reason => {\n                        console.error(`Failed to set the setting '${change.name}':\\n${reason}`);\n                    });\n                }\n            };\n            docManager.stateChanged.connect(onStateChanged);\n        })\n            .catch((reason) => {\n            console.error(reason.message);\n        });\n        // Register a fetch transformer for the settings registry,\n        // allowing us to dynamically populate a help string with the\n        // available document viewers and file types for the default\n        // viewer overrides.\n        settingRegistry.transform(docManagerPluginId, {\n            fetch: plugin => {\n                // Get the available file types.\n                const fileTypes = Array.from(registry.fileTypes())\n                    .map(ft => ft.name)\n                    .join('    \\n');\n                // Get the available widget factories.\n                const factories = Array.from(registry.widgetFactories())\n                    .map(f => f.name)\n                    .join('    \\n');\n                // Generate the help string.\n                const description = trans.__(`Overrides for the default viewers for file types.\nSpecify a mapping from file type name to document viewer name, for example:\n\ndefaultViewers: {\n  markdown: \"Markdown Preview\"\n}\n\nIf you specify non-existent file types or viewers, or if a viewer cannot\nopen a given file type, the override will not function.\n\nAvailable viewers:\n%1\n\nAvailable file types:\n%2`, factories, fileTypes);\n                const schema = JSONExt.deepCopy(plugin.schema);\n                schema.properties.defaultViewers.description = description;\n                return { ...plugin, schema };\n            }\n        });\n        // If the document registry gains or loses a factory or file type,\n        // regenerate the settings description with the available options.\n        registry.changed.connect(() => settingRegistry.load(docManagerPluginId, true));\n    }\n};\n/**\n * A plugin for adding a saving status item to the status bar.\n */\nexport const savingStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:saving-status',\n    description: 'Adds a saving status indicator.',\n    autoStart: true,\n    requires: [IDocumentManager, ILabShell],\n    optional: [ITranslator, IStatusBar],\n    activate: (_, docManager, labShell, translator, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const saving = new SavingStatus({\n            docManager,\n            translator: translator !== null && translator !== void 0 ? translator : nullTranslator\n        });\n        // Keep the currently active widget synchronized.\n        saving.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            saving.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(savingStatusPlugin.id, {\n            item: saving,\n            align: 'middle',\n            isActive: () => saving.model !== null && saving.model.status !== null,\n            activeStateChanged: saving.model.stateChanged\n        });\n    }\n};\n/**\n * A plugin providing a file path widget to the status bar.\n */\nexport const pathStatusPlugin = {\n    id: '@jupyterlab/docmanager-extension:path-status',\n    description: 'Adds a file path indicator in the status bar.',\n    autoStart: true,\n    requires: [IDocumentManager, ILabShell],\n    optional: [IStatusBar],\n    activate: (_, docManager, labShell, statusBar) => {\n        if (!statusBar) {\n            // Automatically disable if statusbar missing\n            return;\n        }\n        const path = new PathStatus({ docManager });\n        // Keep the file path widget up-to-date with the application active widget.\n        path.model.widget = labShell.currentWidget;\n        labShell.currentChanged.connect(() => {\n            path.model.widget = labShell.currentWidget;\n        });\n        statusBar.registerStatusItem(pathStatusPlugin.id, {\n            item: path,\n            align: 'right',\n            rank: 0\n        });\n    }\n};\n/**\n * A plugin providing download commands in the file menu and command palette.\n */\nexport const downloadPlugin = {\n    id: '@jupyterlab/docmanager-extension:download',\n    description: 'Adds command to download files.',\n    autoStart: true,\n    requires: [IDocumentManager],\n    optional: [ITranslator, ICommandPalette],\n    activate: (app, docManager, translator, palette) => {\n        var _a;\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        const { commands, shell } = app;\n        const isEnabled = () => {\n            const { currentWidget } = shell;\n            return !!(currentWidget && docManager.contextForWidget(currentWidget));\n        };\n        commands.addCommand(CommandIDs.download, {\n            label: trans.__('Download'),\n            caption: trans.__('Download the file to your computer'),\n            isEnabled,\n            execute: () => {\n                // Checks that shell.currentWidget is valid:\n                if (isEnabled()) {\n                    const context = docManager.contextForWidget(shell.currentWidget);\n                    if (!context) {\n                        return showDialog({\n                            title: trans.__('Cannot Download'),\n                            body: trans.__('No context found for current widget!'),\n                            buttons: [Dialog.okButton()]\n                        });\n                    }\n                    return context.download();\n                }\n            }\n        });\n        (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {\n            app.commands.notifyCommandChanged(CommandIDs.download);\n        });\n        const category = trans.__('File Operations');\n        if (palette) {\n            palette.addItem({ command: CommandIDs.download, category });\n        }\n    }\n};\n/**\n * A plugin providing open-browser-tab commands.\n *\n * This is its own plugin in case you would like to disable this feature.\n * e.g. jupyter labextension disable @jupyterlab/docmanager-extension:open-browser-tab\n *\n * Note: If disabling this, you may also want to disable:\n * @jupyterlab/filebrowser-extension:open-browser-tab\n */\nexport const openBrowserTabPlugin = {\n    id: '@jupyterlab/docmanager-extension:open-browser-tab',\n    description: 'Adds command to open a browser tab.',\n    autoStart: true,\n    requires: [IDocumentManager],\n    optional: [ITranslator],\n    activate: (app, docManager, translator) => {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        const { commands } = app;\n        commands.addCommand(CommandIDs.openBrowserTab, {\n            execute: args => {\n                const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n                if (!path) {\n                    return;\n                }\n                return docManager.services.contents.getDownloadUrl(path).then(url => {\n                    const opened = window.open();\n                    if (opened) {\n                        opened.opener = null;\n                        opened.location.href = url;\n                    }\n                    else {\n                        throw new Error('Failed to open new browser tab.');\n                    }\n                });\n            },\n            iconClass: args => args['icon'] || '',\n            label: () => trans.__('Open in New Browser Tab')\n        });\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    manager,\n    docManagerPlugin,\n    contextsPlugin,\n    pathStatusPlugin,\n    savingStatusPlugin,\n    downloadPlugin,\n    openBrowserTabPlugin,\n    openerPlugin,\n    recentsManagerPlugin\n];\nexport default plugins;\n/**\n * Toolbar item factory\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     *\n     */\n    function createSaveButton(commands, fileChanged) {\n        return addCommandToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: fileChanged }, () => (React.createElement(CommandToolbarButtonComponent, { commands: commands, id: CommandIDs.save, label: '', args: { toolbar: true } })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n})(ToolbarItems || (ToolbarItems = {}));\n/* Widget to display the revert to checkpoint confirmation. */\nclass RevertConfirmWidget extends Widget {\n    /**\n     * Construct a new revert confirmation widget.\n     */\n    constructor(checkpoint, trans, fileType = 'notebook') {\n        super({\n            node: Private.createRevertConfirmNode(checkpoint, fileType, trans)\n        });\n    }\n}\n// Returns the file type for a widget.\nfunction fileType(widget, docManager) {\n    if (!widget) {\n        return 'File';\n    }\n    const context = docManager.contextForWidget(widget);\n    if (!context) {\n        return '';\n    }\n    const fts = docManager.registry.getFileTypesForPath(context.path);\n    return fts.length && fts[0].displayName ? fts[0].displayName : 'File';\n}\n/**\n * Add the file operations commands to the application's command registry.\n */\nfunction addCommands(app, docManager, widgetOpener, settingRegistry, translator, labShell, palette) {\n    var _a;\n    const trans = translator.load('jupyterlab');\n    const { commands, shell } = app;\n    const category = trans.__('File Operations');\n    const isEnabled = () => {\n        const { currentWidget } = shell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    const isWritable = () => {\n        var _a;\n        const { currentWidget } = shell;\n        if (!currentWidget) {\n            return false;\n        }\n        const context = docManager.contextForWidget(currentWidget);\n        return !!((_a = context === null || context === void 0 ? void 0 : context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable);\n    };\n    const readonlyNotification = (contextPath) => {\n        return Notification.warning(trans.__(`%1 is read-only. Use \"Save as…\" instead.`, contextPath), { autoClose: 5000 });\n    };\n    // If inside a rich application like JupyterLab, add additional functionality.\n    if (labShell) {\n        addLabCommands(app, docManager, labShell, widgetOpener, translator);\n    }\n    commands.addCommand(CommandIDs.deleteFile, {\n        label: () => `Delete ${fileType(shell.currentWidget, docManager)}`,\n        execute: args => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            if (!path) {\n                const command = CommandIDs.deleteFile;\n                throw new Error(`A non-empty path is required for ${command}.`);\n            }\n            return docManager.deleteFile(path);\n        }\n    });\n    commands.addCommand(CommandIDs.newUntitled, {\n        execute: async (args) => {\n            const errorTitle = args['error'] || trans.__('Error');\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const options = {\n                type: args['type'],\n                path\n            };\n            if (args['type'] === 'file') {\n                options.ext = args['ext'] || '.txt';\n            }\n            return docManager.services.contents\n                .newUntitled(options)\n                .catch(error => showErrorMessage(errorTitle, error));\n        },\n        label: args => args['label'] || `New ${args['type']}`\n    });\n    commands.addCommand(CommandIDs.open, {\n        execute: async (args) => {\n            const path = typeof args['path'] === 'undefined' ? '' : args['path'];\n            const factory = args['factory'] || void 0;\n            const kernel = args === null || args === void 0 ? void 0 : args.kernel;\n            const options = args['options'] || void 0;\n            return docManager.services.contents\n                .get(path, { content: false })\n                .then(() => docManager.openOrReveal(path, factory, kernel, options));\n        },\n        iconClass: args => args['icon'] || '',\n        label: args => {\n            var _a;\n            return ((_a = (args['label'] || args['factory'])) !== null && _a !== void 0 ? _a : trans.__('Open the provided `path`.'));\n        },\n        mnemonic: args => args['mnemonic'] || -1\n    });\n    commands.addCommand(CommandIDs.reload, {\n        label: () => trans.__('Reload %1 from Disk', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Reload contents from disk'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            const type = fileType(shell.currentWidget, docManager);\n            if (!context) {\n                return showDialog({\n                    title: trans.__('Cannot Reload'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [Dialog.okButton()]\n                });\n            }\n            if (context.model.dirty) {\n                return showDialog({\n                    title: trans.__('Reload %1 from Disk', type),\n                    body: trans.__('Are you sure you want to reload the %1 from the disk?', type),\n                    buttons: [\n                        Dialog.cancelButton(),\n                        Dialog.warnButton({ label: trans.__('Reload') })\n                    ]\n                }).then(result => {\n                    if (result.button.accept && !context.isDisposed) {\n                        return context.revert();\n                    }\n                });\n            }\n            else {\n                if (!context.isDisposed) {\n                    return context.revert();\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.restoreCheckpoint, {\n        label: () => trans.__('Revert %1 to Checkpoint…', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Revert contents to previous checkpoint'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (!isEnabled()) {\n                return;\n            }\n            const context = docManager.contextForWidget(shell.currentWidget);\n            if (!context) {\n                return showDialog({\n                    title: trans.__('Cannot Revert'),\n                    body: trans.__('No context found for current widget!'),\n                    buttons: [Dialog.okButton()]\n                });\n            }\n            return context.listCheckpoints().then(async (checkpoints) => {\n                const type = fileType(shell.currentWidget, docManager);\n                if (checkpoints.length < 1) {\n                    await showErrorMessage(trans.__('No checkpoints'), trans.__('No checkpoints are available for this %1.', type));\n                    return;\n                }\n                const targetCheckpoint = checkpoints.length === 1\n                    ? checkpoints[0]\n                    : await Private.getTargetCheckpoint(checkpoints.reverse(), trans);\n                if (!targetCheckpoint) {\n                    return;\n                }\n                return showDialog({\n                    title: trans.__('Revert %1 to checkpoint', type),\n                    body: new RevertConfirmWidget(targetCheckpoint, trans, type),\n                    buttons: [\n                        Dialog.cancelButton(),\n                        Dialog.warnButton({\n                            label: trans.__('Revert'),\n                            ariaLabel: trans.__('Revert to Checkpoint')\n                        })\n                    ]\n                }).then(result => {\n                    if (context.isDisposed) {\n                        return;\n                    }\n                    if (result.button.accept) {\n                        if (context.model.readOnly) {\n                            return context.revert();\n                        }\n                        return context\n                            .restoreCheckpoint(targetCheckpoint.id)\n                            .then(() => context.revert());\n                    }\n                });\n            });\n        }\n    });\n    const caption = () => {\n        if (shell.currentWidget) {\n            const context = docManager.contextForWidget(shell.currentWidget);\n            if (context === null || context === void 0 ? void 0 : context.model.collaborative) {\n                return trans.__('In collaborative mode, the document is saved automatically after every change');\n            }\n            if (!isWritable()) {\n                return trans.__(`Document is read-only. \"Save\" is disabled; use \"Save as…\" instead`);\n            }\n        }\n        return trans.__('Save and create checkpoint');\n    };\n    const saveInProgress = new WeakSet();\n    commands.addCommand(CommandIDs.save, {\n        label: () => trans.__('Save %1', fileType(shell.currentWidget, docManager)),\n        caption,\n        icon: args => (args.toolbar ? saveIcon : undefined),\n        isEnabled: args => {\n            if (args._luminoEvent) {\n                return args._luminoEvent.type ===\n                    'keybinding'\n                    ? true\n                    : isWritable();\n            }\n            else {\n                return isWritable();\n            }\n        },\n        execute: async (args) => {\n            var _a, _b, _c, _d, _e;\n            // Checks that shell.currentWidget is valid:\n            const widget = shell.currentWidget;\n            const context = docManager.contextForWidget(widget);\n            if (isEnabled()) {\n                if (!context) {\n                    return showDialog({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [Dialog.okButton()]\n                    });\n                }\n                else {\n                    if (saveInProgress.has(context)) {\n                        return;\n                    }\n                    if (!((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) &&\n                        !context.model.collaborative) {\n                        let type = (_b = args._luminoEvent) === null || _b === void 0 ? void 0 : _b.type;\n                        if (args._luminoEvent && type === 'keybinding') {\n                            readonlyNotification(context.path);\n                            return;\n                        }\n                        else {\n                            return showDialog({\n                                title: trans.__('Cannot Save'),\n                                body: trans.__('Document is read-only'),\n                                buttons: [Dialog.okButton()]\n                            });\n                        }\n                    }\n                    saveInProgress.add(context);\n                    const oldName = PathExt.basename((_d = (_c = context.contentsModel) === null || _c === void 0 ? void 0 : _c.path) !== null && _d !== void 0 ? _d : '');\n                    let newName = oldName;\n                    if (docManager.renameUntitledFileOnSave &&\n                        widget.isUntitled === true) {\n                        const result = await InputDialog.getText({\n                            title: trans.__('Rename file'),\n                            okLabel: trans.__('Rename'),\n                            placeholder: trans.__('File name'),\n                            text: oldName,\n                            selectionRange: oldName.length - PathExt.extname(oldName).length,\n                            checkbox: {\n                                label: trans.__('Do not ask me again.'),\n                                caption: trans.__('If checked, you will not be asked to rename future untitled files when saving them.')\n                            }\n                        });\n                        if (result.button.accept) {\n                            newName = (_e = result.value) !== null && _e !== void 0 ? _e : oldName;\n                            widget.isUntitled = false;\n                            if (typeof result.isChecked === 'boolean') {\n                                const currentSetting = (await settingRegistry.get(docManagerPluginId, 'renameUntitledFileOnSave')).composite;\n                                if (result.isChecked === currentSetting) {\n                                    settingRegistry\n                                        .set(docManagerPluginId, 'renameUntitledFileOnSave', !result.isChecked)\n                                        .catch(reason => {\n                                        console.error(`Fail to set 'renameUntitledFileOnSave:\\n${reason}`);\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    try {\n                        await context.save();\n                        if (!(widget === null || widget === void 0 ? void 0 : widget.isDisposed)) {\n                            return context.createCheckpoint();\n                        }\n                    }\n                    catch (err) {\n                        // If the save was canceled by user-action, do nothing.\n                        if (err.name === 'ModalCancelError') {\n                            return;\n                        }\n                        throw err;\n                    }\n                    finally {\n                        saveInProgress.delete(context);\n                        if (newName !== oldName) {\n                            await context.rename(newName);\n                        }\n                    }\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.saveAll, {\n        label: () => trans.__('Save All'),\n        caption: trans.__('Save all open documents'),\n        isEnabled: () => {\n            return some(shell.widgets('main'), w => { var _a, _b, _c; return (_c = (_b = (_a = docManager.contextForWidget(w)) === null || _a === void 0 ? void 0 : _a.contentsModel) === null || _b === void 0 ? void 0 : _b.writable) !== null && _c !== void 0 ? _c : false; });\n        },\n        execute: () => {\n            var _a;\n            const promises = [];\n            const paths = new Set(); // Cache so we don't double save files.\n            for (const widget of shell.widgets('main')) {\n                const context = docManager.contextForWidget(widget);\n                if (context && !paths.has(context.path)) {\n                    if ((_a = context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable) {\n                        paths.add(context.path);\n                        promises.push(context.save());\n                    }\n                    else {\n                        readonlyNotification(context.path);\n                    }\n                }\n            }\n            return Promise.all(promises);\n        }\n    });\n    commands.addCommand(CommandIDs.saveAs, {\n        label: () => trans.__('Save %1 As…', fileType(shell.currentWidget, docManager)),\n        caption: trans.__('Save with new path'),\n        isEnabled,\n        execute: () => {\n            // Checks that shell.currentWidget is valid:\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(shell.currentWidget);\n                if (!context) {\n                    return showDialog({\n                        title: trans.__('Cannot Save'),\n                        body: trans.__('No context found for current widget!'),\n                        buttons: [Dialog.okButton()]\n                    });\n                }\n                const onChange = (sender, args) => {\n                    if (args.type === 'save' &&\n                        args.newValue &&\n                        args.newValue.path !== context.path) {\n                        void docManager.closeFile(context.path);\n                        void commands.execute(CommandIDs.open, {\n                            path: args.newValue.path\n                        });\n                    }\n                };\n                docManager.services.contents.fileChanged.connect(onChange);\n                void context\n                    .saveAs()\n                    .finally(() => docManager.services.contents.fileChanged.disconnect(onChange));\n            }\n        }\n    });\n    (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {\n        [\n            CommandIDs.reload,\n            CommandIDs.restoreCheckpoint,\n            CommandIDs.save,\n            CommandIDs.saveAll,\n            CommandIDs.saveAs\n        ].forEach(cmd => {\n            app.commands.notifyCommandChanged(cmd);\n        });\n    });\n    commands.addCommand(CommandIDs.toggleAutosave, {\n        label: trans.__('Autosave Documents'),\n        isToggled: () => docManager.autosave,\n        execute: () => {\n            const value = !docManager.autosave;\n            const key = 'autosave';\n            return settingRegistry\n                .set(docManagerPluginId, key, value)\n                .catch((reason) => {\n                console.error(`Failed to set ${docManagerPluginId}:${key} - ${reason.message}`);\n            });\n        }\n    });\n    if (palette) {\n        [\n            CommandIDs.reload,\n            CommandIDs.restoreCheckpoint,\n            CommandIDs.save,\n            CommandIDs.saveAs,\n            CommandIDs.toggleAutosave,\n            CommandIDs.duplicate\n        ].forEach(command => {\n            palette.addItem({ command, category });\n        });\n    }\n}\nfunction addLabCommands(app, docManager, labShell, widgetOpener, translator) {\n    const trans = translator.load('jupyterlab');\n    const { commands } = app;\n    // Returns the doc widget associated with the most recent contextmenu event.\n    const contextMenuWidget = () => {\n        var _a;\n        const pathRe = /[Pp]ath:\\s?(.*)\\n?/;\n        const test = (node) => { var _a; return !!((_a = node['title']) === null || _a === void 0 ? void 0 : _a.match(pathRe)); };\n        const node = app.contextMenuHitTest(test);\n        const pathMatch = node === null || node === void 0 ? void 0 : node['title'].match(pathRe);\n        return ((_a = (pathMatch && docManager.findWidget(pathMatch[1], null))) !== null && _a !== void 0 ? _a : \n        // Fall back to active doc widget if path cannot be obtained from event.\n        labShell.currentWidget);\n    };\n    // Returns `true` if the current widget has a document context.\n    const isEnabled = () => {\n        const { currentWidget } = labShell;\n        return !!(currentWidget && docManager.contextForWidget(currentWidget));\n    };\n    commands.addCommand(CommandIDs.clone, {\n        label: () => trans.__('New View for %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: args => {\n            const widget = contextMenuWidget();\n            const options = args['options'] || {\n                mode: 'split-right'\n            };\n            if (!widget) {\n                return;\n            }\n            // Clone the widget.\n            const child = docManager.cloneWidget(widget);\n            if (child) {\n                widgetOpener.open(child, options);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.rename, {\n        label: () => {\n            let t = fileType(contextMenuWidget(), docManager);\n            if (t) {\n                t = ' ' + t;\n            }\n            return trans.__('Rename%1…', t);\n        },\n        isEnabled,\n        execute: () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                return renameDialog(docManager, context);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.duplicate, {\n        label: () => trans.__('Duplicate %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: () => {\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                if (!context) {\n                    return;\n                }\n                return docManager.duplicate(context.path);\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.del, {\n        label: () => trans.__('Delete %1', fileType(contextMenuWidget(), docManager)),\n        isEnabled,\n        execute: async () => {\n            // Implies contextMenuWidget() !== null\n            if (isEnabled()) {\n                const context = docManager.contextForWidget(contextMenuWidget());\n                if (!context) {\n                    return;\n                }\n                const result = await showDialog({\n                    title: trans.__('Delete'),\n                    body: trans.__('Are you sure you want to delete %1', context.path),\n                    buttons: [\n                        Dialog.cancelButton(),\n                        Dialog.warnButton({ label: trans.__('Delete') })\n                    ]\n                });\n                if (result.button.accept) {\n                    await app.commands.execute('docmanager:delete-file', {\n                        path: context.path\n                    });\n                }\n            }\n        }\n    });\n    commands.addCommand(CommandIDs.showInFileBrowser, {\n        label: () => trans.__('Show in File Browser'),\n        isEnabled,\n        execute: async () => {\n            const widget = contextMenuWidget();\n            const context = widget && docManager.contextForWidget(widget);\n            if (!context) {\n                return;\n            }\n            // 'activate' is needed if this command is selected in the \"open tabs\" sidebar\n            await commands.execute('filebrowser:activate', { path: context.path });\n            await commands.execute('filebrowser:go-to-path', { path: context.path });\n        }\n    });\n    labShell.currentChanged.connect(() => {\n        [\n            CommandIDs.clone,\n            CommandIDs.rename,\n            CommandIDs.duplicate,\n            CommandIDs.del,\n            CommandIDs.showInFileBrowser\n        ].forEach(cmd => {\n            app.commands.notifyCommandChanged(cmd);\n        });\n    });\n}\n/**\n * Handle dirty state for a context.\n */\nfunction handleContext(status, context) {\n    let disposable = null;\n    const onStateChanged = (sender, args) => {\n        if (args.name === 'dirty') {\n            if (args.newValue === true) {\n                if (!disposable) {\n                    disposable = status.setDirty();\n                }\n            }\n            else if (disposable) {\n                disposable.dispose();\n                disposable = null;\n            }\n        }\n    };\n    void context.ready.then(() => {\n        context.model.stateChanged.connect(onStateChanged);\n        if (context.model.dirty) {\n            disposable = status.setDirty();\n        }\n    });\n    context.disposed.connect(() => {\n        if (disposable) {\n            disposable.dispose();\n        }\n    });\n}\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A counter for unique IDs.\n     */\n    Private.id = 0;\n    function createRevertConfirmNode(checkpoint, fileType, trans) {\n        const body = document.createElement('div');\n        const confirmMessage = document.createElement('p');\n        const confirmText = document.createTextNode(trans.__('Are you sure you want to revert the %1 to checkpoint? ', fileType));\n        const cannotUndoText = document.createElement('strong');\n        cannotUndoText.textContent = trans.__('This cannot be undone.');\n        confirmMessage.appendChild(confirmText);\n        confirmMessage.appendChild(cannotUndoText);\n        const lastCheckpointMessage = document.createElement('p');\n        const lastCheckpointText = document.createTextNode(trans.__('The checkpoint was last updated at: '));\n        const lastCheckpointDate = document.createElement('p');\n        const date = new Date(checkpoint.last_modified);\n        lastCheckpointDate.style.textAlign = 'center';\n        lastCheckpointDate.textContent =\n            Time.format(date) + ' (' + Time.formatHuman(date) + ')';\n        lastCheckpointMessage.appendChild(lastCheckpointText);\n        lastCheckpointMessage.appendChild(lastCheckpointDate);\n        body.appendChild(confirmMessage);\n        body.appendChild(lastCheckpointMessage);\n        return body;\n    }\n    Private.createRevertConfirmNode = createRevertConfirmNode;\n    /**\n     * Ask user for a checkpoint to revert to.\n     */\n    async function getTargetCheckpoint(checkpoints, trans) {\n        // the id could be too long to show so use the index instead\n        const indexSeparator = '.';\n        const items = checkpoints.map((checkpoint, index) => {\n            const isoDate = Time.format(checkpoint.last_modified);\n            const humanDate = Time.formatHuman(checkpoint.last_modified);\n            return `${index}${indexSeparator} ${isoDate} (${humanDate})`;\n        });\n        const selectedItem = (await InputDialog.getItem({\n            items: items,\n            title: trans.__('Choose a checkpoint')\n        })).value;\n        if (!selectedItem) {\n            return;\n        }\n        const selectedIndex = selectedItem.split(indexSeparator, 1)[0];\n        return checkpoints[parseInt(selectedIndex, 10)];\n    }\n    Private.getTargetCheckpoint = getTargetCheckpoint;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":["CommandIDs","PluginIDs","clearRecents","recentsManager","reopenClosed","mainPlugin","recentsManagerPlugin","id","description","autoStart","requires","IStateDB","optional","ISettingRegistry","ITranslator","provides","IRecentsManager","activate","app","stateDB","settingRegistry","translator","serviceManager","trans","nullTranslator","load","RecentsManager","contents","updateSettings","settings","maximalRecentsLength","get","composite","Promise","all","restored","then","_","changed","connect","commands","addCommand","execute","isEnabled","recentlyOpened","length","recentlyClosed","label","__","caption","clone","deleteFile","newUntitled","open","openBrowserTab","reload","rename","del","duplicate","restoreCheckpoint","save","saveAll","saveAs","download","toggleAutosave","showInFileBrowser","docManagerPluginId","openerPlugin","IDocumentWidgetOpener","shell","constructor","this","_opened","Signal","widget","options","Private","title","dataset","type","isAttached","add","activateById","emit","opened","contextsPlugin","IDocumentManager","ILabStatus","docManager","widgetOpener","status","contexts","WeakSet","context","contextForWidget","has","disposable","onStateChanged","sender","args","name","newValue","setDirty","dispose","ready","model","stateChanged","dirty","disposed","handleContext","manager","ISessionContextDialogs","JupyterLab","IInfo","translator_","sessionDialogs_","info","_a","docRegistry","registry","sessionDialogs","SessionContextDialogs","when","DocumentManager","opener","setBusy","undefined","isConnectedCallback","isConnected","docManagerPlugin","ICommandPalette","ILabShell","palette","labShell","category","currentWidget","isWritable","contentsModel","writable","readonlyNotification","contextPath","Notification","warning","autoClose","contextMenuWidget","pathRe","node","contextMenuHitTest","match","pathMatch","findWidget","fileType","mode","child","cloneWidget","t","renameDialog","path","async","showDialog","body","buttons","Dialog","cancelButton","warnButton","button","accept","currentChanged","forEach","cmd","notifyCommandChanged","addLabCommands","command","Error","errorTitle","ext","services","catch","error","showErrorMessage","factory","kernel","content","openOrReveal","iconClass","mnemonic","result","isDisposed","revert","okButton","listCheckpoints","checkpoints","targetCheckpoint","getTargetCheckpoint","reverse","RevertConfirmWidget","ariaLabel","readOnly","saveInProgress","collaborative","icon","toolbar","saveIcon","_luminoEvent","_b","_c","_d","_e","oldName","PathExt","basename","newName","renameUntitledFileOnSave","isUntitled","InputDialog","getText","okLabel","placeholder","text","selectionRange","extname","checkbox","value","isChecked","currentSetting","set","reason","console","createCheckpoint","err","delete","some","widgets","w","promises","paths","Set","push","onChange","closeFile","fileChanged","finally","disconnect","isToggled","autosave","key","message","addItem","addCommands","onSettingsUpdated","confirmClosingDocument","autosaveInterval","lastModifiedCheckMargin","renameUntitledFile","defaultViewers","overrides","Object","keys","ft","getFileType","getWidgetFactory","warn","fileTypes","setDefaultWidgetFactory","change","includes","transform","fetch","plugin","Array","from","map","join","factories","widgetFactories","f","schema","JSONExt","deepCopy","properties","savingStatusPlugin","IStatusBar","statusBar","saving","SavingStatus","registerStatusItem","item","align","isActive","activeStateChanged","pathStatusPlugin","PathStatus","rank","downloadPlugin","openBrowserTabPlugin","getDownloadUrl","url","window","location","href","ToolbarItems","createSaveButton","addCommandToolbarButtonClass","ReactWidget","create","UseSignal","signal","CommandToolbarButtonComponent","Widget","checkpoint","super","createRevertConfirmNode","fts","getFileTypesForPath","displayName","document","createElement","confirmMessage","confirmText","createTextNode","cannotUndoText","textContent","appendChild","lastCheckpointMessage","lastCheckpointText","lastCheckpointDate","date","Date","last_modified","style","textAlign","Time","format","formatHuman","items","index","selectedItem","getItem","selectedIndex","split","parseInt"],"sourceRoot":""}