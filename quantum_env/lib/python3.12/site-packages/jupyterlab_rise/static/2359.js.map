{"version":3,"file":"2359.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/coreutils/dist/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@lumino/algorithm')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@lumino/algorithm'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.lumino_coreutils = {}, global.lumino_algorithm));\n})(this, (function (exports, algorithm) { 'use strict';\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for JSON-specific functions.\n     */\n    exports.JSONExt = void 0;\n    (function (JSONExt) {\n        /**\n         * A shared frozen empty JSONObject\n         */\n        JSONExt.emptyObject = Object.freeze({});\n        /**\n         * A shared frozen empty JSONArray\n         */\n        JSONExt.emptyArray = Object.freeze([]);\n        /**\n         * Test whether a JSON value is a primitive.\n         *\n         * @param value - The JSON value of interest.\n         *\n         * @returns `true` if the value is a primitive,`false` otherwise.\n         */\n        function isPrimitive(value) {\n            return (value === null ||\n                typeof value === 'boolean' ||\n                typeof value === 'number' ||\n                typeof value === 'string');\n        }\n        JSONExt.isPrimitive = isPrimitive;\n        function isArray(value) {\n            return Array.isArray(value);\n        }\n        JSONExt.isArray = isArray;\n        function isObject(value) {\n            return !isPrimitive(value) && !isArray(value);\n        }\n        JSONExt.isObject = isObject;\n        /**\n         * Compare two JSON values for deep equality.\n         *\n         * @param first - The first JSON value of interest.\n         *\n         * @param second - The second JSON value of interest.\n         *\n         * @returns `true` if the values are equivalent, `false` otherwise.\n         */\n        function deepEqual(first, second) {\n            // Check referential and primitive equality first.\n            if (first === second) {\n                return true;\n            }\n            // If one is a primitive, the `===` check ruled out the other.\n            if (isPrimitive(first) || isPrimitive(second)) {\n                return false;\n            }\n            // Test whether they are arrays.\n            let a1 = isArray(first);\n            let a2 = isArray(second);\n            // Bail if the types are different.\n            if (a1 !== a2) {\n                return false;\n            }\n            // If they are both arrays, compare them.\n            if (a1 && a2) {\n                return deepArrayEqual(first, second);\n            }\n            // At this point, they must both be objects.\n            return deepObjectEqual(first, second);\n        }\n        JSONExt.deepEqual = deepEqual;\n        /**\n         * Create a deep copy of a JSON value.\n         *\n         * @param value - The JSON value to copy.\n         *\n         * @returns A deep copy of the given JSON value.\n         */\n        function deepCopy(value) {\n            // Do nothing for primitive values.\n            if (isPrimitive(value)) {\n                return value;\n            }\n            // Deep copy an array.\n            if (isArray(value)) {\n                return deepArrayCopy(value);\n            }\n            // Deep copy an object.\n            return deepObjectCopy(value);\n        }\n        JSONExt.deepCopy = deepCopy;\n        /**\n         * Compare two JSON arrays for deep equality.\n         */\n        function deepArrayEqual(first, second) {\n            // Check referential equality first.\n            if (first === second) {\n                return true;\n            }\n            // Test the arrays for equal length.\n            if (first.length !== second.length) {\n                return false;\n            }\n            // Compare the values for equality.\n            for (let i = 0, n = first.length; i < n; ++i) {\n                if (!deepEqual(first[i], second[i])) {\n                    return false;\n                }\n            }\n            // At this point, the arrays are equal.\n            return true;\n        }\n        /**\n         * Compare two JSON objects for deep equality.\n         */\n        function deepObjectEqual(first, second) {\n            // Check referential equality first.\n            if (first === second) {\n                return true;\n            }\n            // Check for the first object's keys in the second object.\n            for (let key in first) {\n                if (first[key] !== undefined && !(key in second)) {\n                    return false;\n                }\n            }\n            // Check for the second object's keys in the first object.\n            for (let key in second) {\n                if (second[key] !== undefined && !(key in first)) {\n                    return false;\n                }\n            }\n            // Compare the values for equality.\n            for (let key in first) {\n                // Get the values.\n                let firstValue = first[key];\n                let secondValue = second[key];\n                // If both are undefined, ignore the key.\n                if (firstValue === undefined && secondValue === undefined) {\n                    continue;\n                }\n                // If only one value is undefined, the objects are not equal.\n                if (firstValue === undefined || secondValue === undefined) {\n                    return false;\n                }\n                // Compare the values.\n                if (!deepEqual(firstValue, secondValue)) {\n                    return false;\n                }\n            }\n            // At this point, the objects are equal.\n            return true;\n        }\n        /**\n         * Create a deep copy of a JSON array.\n         */\n        function deepArrayCopy(value) {\n            let result = new Array(value.length);\n            for (let i = 0, n = value.length; i < n; ++i) {\n                result[i] = deepCopy(value[i]);\n            }\n            return result;\n        }\n        /**\n         * Create a deep copy of a JSON object.\n         */\n        function deepObjectCopy(value) {\n            let result = {};\n            for (let key in value) {\n                // Ignore undefined values.\n                let subvalue = value[key];\n                if (subvalue === undefined) {\n                    continue;\n                }\n                result[key] = deepCopy(subvalue);\n            }\n            return result;\n        }\n    })(exports.JSONExt || (exports.JSONExt = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * An object which stores MIME data for general application use.\n     *\n     * #### Notes\n     * This class does not attempt to enforce \"correctness\" of MIME types\n     * and their associated data. Since this class is designed to transfer\n     * arbitrary data and objects within the same application, it assumes\n     * that the user provides correct and accurate data.\n     */\n    class MimeData {\n        constructor() {\n            this._types = [];\n            this._values = [];\n        }\n        /**\n         * Get an array of the MIME types contained within the dataset.\n         *\n         * @returns A new array of the MIME types, in order of insertion.\n         */\n        types() {\n            return this._types.slice();\n        }\n        /**\n         * Test whether the dataset has an entry for the given type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @returns `true` if the dataset contains a value for the given\n         *   MIME type, `false` otherwise.\n         */\n        hasData(mime) {\n            return this._types.indexOf(mime) !== -1;\n        }\n        /**\n         * Get the data value for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @returns The value for the given MIME type, or `undefined` if\n         *   the dataset does not contain a value for the type.\n         */\n        getData(mime) {\n            let i = this._types.indexOf(mime);\n            return i !== -1 ? this._values[i] : undefined;\n        }\n        /**\n         * Set the data value for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * @param data - The data value for the given MIME type.\n         *\n         * #### Notes\n         * This will overwrite any previous entry for the MIME type.\n         */\n        setData(mime, data) {\n            this.clearData(mime);\n            this._types.push(mime);\n            this._values.push(data);\n        }\n        /**\n         * Remove the data entry for the given MIME type.\n         *\n         * @param mime - The MIME type of interest.\n         *\n         * #### Notes\n         * This is a no-op if there is no entry for the given MIME type.\n         */\n        clearData(mime) {\n            let i = this._types.indexOf(mime);\n            if (i !== -1) {\n                this._types.splice(i, 1);\n                this._values.splice(i, 1);\n            }\n        }\n        /**\n         * Remove all data entries from the dataset.\n         */\n        clear() {\n            this._types.length = 0;\n            this._values.length = 0;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /**\n     * Plugin registry.\n     */\n    class PluginRegistry {\n        constructor(options = {}) {\n            this._application = null;\n            this._validatePlugin = () => true;\n            this._plugins = new Map();\n            this._services = new Map();\n            if (options.validatePlugin) {\n                console.info('Plugins may be rejected by the custom validation plugin method.');\n                this._validatePlugin = options.validatePlugin;\n            }\n        }\n        /**\n         * The application object.\n         *\n         * It will be provided as first argument to the\n         * plugins activation and deactivation functions.\n         *\n         * It can only be set once.\n         *\n         * By default, it is `null`.\n         */\n        get application() {\n            return this._application;\n        }\n        set application(v) {\n            if (this._application !== null) {\n                throw Error('PluginRegistry.application is already set. It cannot be overridden.');\n            }\n            this._application = v;\n        }\n        /**\n         * The list of all the deferred plugins.\n         */\n        get deferredPlugins() {\n            return Array.from(this._plugins)\n                .filter(([id, plugin]) => plugin.autoStart === 'defer')\n                .map(([id, plugin]) => id);\n        }\n        /**\n         * Get a plugin description.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns The plugin description.\n         */\n        getPluginDescription(id) {\n            var _a, _b;\n            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : '';\n        }\n        /**\n         * Test whether a plugin is registered with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns `true` if the plugin is registered, `false` otherwise.\n         */\n        hasPlugin(id) {\n            return this._plugins.has(id);\n        }\n        /**\n         * Test whether a plugin is activated with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns `true` if the plugin is activated, `false` otherwise.\n         */\n        isPluginActivated(id) {\n            var _a, _b;\n            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;\n        }\n        /**\n         * List the IDs of the plugins registered with the application.\n         *\n         * @returns A new array of the registered plugin IDs.\n         */\n        listPlugins() {\n            return Array.from(this._plugins.keys());\n        }\n        /**\n         * Register a plugin with the application.\n         *\n         * @param plugin - The plugin to register.\n         *\n         * #### Notes\n         * An error will be thrown if a plugin with the same ID is already\n         * registered, or if the plugin has a circular dependency.\n         *\n         * If the plugin provides a service which has already been provided\n         * by another plugin, the new service will override the old service.\n         */\n        registerPlugin(plugin) {\n            // Throw an error if the plugin ID is already registered.\n            if (this._plugins.has(plugin.id)) {\n                throw new TypeError(`Plugin '${plugin.id}' is already registered.`);\n            }\n            if (!this._validatePlugin(plugin)) {\n                throw new Error(`Plugin '${plugin.id}' is not valid.`);\n            }\n            // Create the normalized plugin data.\n            const data = Private.createPluginData(plugin);\n            // Ensure the plugin does not cause a cyclic dependency.\n            Private.ensureNoCycle(data, this._plugins, this._services);\n            // Add the service token to the service map.\n            if (data.provides) {\n                this._services.set(data.provides, data.id);\n            }\n            // Add the plugin to the plugin map.\n            this._plugins.set(data.id, data);\n        }\n        /**\n         * Register multiple plugins with the application.\n         *\n         * @param plugins - The plugins to register.\n         *\n         * #### Notes\n         * This calls `registerPlugin()` for each of the given plugins.\n         */\n        registerPlugins(plugins) {\n            for (const plugin of plugins) {\n                this.registerPlugin(plugin);\n            }\n        }\n        /**\n         * Deregister a plugin with the application.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @param force - Whether to deregister the plugin even if it is active.\n         */\n        deregisterPlugin(id, force) {\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                return;\n            }\n            if (plugin.activated && !force) {\n                throw new Error(`Plugin '${id}' is still active.`);\n            }\n            this._plugins.delete(id);\n        }\n        /**\n         * Activate the plugin with the given ID.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns A promise which resolves when the plugin is activated\n         *   or rejects with an error if it cannot be activated.\n         */\n        async activatePlugin(id) {\n            // Reject the promise if the plugin is not registered.\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                throw new ReferenceError(`Plugin '${id}' is not registered.`);\n            }\n            // Resolve immediately if the plugin is already activated.\n            if (plugin.activated) {\n                return;\n            }\n            // Return the pending resolver promise if it exists.\n            if (plugin.promise) {\n                return plugin.promise;\n            }\n            // Resolve the required services for the plugin.\n            const required = plugin.requires.map(t => this.resolveRequiredService(t));\n            // Resolve the optional services for the plugin.\n            const optional = plugin.optional.map(t => this.resolveOptionalService(t));\n            // Setup the resolver promise for the plugin.\n            plugin.promise = Promise.all([...required, ...optional])\n                .then(services => plugin.activate.apply(undefined, [this.application, ...services]))\n                .then(service => {\n                plugin.service = service;\n                plugin.activated = true;\n                plugin.promise = null;\n            })\n                .catch(error => {\n                plugin.promise = null;\n                throw error;\n            });\n            // Return the pending resolver promise.\n            return plugin.promise;\n        }\n        /**\n         * Activate all the deferred plugins.\n         *\n         * @returns A promise which will resolve when each plugin is activated\n         * or rejects with an error if one cannot be activated.\n         */\n        async activatePlugins(kind, options = {}) {\n            switch (kind) {\n                case 'defer': {\n                    const promises = this.deferredPlugins\n                        .filter(pluginId => this._plugins.get(pluginId).autoStart)\n                        .map(pluginId => {\n                        return this.activatePlugin(pluginId);\n                    });\n                    await Promise.all(promises);\n                    break;\n                }\n                case 'startUp': {\n                    // Collect the ids of the startup plugins.\n                    const startups = Private.collectStartupPlugins(this._plugins, options);\n                    // Generate the activation promises.\n                    const promises = startups.map(async (id) => {\n                        try {\n                            return await this.activatePlugin(id);\n                        }\n                        catch (error) {\n                            console.error(`Plugin '${id}' failed to activate.`, error);\n                        }\n                    });\n                    await Promise.all(promises);\n                    break;\n                }\n            }\n        }\n        /**\n         * Deactivate the plugin and its downstream dependents if and only if the\n         * plugin and its dependents all support `deactivate`.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @returns A list of IDs of downstream plugins deactivated with this one.\n         */\n        async deactivatePlugin(id) {\n            // Reject the promise if the plugin is not registered.\n            const plugin = this._plugins.get(id);\n            if (!plugin) {\n                throw new ReferenceError(`Plugin '${id}' is not registered.`);\n            }\n            // Bail early if the plugin is not activated.\n            if (!plugin.activated) {\n                return [];\n            }\n            // Check that this plugin can deactivate.\n            if (!plugin.deactivate) {\n                throw new TypeError(`Plugin '${id}'#deactivate() method missing`);\n            }\n            // Find the optimal deactivation order for plugins downstream of this one.\n            const manifest = Private.findDependents(id, this._plugins, this._services);\n            const downstream = manifest.map(id => this._plugins.get(id));\n            // Check that all downstream plugins can deactivate.\n            for (const plugin of downstream) {\n                if (!plugin.deactivate) {\n                    throw new TypeError(`Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`);\n                }\n            }\n            // Deactivate all downstream plugins.\n            for (const plugin of downstream) {\n                const services = [...plugin.requires, ...plugin.optional].map(service => {\n                    const id = this._services.get(service);\n                    return id ? this._plugins.get(id).service : null;\n                });\n                // Await deactivation so the next plugins only receive active services.\n                await plugin.deactivate(this.application, ...services);\n                plugin.service = null;\n                plugin.activated = false;\n            }\n            // Remove plugin ID and return manifest of deactivated plugins.\n            manifest.pop();\n            return manifest;\n        }\n        /**\n         * Resolve a required service of a given type.\n         *\n         * @param token - The token for the service type of interest.\n         *\n         * @returns A promise which resolves to an instance of the requested\n         *   service, or rejects with an error if it cannot be resolved.\n         *\n         * #### Notes\n         * Services are singletons. The same instance will be returned each\n         * time a given service token is resolved.\n         *\n         * If the plugin which provides the service has not been activated,\n         * resolving the service will automatically activate the plugin.\n         *\n         * User code will not typically call this method directly. Instead,\n         * the required services for the user's plugins will be resolved\n         * automatically when the plugin is activated.\n         */\n        async resolveRequiredService(token) {\n            // Reject the promise if there is no provider for the type.\n            const id = this._services.get(token);\n            if (!id) {\n                throw new TypeError(`No provider for: ${token.name}.`);\n            }\n            // Activate the plugin if necessary.\n            const plugin = this._plugins.get(id);\n            if (!plugin.activated) {\n                await this.activatePlugin(id);\n            }\n            return plugin.service;\n        }\n        /**\n         * Resolve an optional service of a given type.\n         *\n         * @param token - The token for the service type of interest.\n         *\n         * @returns A promise which resolves to an instance of the requested\n         *   service, or `null` if it cannot be resolved.\n         *\n         * #### Notes\n         * Services are singletons. The same instance will be returned each\n         * time a given service token is resolved.\n         *\n         * If the plugin which provides the service has not been activated,\n         * resolving the service will automatically activate the plugin.\n         *\n         * User code will not typically call this method directly. Instead,\n         * the optional services for the user's plugins will be resolved\n         * automatically when the plugin is activated.\n         */\n        async resolveOptionalService(token) {\n            // Resolve with `null` if there is no provider for the type.\n            const id = this._services.get(token);\n            if (!id) {\n                return null;\n            }\n            // Activate the plugin if necessary.\n            const plugin = this._plugins.get(id);\n            if (!plugin.activated) {\n                try {\n                    await this.activatePlugin(id);\n                }\n                catch (reason) {\n                    console.error(reason);\n                    return null;\n                }\n            }\n            return plugin.service;\n        }\n    }\n    /**\n     * The namespace for the module implementation details.\n     */\n    var Private;\n    (function (Private) {\n        class PluginData {\n            constructor(plugin) {\n                var _a, _b, _c, _d;\n                this._activated = false;\n                this._promise = null;\n                this._service = null;\n                this.id = plugin.id;\n                this.description = (_a = plugin.description) !== null && _a !== void 0 ? _a : '';\n                this.activate = plugin.activate;\n                this.deactivate = (_b = plugin.deactivate) !== null && _b !== void 0 ? _b : null;\n                this.provides = (_c = plugin.provides) !== null && _c !== void 0 ? _c : null;\n                this.autoStart = (_d = plugin.autoStart) !== null && _d !== void 0 ? _d : false;\n                this.requires = plugin.requires ? plugin.requires.slice() : [];\n                this.optional = plugin.optional ? plugin.optional.slice() : [];\n            }\n            /**\n             * Whether the plugin has been activated.\n             */\n            get activated() {\n                return this._activated;\n            }\n            set activated(a) {\n                this._activated = a;\n            }\n            /**\n             * The resolved service for the plugin, or `null`.\n             */\n            get service() {\n                return this._service;\n            }\n            set service(s) {\n                this._service = s;\n            }\n            /**\n             * The pending resolver promise, or `null`.\n             */\n            get promise() {\n                return this._promise;\n            }\n            set promise(p) {\n                this._promise = p;\n            }\n        }\n        /**\n         * Create a normalized plugin data object for the given plugin.\n         */\n        function createPluginData(plugin) {\n            return new PluginData(plugin);\n        }\n        Private.createPluginData = createPluginData;\n        /**\n         * Ensure no cycle is present in the plugin resolution graph.\n         *\n         * If a cycle is detected, an error will be thrown.\n         */\n        function ensureNoCycle(plugin, plugins, services) {\n            const dependencies = [...plugin.requires, ...plugin.optional];\n            const visit = (token) => {\n                if (token === plugin.provides) {\n                    return true;\n                }\n                const id = services.get(token);\n                if (!id) {\n                    return false;\n                }\n                const visited = plugins.get(id);\n                const dependencies = [...visited.requires, ...visited.optional];\n                if (dependencies.length === 0) {\n                    return false;\n                }\n                trace.push(id);\n                if (dependencies.some(visit)) {\n                    return true;\n                }\n                trace.pop();\n                return false;\n            };\n            // Bail early if there cannot be a cycle.\n            if (!plugin.provides || dependencies.length === 0) {\n                return;\n            }\n            // Setup a stack to trace service resolution.\n            const trace = [plugin.id];\n            // Throw an exception if a cycle is present.\n            if (dependencies.some(visit)) {\n                throw new ReferenceError(`Cycle detected: ${trace.join(' -> ')}.`);\n            }\n        }\n        Private.ensureNoCycle = ensureNoCycle;\n        /**\n         * Find dependents in deactivation order.\n         *\n         * @param id - The ID of the plugin of interest.\n         *\n         * @param plugins - The map containing all plugins.\n         *\n         * @param services - The map containing all services.\n         *\n         * @returns A list of dependent plugin IDs in order of deactivation\n         *\n         * #### Notes\n         * The final item of the returned list is always the plugin of interest.\n         */\n        function findDependents(id, plugins, services) {\n            const edges = new Array();\n            const add = (id) => {\n                const plugin = plugins.get(id);\n                // FIXME In the case of missing optional dependencies, we may consider\n                // deactivating and reactivating the plugin without the missing service.\n                const dependencies = [...plugin.requires, ...plugin.optional];\n                edges.push(...dependencies.reduce((acc, dep) => {\n                    const service = services.get(dep);\n                    if (service) {\n                        // An edge is oriented from dependent to provider.\n                        acc.push([id, service]);\n                    }\n                    return acc;\n                }, []));\n            };\n            for (const id of plugins.keys()) {\n                add(id);\n            }\n            // Filter edges\n            // - Get all packages that dependent on the package to be deactivated\n            const newEdges = edges.filter(edge => edge[1] === id);\n            let oldSize = 0;\n            while (newEdges.length > oldSize) {\n                const previousSize = newEdges.length;\n                // Get all packages that dependent on packages that will be deactivated\n                const packagesOfInterest = new Set(newEdges.map(edge => edge[0]));\n                for (const poi of packagesOfInterest) {\n                    edges\n                        .filter(edge => edge[1] === poi)\n                        .forEach(edge => {\n                        // We check it is not already included to deal with circular dependencies\n                        if (!newEdges.includes(edge)) {\n                            newEdges.push(edge);\n                        }\n                    });\n                }\n                oldSize = previousSize;\n            }\n            const sorted = algorithm.topologicSort(newEdges);\n            const index = sorted.findIndex(candidate => candidate === id);\n            if (index === -1) {\n                return [id];\n            }\n            return sorted.slice(0, index + 1);\n        }\n        Private.findDependents = findDependents;\n        /**\n         * Collect the IDs of the plugins to activate on startup.\n         */\n        function collectStartupPlugins(plugins, options) {\n            // Create a set to hold the plugin IDs.\n            const collection = new Set();\n            // Collect the auto-start (non deferred) plugins.\n            for (const id of plugins.keys()) {\n                if (plugins.get(id).autoStart === true) {\n                    collection.add(id);\n                }\n            }\n            // Add the startup plugins.\n            if (options.startPlugins) {\n                for (const id of options.startPlugins) {\n                    collection.add(id);\n                }\n            }\n            // Remove the ignored plugins.\n            if (options.ignorePlugins) {\n                for (const id of options.ignorePlugins) {\n                    collection.delete(id);\n                }\n            }\n            // Return the collected startup plugins.\n            return Array.from(collection);\n        }\n        Private.collectStartupPlugins = collectStartupPlugins;\n    })(Private || (Private = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A class which wraps a promise into a delegate object.\n     *\n     * #### Notes\n     * This class is useful when the logic to resolve or reject a promise\n     * cannot be defined at the point where the promise is created.\n     */\n    class PromiseDelegate {\n        /**\n         * Construct a new promise delegate.\n         */\n        constructor() {\n            this.promise = new Promise((resolve, reject) => {\n                this._resolve = resolve;\n                this._reject = reject;\n            });\n        }\n        /**\n         * Resolve the wrapped promise with the given value.\n         *\n         * @param value - The value to use for resolving the promise.\n         */\n        resolve(value) {\n            let resolve = this._resolve;\n            resolve(value);\n        }\n        /**\n         * Reject the wrapped promise with the given value.\n         *\n         * @reason - The reason for rejecting the promise.\n         */\n        reject(reason) {\n            let reject = this._reject;\n            reject(reason);\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A runtime object which captures compile-time type information.\n     *\n     * #### Notes\n     * A token captures the compile-time type of an interface or class in\n     * an object which can be used at runtime in a type-safe fashion.\n     */\n    class Token {\n        /**\n         * Construct a new token.\n         *\n         * @param name - A human readable name for the token.\n         * @param description - Token purpose description for documentation.\n         */\n        constructor(name, description) {\n            this.name = name;\n            this.description = description !== null && description !== void 0 ? description : '';\n            this._tokenStructuralPropertyT = null;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    // Fallback\n    function fallbackRandomValues(buffer) {\n        let value = 0;\n        for (let i = 0, n = buffer.length; i < n; ++i) {\n            if (i % 4 === 0) {\n                value = (Math.random() * 0xffffffff) >>> 0;\n            }\n            buffer[i] = value & 0xff;\n            value >>>= 8;\n        }\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for random number related functionality.\n     */\n    exports.Random = void 0;\n    (function (Random) {\n        /**\n         * A function which generates random bytes.\n         *\n         * @param buffer - The `Uint8Array` to fill with random bytes.\n         *\n         * #### Notes\n         * A cryptographically strong random number generator will be used if\n         * available. Otherwise, `Math.random` will be used as a fallback for\n         * randomness.\n         *\n         * The following RNGs are supported, listed in order of precedence:\n         *   - `window.crypto.getRandomValues`\n         *   - `window.msCrypto.getRandomValues`\n         *   - `require('crypto').randomFillSync\n         *   - `require('crypto').randomBytes\n         *   - `Math.random`\n         */\n        Random.getRandomValues = (() => {\n            // Look up the crypto module if available.\n            const crypto = (typeof window !== 'undefined' && (window.crypto || window.msCrypto)) ||\n                null;\n            // Modern browsers and IE 11\n            if (crypto && typeof crypto.getRandomValues === 'function') {\n                return function getRandomValues(buffer) {\n                    return crypto.getRandomValues(buffer);\n                };\n            }\n            // Fallback\n            return fallbackRandomValues;\n        })();\n    })(exports.Random || (exports.Random = {}));\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * A function which creates a function that generates UUID v4 identifiers.\n     *\n     * @returns A new function that creates a UUID v4 string.\n     *\n     * #### Notes\n     * This implementation complies with RFC 4122.\n     *\n     * This uses `Random.getRandomValues()` for random bytes, which in\n     * turn will use the underlying `crypto` module of the platform if\n     * it is available. The fallback for randomness is `Math.random`.\n     */\n    function uuid4Factory(getRandomValues) {\n        // Create a 16 byte array to hold the random values.\n        const bytes = new Uint8Array(16);\n        // Create a look up table from bytes to hex strings.\n        const lut = new Array(256);\n        // Pad the single character hex digits with a leading zero.\n        for (let i = 0; i < 16; ++i) {\n            lut[i] = '0' + i.toString(16);\n        }\n        // Populate the rest of the hex digits.\n        for (let i = 16; i < 256; ++i) {\n            lut[i] = i.toString(16);\n        }\n        // Return a function which generates the UUID.\n        return function uuid4() {\n            // Get a new batch of random values.\n            getRandomValues(bytes);\n            // Set the UUID version number to 4.\n            bytes[6] = 0x40 | (bytes[6] & 0x0f);\n            // Set the clock sequence bit to the RFC spec.\n            bytes[8] = 0x80 | (bytes[8] & 0x3f);\n            // Assemble the UUID string.\n            return (lut[bytes[0]] +\n                lut[bytes[1]] +\n                lut[bytes[2]] +\n                lut[bytes[3]] +\n                '-' +\n                lut[bytes[4]] +\n                lut[bytes[5]] +\n                '-' +\n                lut[bytes[6]] +\n                lut[bytes[7]] +\n                '-' +\n                lut[bytes[8]] +\n                lut[bytes[9]] +\n                '-' +\n                lut[bytes[10]] +\n                lut[bytes[11]] +\n                lut[bytes[12]] +\n                lut[bytes[13]] +\n                lut[bytes[14]] +\n                lut[bytes[15]]);\n        };\n    }\n\n    // Copyright (c) Jupyter Development Team.\n    // Distributed under the terms of the Modified BSD License.\n    /*-----------------------------------------------------------------------------\n    | Copyright (c) 2014-2017, PhosphorJS Contributors\n    |\n    | Distributed under the terms of the BSD 3-Clause License.\n    |\n    | The full license is in the file LICENSE, distributed with this software.\n    |----------------------------------------------------------------------------*/\n    /**\n     * The namespace for UUID related functionality.\n     */\n    exports.UUID = void 0;\n    (function (UUID) {\n        /**\n         * A function which generates UUID v4 identifiers.\n         *\n         * @returns A new UUID v4 string.\n         *\n         * #### Notes\n         * This implementation complies with RFC 4122.\n         *\n         * This uses `Random.getRandomValues()` for random bytes, which in\n         * turn will use the underlying `crypto` module of the platform if\n         * it is available. The fallback for randomness is `Math.random`.\n         */\n        UUID.uuid4 = uuid4Factory(exports.Random.getRandomValues);\n    })(exports.UUID || (exports.UUID = {}));\n\n    exports.MimeData = MimeData;\n    exports.PluginRegistry = PluginRegistry;\n    exports.PromiseDelegate = PromiseDelegate;\n    exports.Token = Token;\n\n}));\n//# sourceMappingURL=index.js.map\n"],"names":["exports","algorithm","JSONExt","isPrimitive","value","isArray","Array","deepEqual","first","second","a1","a2","length","i","n","deepArrayEqual","key","undefined","firstValue","secondValue","deepObjectEqual","deepCopy","result","deepArrayCopy","subvalue","deepObjectCopy","emptyObject","Object","freeze","emptyArray","isObject","Private","PluginData","constructor","plugin","_a","_b","_c","_d","this","_activated","_promise","_service","id","description","activate","deactivate","provides","autoStart","requires","slice","optional","activated","a","service","s","promise","p","createPluginData","ensureNoCycle","plugins","services","dependencies","visit","token","get","visited","trace","push","some","pop","ReferenceError","join","findDependents","edges","add","reduce","acc","dep","keys","newEdges","filter","edge","oldSize","previousSize","packagesOfInterest","Set","map","poi","forEach","includes","sorted","topologicSort","index","findIndex","candidate","collectStartupPlugins","options","collection","startPlugins","ignorePlugins","delete","from","fallbackRandomValues","buffer","Math","random","Random","getRandomValues","crypto","window","msCrypto","UUID","uuid4","bytes","Uint8Array","lut","toString","uuid4Factory","MimeData","_types","_values","types","hasData","mime","indexOf","getData","setData","data","clearData","splice","clear","PluginRegistry","_application","_validatePlugin","_plugins","Map","_services","validatePlugin","console","info","application","v","Error","deferredPlugins","getPluginDescription","hasPlugin","has","isPluginActivated","listPlugins","registerPlugin","TypeError","set","registerPlugins","deregisterPlugin","force","activatePlugin","required","t","resolveRequiredService","resolveOptionalService","Promise","all","then","apply","catch","error","activatePlugins","kind","promises","pluginId","async","deactivatePlugin","manifest","downstream","name","reason","PromiseDelegate","resolve","reject","_resolve","_reject","Token","_tokenStructuralPropertyT","factory"],"sourceRoot":""}